{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js');\n\n// An object for wrangling textures\n// An assumption here is that doing anything with textures is fairly expensive, so the code should be expressive rather than performant\nCrafty.TextureManager = TextureManager;\n\nfunction TextureManager (gl, webgl) {\n    this.gl = gl;\n    this.webgl = webgl;\n    // The maximum number of units the environment says it supports\n    this.max_units =  gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n    // An array of textures bound to a texture unit; position corresponds to the unit in question\n    this.bound_textures = [];\n    // A dictionary of registered textures, so that multiple copies of the same texture aren't generated\n    this.registered_textures = {};\n    // Try to track which texture is active\n    this.active = null;\n}\n\nTextureManager.prototype = {\n\n    // Clear out the bound textures and other existing state\n    reset: function(){\n        var t;\n        for (var i = 0; i < this.bound_textures.length; i++){\n            t = this.bound_textures[i];\n            t.unbind();\n        }\n        this.bound_textures = [];\n        this.active = null;\n    },\n\n    // creates a texture out of the given image and repeating state\n    // The url is just used to generate a unique id for the texture\n    makeTexture: function(url, image, repeating) {\n        // gl is the context, webgl is the Crafty object containing prefs/etc\n        // var gl = this.gl;\n        var webgl = this.webgl;\n\n        // Check whether a texture that matches the one requested already exists\n        var id =  \"texture-(r:\" + repeating + \")-\" + url;\n        if (typeof this.registered_textures[id] !== 'undefined')\n            return this.registered_textures[id];\n\n        // Create a texture, bind it to the next available unit\n        var t = new TextureWrapper(this, id);\n        this.registered_textures[id] = t;\n        this.bindTexture(t);\n\n        // Set the properties of the texture \n        t.setImage(image);\n        t.setFilter(webgl.texture_filter);\n        t.setRepeat(repeating);\n\n        return t;\n    },\n\n    // Returns the bound texture of smallest size\n    // If we have more textures than available units, we should preferentially leave the larger textures bound?\n    smallest: function() {\n        var min_size = Infinity;\n        var index = null;\n        for (var i=0; i<this.bound_textures.length; i++) {\n            var t = this.bound_textures[i];\n            if (t.size < min_size) {\n                min_size = t.size;\n                index = i;\n            }\n        }\n        return index;\n    },\n\n    // Returns either the first empty unit, or the unit of the smallest bound texture\n    getAvailableUnit: function() {\n        if (this.bound_textures.length < this.max_units) {\n            return this.bound_textures.length;\n        } else {\n            return this.smallest();\n        }\n    },\n\n    // takes a texture object and, if it isn't associated with a unit, binds it to one\n    bindTexture: function(t) {\n        // return if the texture is already bound\n        if (t.unit !== null) return;\n        var i = this.getAvailableUnit();\n        if (this.bound_textures[i]){\n            this.unbindTexture(this.bound_textures[i]);\n        }\n        this.bound_textures[i] = t;\n        t.bind(i);\n\n    },\n\n    // We don't actually \"unbind\" the texture -- we just set it's bound state to null\n    // This is called before another texture is bound\n    unbindTexture: function(t) {\n        t.unbind();\n    },\n\n    setActiveTexture: function(t) {\n        if (this.active === t.id) return;\n        this.gl.activeTexture(this.gl[t.name]);\n        this.active = t.unit;\n    }\n\n};\n\n// An object for abstracting out the gl calls associated with textures\nCrafty.TextureWrapper = TextureWrapper;\n\nfunction TextureWrapper (manager, id){\n    this.manager = manager;\n    this.gl = manager.gl;\n    this.glTexture = this.gl.createTexture();\n    this.id = id;\n    this.active = false;\n    this.unit = null;\n    this.powerOfTwo = false;\n}\n\nTextureWrapper.prototype = {\n\n    // Given a number, binds to the corresponding texture unit\n    bind: function(unit) {\n        var gl = this.gl;\n        this.unit = unit;\n        this.name = \"TEXTURE\" + unit;\n        this.manager.setActiveTexture(this);\n        gl.bindTexture(gl.TEXTURE_2D, this.glTexture);\n    },\n\n    // Check whether this texture is active (important for setting properties)\n    isActive: function() {\n        return (this.manager.active === this.unit);\n    },\n\n    // Since gl doesn't require unbinding, just clears the metadata\n    unbind: function() {\n        this.unit = null;\n        this.name = null;\n        if(this.isActive())\n            this.manager.active = null;\n    },\n\n    // actually loads an image into the texture object; sets the appropriate metadata\n    setImage: function(image) {\n        if(!this.isActive()) throw(\"Trying to set image of texture that isn't active\");\n        this.width = image.width;\n        this.height = image.height;\n        this.size = image.width * image.height;\n        this.powerOfTwo = !((Math.log(image.width)/Math.LN2 !== Math.floor(Math.log(image.width)/Math.LN2)) || (Math.log(image.height)/Math.LN2 !== Math.floor(Math.log(image.height)/Math.LN2)));\n        var gl = this.gl;\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n    },\n\n    // Sets the min/mag filters\n    setFilter: function(filter) {\n        if(!this.isActive()) throw(\"Trying to set filter of texture that isn't active\");\n        var gl = this.gl;\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n    },\n\n    // set image wrapping\n    setRepeat: function(repeat) {\n        if(!this.isActive()) throw(\"Trying to set repeat property of texture that isn't active\");\n        if(repeat && !this.powerOfTwo){\n            throw(\"Can't create a repeating image whose dimensions aren't a power of 2 in WebGL contexts\");\n        }\n        var gl = this.gl;\n        this.repeatMode = repeat ? gl.REPEAT : gl.CLAMP_TO_EDGE;\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.repeatMode);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.repeatMode);\n    },\n\n    // given a shader and pair of uniform names, sets the sampler and dimensions to be used by this texture\n    setToProgram: function(shader, sampler_name, dimension_name) {\n        if(this.unit === null) throw(\"Trying to use texture not set to a texture unit.\");\n        var gl = this.gl;\n        gl.useProgram(shader);\n        // Set the texture buffer to use\n        gl.uniform1i(gl.getUniformLocation(shader, sampler_name), this.unit);\n        // Set the image dimensions\n        gl.uniform2f(gl.getUniformLocation(shader, dimension_name), this.width, this.height);\n    }\n};"},"hash":"c99bc559dff1e9cfad84984f9e7e7be3"}