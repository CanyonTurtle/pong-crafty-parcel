{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js'),\n    document = window.document;\n\n/**@\n * #DebugCanvas\n * @category Debug\n * @kind Component\n * \n * @trigger DebugDraw - when the entity is ready to be drawn to the stage\n * @trigger NoCanvas - if the browser does not support canvas\n *\n * When this component is added to an entity it will be drawn by the DebugCanvas layer.\n *\n * Crafty.debugCanvas.init() will be automatically called if it is not called already to initialize the canvas element.\n *\n * To visualise an object's MBR, use \"VisibleMBR\".  To visualise a \"Collision\" object's hitbox, use \"WiredHitBox\" or \"SolidHitBox\".\n * @see DebugPolygon,  DebugRectangle\n */\nCrafty.c(\"DebugCanvas\", {\n    init: function () {\n        this.requires(\"2D\");\n        if (!Crafty.DebugCanvas.context)\n            Crafty.DebugCanvas.init();\n        Crafty.DebugCanvas.add(this);\n        this._debug = {\n            alpha: 1.0,\n            lineWidth: 1\n        };\n        this.bind(\"RemoveComponent\", this.onDebugRemove);\n        this.bind(\"Remove\", this.onDebugDestroy);\n    },\n\n    // When component is removed\n    onDebugRemove: function (id) {\n        if (id === \"DebugCanvas\") {\n            Crafty.DebugCanvas.remove(this);\n        }\n    },\n\n    //When entity is destroyed\n    onDebugDestroy: function (id) {\n        Crafty.DebugCanvas.remove(this);\n    },\n\n    /**@\n     * #.debugAlpha\n     * @comp DebugCanvas\n     * @kind Method\n     * \n     * @sign public  .debugAlpha(Number alpha)\n     * @param alpha - The alpha level the component will be drawn with\n     */\n    debugAlpha: function (alpha) {\n        this._debug.alpha = alpha;\n        return this;\n    },\n\n    /**@\n     * #.debugFill\n     * @comp DebugCanvas\n     * @kind Method\n     * \n     * @sign public  .debugFill([String fillStyle])\n     * @param fillStyle - The color the component will be filled with.  Defaults to \"red\". Pass the boolean false to turn off filling.\n     * @example\n     * ~~~\n     * var myEntity = Crafty.e(\"2D, Collision, SolidHitBox \").debugFill(\"purple\")\n     * ~~~\n     */\n    debugFill: function (fillStyle) {\n        if (typeof fillStyle === 'undefined')\n            fillStyle = \"red\";\n        this._debug.fillStyle = fillStyle;\n        return this;\n    },\n\n    /**@\n     * #.debugStroke\n     * @comp DebugCanvas\n     * @kind Method\n     * \n     * @sign public  .debugStroke([String strokeStyle])\n     * @param strokeStyle - The color the component will be outlined with.  Defaults to \"red\".  Pass the boolean false to turn this off.\n     * @example\n     * ~~~\n     * var myEntity = Crafty.e(\"2D, Collision, WiredHitBox \").debugStroke(\"white\")\n     * ~~~\n     */\n    debugStroke: function (strokeStyle) {\n        if (typeof strokeStyle === 'undefined')\n            strokeStyle = \"red\";\n        this._debug.strokeStyle = strokeStyle;\n        return this;\n    },\n\n    debugDraw: function (ctx) {\n        var ga = ctx.globalAlpha;\n        var props = this._debug;\n\n        if (props.alpha)\n            ctx.globalAlpha = this._debug.alpha;\n\n        if (props.strokeStyle)\n            ctx.strokeStyle = props.strokeStyle;\n\n        if (props.lineWidth)\n            ctx.lineWidth = props.lineWidth;\n\n        if (props.fillStyle)\n            ctx.fillStyle = props.fillStyle;\n\n        this.trigger(\"DebugDraw\", ctx);\n\n        ctx.globalAlpha = ga;\n\n    }\n\n\n});\n\n\n\n/**@\n * #DebugRectangle\n * @category Debug\n * @kind Component\n *\n * A component for rendering an object with a position and dimensions to the debug canvas.\n *\n *\n * ~~~\n * var myEntity = Crafty.e(\"2D, DebugRectangle\")\n *                      .attr({x: 13, y: 37, w: 42, h: 42})\n *                      .debugStroke(\"green\");\n * myEntity.debugRectangle(myEntity)\n *~~~\n * @see DebugCanvas\n */\nCrafty.c(\"DebugRectangle\", {\n    init: function () {\n        this.requires(\"2D, DebugCanvas\");\n    },\n\n    /**@\n     * #.debugRectangle\n     * @comp DebugRectangle\n     * @kind Method\n     * \n     * @sign public  .debugRectangle(Object rect)\n     * @param rect - an object with _x, _y, _w, and _h to draw\n     *\n     * Sets the rectangle that this component draws to the debug canvas.\n     *\n     */\n    debugRectangle: function (rect) {\n        this.debugRect = rect;\n        this.unbind(\"DebugDraw\", this.drawDebugRect);\n        this.bind(\"DebugDraw\", this.drawDebugRect);\n        return this;\n\n    },\n\n    drawDebugRect: function (ctx) {\n\n        var rect = this.debugRect;\n        if (rect === null || rect === undefined)\n            return;\n        if (rect._h && rect._w) {\n            if (this._debug.fillStyle)\n                ctx.fillRect(rect._x, rect._y, rect._w, rect._h);\n            if (this._debug.strokeStyle)\n                ctx.strokeRect(rect._x, rect._y, rect._w, rect._h);\n        }\n\n    }\n\n\n\n});\n\n\n\n/**@\n * #VisibleMBR\n * @category Debug\n * @kind Component\n *\n * Adding this component to an entity will cause it's MBR to be drawn to the debug canvas.\n *\n * The methods of DebugCanvas can be used to control this component's appearance.\n * @see 2D, DebugRectangle, DebugCanvas\n */\nCrafty.c(\"VisibleMBR\", {\n    init: function () {\n        this.requires(\"DebugRectangle\")\n            .debugFill(\"purple\")\n            .bind(\"EnterFrame\", this._assignRect);\n    },\n\n    // Internal method for updating the MBR drawn.\n    _assignRect: function () {\n        if (this._mbr)\n            this.debugRectangle(this._mbr);\n        else\n            this.debugRectangle(this);\n\n    }\n\n\n});\n\n\n/**@\n * #DebugPolygon\n * @category Debug\n * @kind Component\n *\n * For drawing a polygon to the debug canvas\n *\n * The methods of DebugCanvas can be used to control this component's appearance -- by default it is neither filled nor outlined\n *\n * For debugging hitboxes, use WiredHitBox or SolidHitBox.  For debugging MBR, use VisibleMBR\n *\n * @see DebugCanvas\n */\nCrafty.c(\"DebugPolygon\", {\n    init: function () {\n        this.requires(\"2D, DebugCanvas\");\n    },\n\n\n    /**@\n     * #.debugPolygon\n     * @comp DebugPolygon\n     * @kind Method\n     * \n     * @sign public  .debugPolygon(Polygon poly)\n     * @param poly - a polygon to render\n     *\n     * Sets the polygon that this component renders to the debug canvas.\n     *\n     */\n    debugPolygon: function (poly) {\n        this.polygon = poly;\n        this.unbind(\"DebugDraw\", this.drawDebugPolygon);\n        this.bind(\"DebugDraw\", this.drawDebugPolygon);\n        return this;\n    },\n\n    drawDebugPolygon: function (ctx) {\n        if (typeof this.polygon === \"undefined\")\n            return;\n\n        ctx.beginPath();\n        var p = this.polygon.points, l = p.length;\n        for (var i=0; i<l; i+=2){\n            ctx.lineTo(p[i], p[i+1]);\n        }\n        ctx.closePath();\n\n        if (this._debug.fillStyle)\n            ctx.fill();\n        if (this._debug.strokeStyle)\n            ctx.stroke();\n    }\n});\n\n\n/**@\n * #WiredHitBox\n * @category Debug\n * @kind Component\n *\n * Adding this component to an entity with a Collision component will cause its collision polygon to be drawn to the debug canvas as an outline\n *\n * The methods of DebugCanvas can be used to control this component's appearance.\n * @see DebugPolygon, DebugCanvas\n */\nCrafty.c(\"WiredHitBox\", {\n    init: function () {\n        this.requires(\"DebugPolygon\")\n            .debugStroke(\"red\")\n            .matchHitBox();\n        this.bind(\"NewHitbox\", this.matchHitBox);\n    },\n    matchHitBox: function () {\n        this.debugPolygon(this.map);\n    }\n});\n\n/**@\n * #SolidHitBox\n * @category Debug\n * @kind Component\n *\n * Adding this component to an entity with a Collision component will cause its collision polygon to be drawn to the debug canvas, with a default alpha level of 0.7.\n *\n * The methods of DebugCanvas can be used to control this component's appearance.\n * @see DebugPolygon, DebugCanvas\n */\nCrafty.c(\"SolidHitBox\", {\n    init: function () {\n        this.requires(\"Collision, DebugPolygon\")\n            .debugFill(\"orange\").debugAlpha(0.7)\n            .matchHitBox();\n        this.bind(\"NewHitbox\", this.matchHitBox);\n    },\n    matchHitBox: function () {\n        this.debugPolygon(this.map);\n    }\n});\n\n/**@\n * #WiredAreaMap\n * @category Debug\n * @kind Component\n *\n * Adding this component to an entity with an AreaMap component will cause its click polygon to be drawn to the debug canvas as an outline.\n * Following click areas exist for an entity (in decreasing order of priority): AreaMap, Hitbox, MBR. Use the appropriate debug components to display them.\n *\n * The methods of DebugCanvas can be used to control this component's appearance.\n * @see DebugPolygon, DebugCanvas\n */\nCrafty.c(\"WiredAreaMap\", {\n    init: function () {\n        this.requires(\"DebugPolygon\")\n            .debugStroke(\"green\")\n            .matchAreaMap();\n        this.bind(\"NewAreaMap\", this.matchAreaMap);\n    },\n    matchAreaMap: function () {\n        this.debugPolygon(this.mapArea);\n    }\n});\n\n/**@\n * #SolidAreaMap\n * @category Debug\n * @kind Component\n *\n * Adding this component to an entity with an AreaMap component will cause its click polygon to be drawn to the debug canvas, with a default alpha level of 0.7.\n * Following click areas exist for an entity (in decreasing order of priority): AreaMap, Hitbox, MBR. Use the appropriate debug components to display them.\n *\n * The methods of DebugCanvas can be used to control this component's appearance.\n * @see DebugPolygon, DebugCanvas\n */\nCrafty.c(\"SolidAreaMap\", {\n    init: function () {\n        this.requires(\"DebugPolygon\")\n            .debugFill(\"lime\").debugAlpha(0.7)\n            .matchAreaMap();\n        this.bind(\"NewAreaMap\", this.matchAreaMap);\n    },\n    matchAreaMap: function () {\n        this.debugPolygon(this.mapArea);\n    }\n});\n\nCrafty.DebugCanvas = {\n    context: null,\n    entities: [],\n    onetimeEntities: [],\n    add: function (ent) {\n        this.entities.push(ent);\n    },\n\n    remove: function (ent) {\n        var list = this.entities;\n        for (var i = list.length - 1; i >= 0; i--)\n            if (list[i] === ent)\n                list.splice(i, 1);\n\n    },\n\n    // Mostly copied from canvas.init()\n    // Called the first time a \"DebugCanvas\" component is added to an entity\n    // We should consider how to abstract the idea of multiple canvases\n    init: function () {\n        if (!Crafty.DebugCanvas.context) {\n            //check if canvas is supported\n            if (!Crafty.support.canvas) {\n                Crafty.trigger(\"NoCanvas\");\n                Crafty.stop();\n                return;\n            }\n\n            //create an empty canvas element\n            var c;\n            c = document.createElement(\"canvas\");\n            c.width = Crafty.viewport.width;\n            c.height = Crafty.viewport.height;\n            c.style.position = 'absolute';\n            c.style.left = \"0px\";\n            c.style.top = \"0px\";\n            c.id = \"debug-canvas\";\n            // The debug canvas should be on the very top; the highest a regular zindex can get is ~10000\n            c.style.zIndex = 100000;\n\n            Crafty.stage.elem.appendChild(c);\n            Crafty.DebugCanvas.context = c.getContext('2d');\n            Crafty.DebugCanvas._canvas = c;\n\n\n\n        }\n        //Bind rendering of canvas context (see drawing.js)\n        Crafty.unbind(\"RenderScene\", Crafty.DebugCanvas.renderScene);\n        Crafty.bind(\"RenderScene\", Crafty.DebugCanvas.renderScene);\n\n    },\n\n\n    // copied from drawAll()\n    renderScene: function (rect) {\n        rect = rect || Crafty.viewport.rect();\n        var q = Crafty.DebugCanvas.entities,\n            i = 0,\n            l = q.length,\n            ctx = Crafty.DebugCanvas.context,\n            current;\n\n        var view = Crafty.viewport;\n        ctx.setTransform(view._scale, 0, 0, view._scale, Math.round(view._x*view._scale), Math.round(view._y*view._scale));\n\n        ctx.clearRect(rect._x, rect._y, rect._w, rect._h);\n\n        var lastLayer = null;\n        for (; i < l; i++) {\n            current = q[i];\n\n            // If necessary, update the view transform to match the current entities layer\n            if (lastLayer !== current._drawlayer){\n                view = current._drawLayer._viewportRect();\n                ctx.setTransform(view._scale, 0, 0, view._scale, Math.round(-view._x*view._scale), Math.round(-view._y*view._scale));\n                lastLayer = current._drawLayer;\n            }\n\n            current.debugDraw(ctx);\n        }\n\n    }\n\n};\n"},"hash":"d7c2ffa54901cc796c1ccaeb26e32f4a"}