{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js');\n\n\n/**@\n * #Text\n * @category Graphics\n * @kind Component\n * \n * @trigger Invalidate - when the text is changed\n * @requires Canvas or DOM\n * Component to make a text entity.\n *\n * By default, text will have the style \"10px sans-serif\".\n *\n * @note An entity with the text component is just text! If you want to write text\n * inside an image, you need one entity for the text and another entity for the image.\n * More tips for writing text inside an image: (1) Use the z-index (from 2D component)\n * to ensure that the text is on top of the image, not the other way around; (2)\n * use .attach() (from 2D component) to glue the text to the image so they move and\n * rotate together.\n *\n * @note For DOM (but not canvas) text entities, various font settings (such as\n * text-decoration) can be set using `.css()` (see DOM component). But\n * you cannot use `.css()` to set the properties which are controlled by `.textFont()`,\n *  `.textColor()`, or `.textAlign()` -- the settings will be ignored.\n *\n * @note If you use canvas text with glyphs that are taller than standard letters, portions of the glyphs might be cut off.\n */\nCrafty.c(\"Text\", {\n    _text: \"\",\n    defaultSize: \"10px\",\n    defaultFamily: \"sans-serif\",\n    defaultVariant: \"normal\",\n    defaultLineHeight: \"normal\",\n    defaultTextAlign: \"left\",\n    ready: true,\n\n    init: function () {\n        this.requires(\"2D\");\n        this._textFont = {\n            \"type\": \"\",\n            \"weight\": \"\",\n            \"size\": this.defaultSize,\n            \"lineHeight\":this.defaultLineHeight,\n            \"family\": this.defaultFamily,\n            \"variant\": this.defaultVariant\n        };\n        this._textAlign = this.defaultTextAlign;\n    },\n\n    events: {\n        \"Draw\": function (e) {\n            var font = this._fontString();\n\n            if (e.type === \"DOM\") {\n                var el = this._element,\n                    style = el.style;\n\n                style.color = this._textColor;\n                style.font = font;\n                style.textAlign = this._textAlign;\n                el.innerHTML = this._text;\n            } else if (e.type === \"canvas\") {\n                var context = e.ctx;\n\n                context.save();\n\n                context.textBaseline = \"top\";\n                context.fillStyle = this._textColor || \"rgb(0,0,0)\";\n                context.font = font;\n                context.textAlign = this._textAlign;\n\n                context.fillText(this._text, e.pos._x, e.pos._y);\n\n                context.restore();\n            }\n        }\n    },\n\n    remove: function(){\n        // Clean up the dynamic text update\n        this.unbind(this._textUpdateEvent, this._dynamicTextUpdate);\n    },\n\n    // takes a CSS font-size string and gets the height of the resulting font in px\n    _getFontHeight: (function(){\n        // regex for grabbing the first string of letters\n        var re = /([a-zA-Z]+)\\b/;\n        // From the CSS spec.  \"em\" and \"ex\" are undefined on a canvas.\n        var multipliers = {\n            \"px\": 1,\n            \"pt\": 4/3,\n            \"pc\": 16,\n            \"cm\": 96/2.54,\n            \"mm\": 96/25.4,\n            \"in\": 96,\n            \"em\": undefined,\n            \"ex\": undefined\n        };\n        return function (font){\n            var number = parseFloat(font);\n            var match = re.exec(font);\n            var unit =  match ? match[1] : \"px\";\n            if (multipliers[unit] !== undefined)\n                return Math.ceil(number * multipliers[unit]);\n            else\n                return Math.ceil(number);\n        };\n    })(),\n\n    /**@\n     * #.text\n     * @comp Text\n     * @kind Method\n     * \n     * @sign public this .text(String text)\n     * @param text - String of text that will be inserted into the DOM or Canvas element.\n     *\n     * @sign public this .text(Function textGenerator)\n     * @param textGenerator - A function that returns a string.  \n     *        It will be immediately invoked in the context of the entity, with the result used as the text to display.\n     *\n     * This method will update the text inside the entity.\n     *\n     * If you need to reference attributes on the entity itself you can pass a function instead of a string.\n     * \n     * If dynamic text generation is turned on, the function will then be reevaluated as necessary.\n     * \n     * @see .dynamicTextGeneration\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D, DOM, Text\").attr({ x: 100, y: 100 }).text(\"Look at me!!\");\n     *\n     * Crafty.e(\"2D, DOM, Text\").attr({ x: 100, y: 100 })\n     *     .text(function () { return \"My position is \" + this._x });\n     *\n     * Crafty.e(\"2D, Canvas, Text\").attr({ x: 100, y: 100 }).text(\"Look at me!!\");\n     *\n     * Crafty.e(\"2D, Canvas, Text\").attr({ x: 100, y: 100 })\n     *     .text(function () { return \"My position is \" + this._x });\n     * ~~~\n     */\n    _textGenerator: null,\n    text: function (text) {\n        if (!(typeof text !== \"undefined\" && text !== null)) return this._text;\n        if (typeof (text) === \"function\"){\n            this._text = text.call(this);\n            this._textGenerator = text;\n        } else {\n            this._text = text;\n            this._textGenerator = null;\n        }\n\n        if (this.has(\"Canvas\") )\n            this._resizeForCanvas();\n\n        this.trigger(\"Invalidate\");\n        return this;\n    },\n\n    /**@\n     * #.dynamicTextGeneration\n     * @comp Text\n     * @kind Method\n     * \n     * @sign public this .dynamicTextGeneration(bool dynamicTextOn[, string textUpdateEvent])\n     * @param dynamicTextOn - A flag that indicates whether dyanamic text should be on or off.\n     * @param textUpdateEvent - The name of the event which will trigger text to be updated.  Defaults to \"EnterFrame\".  (This parameter does nothing if dynamicTextOn is false.)\n     *\n     * Turns on (or off) dynamic text generation for this entity.  While dynamic text generation is on, \n     * if the `.text()` method is called with a text generating function, the text will be updated each frame.\n     * \n     * If textUpdateEvent is provided, text generation will be bound to that event instead of \"EnterFrame\".  \n     * \n     * @note Dynamic text generation could cause performance issues when the entity is attached to a Canvas layer.\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D, DOM, Text, Motion\").attr({ x: 100, y: 100, vx: 10 })\n     *     .text(function () { return \"My position is \" + this._x })\n     *     .dynamicTextGeneration(true)\n     * ~~~\n     * The above example will update the text with the entities position as it changes.\n     */\n    _dynamicTextOn: false,\n    _textUpdateEvent: null,\n    _dynamicTextUpdate: function(){\n        if (!this._textGenerator) return;\n        this.text(this._textGenerator);\n    },\n    dynamicTextGeneration: function(dynamicTextOn, textUpdateEvent) {\n        this.unbind(this._textUpdateEvent, this._dynamicTextUpdate);\n        if (dynamicTextOn) {\n            this._textUpdateEvent = textUpdateEvent || \"EnterFrame\";\n            this.bind(this._textUpdateEvent, this._dynamicTextUpdate);\n        }\n        return this;\n    },\n\n    // Calculates the height and width of text on the canvas\n    // Width is found by using the canvas measureText function\n    // Height is only estimated -- it calculates the font size in pixels, and sets the height to 110% of that.\n    _resizeForCanvas: function(){\n        var ctx = this._drawContext;\n        ctx.font = this._fontString();\n        this.w = ctx.measureText(this._text).width;\n\n        var size = (this._textFont.size || this.defaultSize);\n        this.h = 1.1 * this._getFontHeight(size);\n\n        /* Offset the MBR for text alignment*/\n        if (this._textAlign === 'left' || this._textAlign === 'start') {\n            this.offsetBoundary(0, 0, 0, 0);\n        } else if (this._textAlign === 'center') {\n            this.offsetBoundary(this.w/2, 0, -this.w/2, 0);\n        } else if (this._textAlign === 'end' || this._textAlign === 'right') {\n            this.offsetBoundary(this.w, 0, -this.w, 0);\n        }\n    },\n\n    // Returns the font string to use\n    _fontString: function(){\n        return this._textFont.type + ' ' + this._textFont.variant  + ' ' + this._textFont.weight + ' ' + this._textFont.size  + ' / ' + this._textFont.lineHeight + ' ' + this._textFont.family;\n    },\n    /**@\n     * #.textColor\n     * @comp Text\n     * @kind Method\n     * \n     * @sign public this .textColor(String color)\n     * @param color - The color in name, hex, rgb or rgba\n     *\n     * Change the color of the text. You can use HEX, rgb and rgba colors. \n     *\n     * If you want the text to be transparent, you should use rgba where you can define alphaChannel.\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D, DOM, Text\").attr({ x: 100, y: 100 }).text(\"Look at me!!\")\n     *   .textColor('#FF0000');\n     *\n     * Crafty.e(\"2D, Canvas, Text\").attr({ x: 100, y: 100 }).text('Look at me!!')\n     *   .textColor('rgba(0, 255, 0, 0.5)');\n     *\n     * Crafty.e(\"2D, Canvas, Text\").attr({ x: 100, y: 100 }).text('Look at me!!')\n     *   .textColor('white');\n     * ~~~\n     * @see Crafty.assignColor\n     */\n    textColor: function (color) {\n        Crafty.assignColor(color, this);\n        this._textColor = \"rgba(\" + this._red + \", \" + this._green + \", \" + this._blue + \", \" + this._strength + \")\";\n        this.trigger(\"Invalidate\");\n        return this;\n    },\n\n    /**@\n     * #.textAlign\n     * @comp Text\n     * @kind Method\n     * \n     * @sign public this .textAlign(String alignment)\n     * @param alignment - The new alignment of the text.\n     *\n     * Change the alignment of the text. Valid values are 'start', 'end, 'left', 'center', or 'right'.\n     */\n    textAlign: function(alignment) {\n        this._textAlign = alignment;\n        if (this.has(\"Canvas\"))\n            this._resizeForCanvas();\n        this.trigger(\"Invalidate\");\n        return this;\n    },\n\n    /**@\n     * #.textFont\n     * @comp Text\n     * @kind Method\n     * \n     * @triggers Invalidate\n     * @sign public this .textFont(String key, * value)\n     * @param key - Property of the entity to modify\n     * @param value - Value to set the property to\n     *\n     * @sign public this .textFont(Object map)\n     * @param map - Object where the key is the property to modify and the value as the property value\n     *\n     * Use this method to set font property of the text entity.  Possible values are: type, weight, size, family, lineHeight, and variant.\n     *\n     * When rendered by the canvas, lineHeight and variant will be ignored.\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D, DOM, Text\").textFont({ type: 'italic', family: 'Arial' });\n     * Crafty.e(\"2D, Canvas, Text\").textFont({ size: '20px', weight: 'bold' });\n     *\n     * Crafty.e(\"2D, Canvas, Text\").textFont(\"type\", \"italic\");\n     * Crafty.e(\"2D, Canvas, Text\").textFont(\"type\"); // italic\n     * ~~~\n     */\n    textFont: function (key, value) {\n        if (arguments.length === 1) {\n            //if just the key, return the value\n            if (typeof key === \"string\") {\n                return this._textFont[key];\n            }\n\n            if (typeof key === \"object\") {\n                for (var propertyKey in key) {\n                    if(propertyKey === 'family'){\n                        this._textFont[propertyKey] = \"'\" + key[propertyKey] + \"'\";\n                    } else {\n                        this._textFont[propertyKey] = key[propertyKey];\n                    }\n                }\n            }\n        } else {\n            this._textFont[key] = value;\n        }\n\n        if (this.has(\"Canvas\") )\n            this._resizeForCanvas();\n\n        this.trigger(\"Invalidate\");\n        return this;\n    },\n    /**@\n     * #.unselectable\n     * @comp Text\n     * @kind Method\n     * \n     * @triggers Invalidate\n     * @sign public this .unselectable()\n     *\n     * This method sets the text so that it cannot be selected (highlighted) by dragging.\n     * (Canvas text can never be highlighted, so this only matters for DOM text.)\n     * Works by changing the css property \"user-select\" and its variants.\n     * \n     * Likewise, this sets the mouseover cursor to be \"default\" (arrow), not \"text\" (I-beam)\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D, DOM, Text\").text('This text cannot be highlighted!').unselectable();\n     * ~~~\n     */\n    unselectable: function () {\n        // http://stackoverflow.com/questions/826782/css-rule-to-disable-text-selection-highlighting\n        if (this.has(\"DOM\")) {\n            this.css({\n                '-webkit-touch-callout': 'none',\n                '-webkit-user-select': 'none',\n                '-khtml-user-select': 'none',\n                '-moz-user-select': 'none',\n                '-ms-user-select': 'none',\n                'user-select': 'none',\n                'cursor': 'default'\n            });\n            this.trigger(\"Invalidate\");\n        }\n        return this;\n    }\n\n});\n"},"hash":"dcc76747c2b3edd689bb1740e2824af5"}