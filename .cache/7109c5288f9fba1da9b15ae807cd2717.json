{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}},{"name":"./spatial-grid.js","loc":{"line":2,"column":22}}],"generated":{"js":"var Crafty = require('../core/core.js'),\n    HashMap = require('./spatial-grid.js');\n\n\n\n/**@\n * #Crafty.map\n * @category 2D\n * @kind CoreObject\n * \n * Functions related with querying entities.\n * @see Crafty.HashMap\n */\nCrafty.map = new HashMap();\nvar M = Math,\n    //Mc = M.cos,\n    //Ms = M.sin,\n    PI = M.PI,\n    DEG_TO_RAD = PI / 180;\n\n/**@\n * #2D\n * @category 2D\n * @kind Component\n * \n * Component for any entity that has a position on the stage.\n * @trigger Move - when the entity has moved - { _x:Number, _y:Number, _w:Number, _h:Number } - Old position\n * @trigger Invalidate - when the entity needs to be redrawn\n * @trigger Rotate - when the entity is rotated - { cos:Number, sin:Number, deg:Number, rad:Number, o: {x:Number, y:Number}}\n * @trigger Reorder - when the entity's z index has changed\n */\nCrafty.c(\"2D\", {\n    /**@\n     * #.x\n     * @comp 2D\n     * @kind Property\n     * \n     * The `x` position on the stage. When modified, will automatically be redrawn.\n     * Is actually a getter/setter so when using this value for calculations and not modifying it,\n     * use the `._x` property.\n     * @see ._setter2d\n     */\n    _x: 0,\n    /**@\n     * #.y\n     * @kind Property\n     * \n     * @comp 2D\n     * The `y` position on the stage. When modified, will automatically be redrawn.\n     * Is actually a getter/setter so when using this value for calculations and not modifying it,\n     * use the `._y` property.\n     * @see ._setter2d\n     */\n    _y: 0,\n    /**@\n     * #.w\n     * @comp 2D\n     * @kind Property\n     * \n     * The width of the entity. When modified, will automatically be redrawn.\n     * Is actually a getter/setter so when using this value for calculations and not modifying it,\n     * use the `._w` property.\n     *\n     * Changing this value is not recommended as canvas has terrible resize quality and DOM will just clip the image.\n     * @see ._setter2d\n     */\n    _w: 0,\n    /**@\n     * #.h\n     * @comp 2D\n     * @kind Property\n     * \n     * The height of the entity. When modified, will automatically be redrawn.\n     * Is actually a getter/setter so when using this value for calculations and not modifying it,\n     * use the `._h` property.\n     *\n     * Changing this value is not recommended as canvas has terrible resize quality and DOM will just clip the image.\n     * @see ._setter2d\n     */\n    _h: 0,\n\n    /**@\n     * #.z\n     * @comp 2D\n     * @kind Property\n     * \n     * The `z` index on the stage. When modified, will automatically be redrawn.\n     * Is actually a getter/setter so when using this value for calculations and not modifying it,\n     * use the `._z` property.\n     *\n     * A higher `z` value will be closer to the front of the stage. A smaller `z` value will be closer to the back.\n     * A global Z index is produced based on its `z` value as well as the GID (which entity was created first).\n     * Therefore entities will naturally maintain order depending on when it was created if same z value.\n     *\n     * `z` is required to be an integer, e.g. `z=11.2` is not allowed.\n     * @see ._attr\n     */\n    _z: 0,\n\n    /**@\n     * #._globalZ\n     * @comp 2D\n     * @kind Property\n     * \n     * When two entities overlap, the one with the larger `_globalZ` will be on top of the other.\n     */\n    _globalZ: null,\n\n    /**@\n     * #.rotation\n     * @comp 2D\n     * @kind Property\n     * \n     * The rotation state of the entity, in clockwise degrees.\n     * `this.rotation = 0` sets it to its original orientation; `this.rotation = 10`\n     * sets it to 10 degrees clockwise from its original orientation;\n     * `this.rotation = -10` sets it to 10 degrees counterclockwise from its\n     * original orientation, etc.\n     *\n     * When modified, will automatically be redrawn. Is actually a getter/setter\n     * so when using this value for calculations and not modifying it,\n     * use the `._rotation` property.\n     *\n     * `this.rotation = 0` does the same thing as `this.rotation = 360` or `720` or\n     * `-360` or `36000` etc. So you can keep increasing or decreasing the angle for continuous\n     * rotation. (Numerical errors do not occur until you get to millions of degrees.)\n     *\n     * The default is to rotate the entity around its (initial) top-left corner; use\n     * `.origin()` to change that.\n     *\n     * @see ._setter2d, .origin\n     */\n    _rotation: 0,\n\n    _origin: null,\n    _mbr: null,\n    _entry: null,\n    _children: null,\n    _parent: null,\n\n    // Setup   all the properties that we need to define\n    _2D_property_definitions: {\n        x: {\n            set: function (v) {\n                this._setter2d('_x', v);\n            },\n            get: function () {\n                return this._x;\n            },\n            configurable: true,\n            enumerable: true\n        },\n        _x: {enumerable:false},\n\n        y: {\n            set: function (v) {\n                this._setter2d('_y', v);\n            },\n            get: function () {\n                return this._y;\n            },\n            configurable: true,\n            enumerable: true\n        },\n        _y: {enumerable:false},\n\n        w: {\n            set: function (v) {\n                this._setter2d('_w', v);\n            },\n            get: function () {\n                return this._w;\n            },\n            configurable: true,\n            enumerable: true\n        },\n        _w: {enumerable:false},\n\n        h: {\n            set: function (v) {\n                this._setter2d('_h', v);\n            },\n            get: function () {\n                return this._h;\n            },\n            configurable: true,\n            enumerable: true\n        },\n        _h: {enumerable:false},\n\n        z: {\n            set: function (v) {\n                this._setter2d('_z', v);\n            },\n            get: function () {\n                return this._z;\n            },\n            configurable: true,\n            enumerable: true\n        },\n        _z: {enumerable:false},\n\n        rotation: {\n            set: function (v) {\n                this._setter2d('_rotation', v);\n            },\n            get: function () {\n                return this._rotation;\n            },\n            configurable: true,\n            enumerable: true\n        },\n        _rotation: {enumerable:false}\n    },\n\n    _define2DProperties: function () {\n        for (var prop in this._2D_property_definitions){\n            Object.defineProperty(this, prop, this._2D_property_definitions[prop]);\n        }\n    },\n\n    init: function () {\n        this._globalZ = this[0];\n        this._origin = {\n            x: 0,\n            y: 0\n        };\n\n        // offsets for the basic bounding box\n        this._bx1 = 0;\n        this._bx2 = 0;\n        this._by1 = 0;\n        this._by2 = 0;\n\n        this._children = [];\n\n        \n        // create setters and getters that associate properties such as x/_x\n        this._define2DProperties();\n        \n\n        //insert self into the HashMap\n        this._entry = Crafty.map.insert(this);\n\n        //when object changes, update HashMap\n        this.bind(\"Move\", function (e) {\n            // Choose the largest bounding region that exists\n            var area = this._cbr || this._mbr || this;\n            this._entry.update(area);\n            // Move children (if any) by the same amount\n            if (this._children.length > 0) {\n                this._cascade(e);\n            }\n        });\n\n        this.bind(\"Rotate\", function (e) {\n            // Choose the largest bounding region that exists\n            var old = this._cbr || this._mbr || this;\n            this._entry.update(old);\n            // Rotate children (if any) by the same amount\n            if (this._children.length > 0) {\n                this._cascade(e);\n            }\n        });\n\n        //when object is removed, remove from HashMap and destroy attached children\n        this.bind(\"Remove\", function () {\n            if (this._children) {\n                for (var i = 0; i < this._children.length; i++) {\n                    // delete the child's _parent link, or else the child will splice itself out of\n                    // this._children while destroying itself (which messes up this for-loop iteration).\n                    delete this._children[i]._parent;\n\n                    // Destroy child if possible (It's not always possible, e.g. the polygon attached\n                    // by areaMap has no .destroy(), it will just get garbage-collected.)\n                    if (this._children[i].destroy) {\n                        this._children[i].destroy();\n                    }\n                }\n                this._children = [];\n            }\n\n            if (this._parent) {\n                this._parent.detach(this);\n            }\n\n            Crafty.map.remove(this._entry);\n\n            this.detach();\n        });\n    },\n\n\n    /**@\n     * #.offsetBoundary\n     * @comp 2D\n     * @kind Method\n     * \n     * Extends the MBR of the entity by a specified amount.\n     * \n     * @trigger BoundaryOffset - when the MBR offset changes\n     * @sign public this .offsetBoundary(Number dx1, Number dy1, Number dx2, Number dy2)\n     * @param dx1 - Extends the MBR to the left by this amount\n     * @param dy1 - Extends the MBR upward by this amount\n     * @param dx2 - Extends the MBR to the right by this amount\n     * @param dy2 - Extends the MBR downward by this amount\n     *\n     * @sign public this .offsetBoundary(Number offset)\n     * @param offset - Extend the MBR in all directions by this amount\n     *\n     * You would most likely use this function to ensure that custom canvas rendering beyond the extent of the entity's normal bounds is not clipped.\n     */\n    offsetBoundary: function(x1, y1, x2, y2){\n        if (arguments.length === 1)\n            y1 = x2 = y2 = x1;\n        this._bx1 = x1;\n        this._bx2 = x2;\n        this._by1 = y1;\n        this._by2 = y2;\n        this.trigger(\"BoundaryOffset\");\n        this._calculateMBR();\n        return this;\n    },\n\n    /**\n     * Calculates the MBR when rotated some number of radians about an origin point o.\n     * Necessary on a rotation, or a resize\n     */\n\n    _calculateMBR: function () {\n        var ox = this._origin.x + this._x,\n            oy = this._origin.y + this._y,\n            rad = -this._rotation * DEG_TO_RAD;\n        // axis-aligned (unrotated) coordinates, relative to the origin point\n        var dx1 = this._x - this._bx1 - ox,\n            dx2 = this._x + this._w + this._bx2 - ox,\n            dy1 = this._y - this._by1 - oy,\n            dy2 = this._y + this._h + this._by2 - oy;\n\n        var ct = Math.cos(rad),\n            st = Math.sin(rad);\n        // Special case 90 degree rotations to prevent rounding problems\n        ct = (ct < 1e-10 && ct > -1e-10) ? 0 : ct;\n        st = (st < 1e-10 && st > -1e-10) ? 0 : st;\n\n        // Calculate the new points relative to the origin, then find the new (absolute) bounding coordinates!\n        var x0 =   dx1 * ct + dy1 * st,\n            y0 = - dx1 * st + dy1 * ct,\n            x1 =   dx2 * ct + dy1 * st,\n            y1 = - dx2 * st + dy1 * ct,\n            x2 =   dx2 * ct + dy2 * st,\n            y2 = - dx2 * st + dy2 * ct,\n            x3 =   dx1 * ct + dy2 * st,\n            y3 = - dx1 * st + dy2 * ct,\n            minx = Math.floor(Math.min(x0, x1, x2, x3) + ox),\n            miny = Math.floor(Math.min(y0, y1, y2, y3) + oy),\n            maxx = Math.ceil(Math.max(x0, x1, x2, x3) + ox),\n            maxy = Math.ceil(Math.max(y0, y1, y2, y3) + oy);\n        if (!this._mbr) {\n            this._mbr = {\n                _x: minx,\n                _y: miny,\n                _w: maxx - minx,\n                _h: maxy - miny\n            };\n        } else {\n            this._mbr._x = minx;\n            this._mbr._y = miny;\n            this._mbr._w = maxx - minx;\n            this._mbr._h = maxy - miny;\n        }\n\n        // If a collision hitbox exists AND sits outside the entity, find a bounding box for both.\n        // `_cbr` contains information about a bounding circle of the hitbox. \n        // The bounds of `_cbr` will be the union of the `_mbr` and the bounding box of that circle.\n        // This will not be a minimal region, but since it's only used for the broad phase pass it's good enough. \n        //\n        // cbr is calculated by the `_checkBounds` method of the \"Collision\" component\n        if (this._cbr) {\n            var cbr = this._cbr;\n            var cx = cbr.cx, cy = cbr.cy, r = cbr.r;\n            var cx2 = ox + (cx + this._x - ox) * ct + (cy + this._y - oy) * st;\n            var cy2 = oy - (cx + this._x - ox) * st + (cy + this._y - oy) * ct;\n            cbr._x = Math.min(cx2 - r, minx);\n            cbr._y = Math.min(cy2 - r, miny);\n            cbr._w = Math.max(cx2 + r, maxx) - cbr._x;\n            cbr._h = Math.max(cy2 + r, maxy) - cbr._y;\n        }\n\n    },\n\n    /**\n     * Handle changes that need to happen on a rotation\n     */\n    _rotate: function (v) {\n        //var theta = -1 * (v % 360); //angle always between 0 and 359\n        var difference = this._rotation - v;\n        // skip if there's no rotation!\n        if (difference === 0)\n            return;\n        else\n            this._rotation = v;\n\n        //Calculate the new MBR\n        var //rad = theta * DEG_TO_RAD,\n            o = {\n                x: this._origin.x + this._x,\n                y: this._origin.y + this._y\n            };\n\n        this._calculateMBR();\n\n\n        //trigger \"Rotate\" event\n        var drad = difference * DEG_TO_RAD,\n            // ct = Math.cos(rad),\n            // st = Math.sin(rad),\n            cos = Math.cos(drad),\n            sin = Math.sin(drad);\n\n        this.trigger(\"Rotate\", {\n            cos: (-1e-10 < cos && cos < 1e-10) ? 0 : cos, // Special case 90 degree rotations to prevent rounding problems\n            sin: (-1e-10 < sin && sin < 1e-10) ? 0 : sin, // Special case 90 degree rotations to prevent rounding problems\n            deg: difference,\n            rad: drad,\n            o: o\n        });\n    },\n\n    /**@\n     * #.area\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public Number .area(void)\n     * Calculates the area of the entity\n     */\n    area: function () {\n        return this._w * this._h;\n    },\n\n    /**@\n     * #.intersect\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public Boolean .intersect(Number x, Number y, Number w, Number h)\n     * @param x - X position of the rect\n     * @param y - Y position of the rect\n     * @param w - Width of the rect\n     * @param h - Height of the rect\n     * @sign public Boolean .intersect(Object rect)\n     * @param rect - An object that must have the `_x, _y, _w, _h` values as properties\n     *\n     * Determines if this entity intersects a rectangle.  If the entity is rotated, its MBR is used for the test.\n     */\n    intersect: function (x, y, w, h) {\n        var rect, mbr = this._mbr || this;\n        if (typeof x === \"object\") {\n            rect = x;\n        } else {\n            rect = {\n                _x: x,\n                _y: y,\n                _w: w,\n                _h: h\n            };\n        }\n\n        return mbr._x < rect._x + rect._w && mbr._x + mbr._w > rect._x &&\n            mbr._y < rect._y + rect._h && mbr._y + mbr._h > rect._y;\n    },\n\n    /**@\n     * #.within\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public Boolean .within(Number x, Number y, Number w, Number h)\n     * @param x - X position of the rect\n     * @param y - Y position of the rect\n     * @param w - Width of the rect\n     * @param h - Height of the rect\n     * @sign public Boolean .within(Object rect)\n     * @param rect - An object that must have the `_x, _y, _w, _h` values as properties\n     *\n     * Determines if this current entity is within another rectangle.\n     */\n    within: function (x, y, w, h) {\n        var rect, mbr = this._mbr || this;\n        if (typeof x === \"object\") {\n            rect = x;\n        } else {\n            rect = {\n                _x: x,\n                _y: y,\n                _w: w,\n                _h: h\n            };\n        }\n\n        return rect._x <= mbr._x && rect._x + rect._w >= mbr._x + mbr._w &&\n            rect._y <= mbr._y && rect._y + rect._h >= mbr._y + mbr._h;\n    },\n\n    /**@\n     * #.contains\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public Boolean .contains(Number x, Number y, Number w, Number h)\n     * @param x - X position of the rect\n     * @param y - Y position of the rect\n     * @param w - Width of the rect\n     * @param h - Height of the rect\n     * @sign public Boolean .contains(Object rect)\n     * @param rect - An object that must have the `_x, _y, _w, _h` values as properties.\n     *\n     * Determines if the rectangle is within the current entity.  If the entity is rotated, its MBR is used for the test.\n     */\n    contains: function (x, y, w, h) {\n        var rect, mbr = this._mbr || this;\n        if (typeof x === \"object\") {\n            rect = x;\n        } else {\n            rect = {\n                _x: x,\n                _y: y,\n                _w: w,\n                _h: h\n            };\n        }\n\n        return rect._x >= mbr._x && rect._x + rect._w <= mbr._x + mbr._w &&\n            rect._y >= mbr._y && rect._y + rect._h <= mbr._y + mbr._h;\n    },\n\n    /**@\n     * #.pos\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public Object .pos([Object pos])\n     * @param pos - an object to use as output\n     * @returns an object with `_x`, `_y`, `_w`, and `_h` properties; if an object is passed in, it will be reused rather than creating a new object.\n     *\n     * Return an object containing a copy of this entity's bounds (`_x`, `_y`, `_w`, and `_h` values).\n     *\n     * @note The keys have an underscore prefix. This is due to the x, y, w, h properties\n     * being setters and getters that wrap the underlying properties with an underscore (_x, _y, _w, _h).\n     */\n    pos: function (pos) {\n        pos = pos || {};\n        pos._x = (this._x);\n        pos._y = (this._y);\n        pos._w = (this._w);\n        pos._h = (this._h);\n        return pos;\n    },\n\n    /**@\n     * #.mbr\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public Object .mbr([Object mbr])\n     * @param mbr - an object to use as output\n     * @returns an object with `_x`, `_y`, `_w`, and `_h` properties; if an object is passed in, it will be reused rather than creating a new object.\n     *\n     * Return an object containing a copy of this entity's minimum bounding rectangle.\n     * The MBR encompasses a rotated entity's bounds.\n     * If there is no rotation on the entity it will return its bounds (`.pos()`) instead.\n     *\n     * @note The keys have an underscore prefix. This is due to the x, y, w, h properties\n     * being setters and getters that wrap the underlying properties with an underscore (_x, _y, _w, _h).\n     *\n     * @see .pos\n     */\n    mbr: function (mbr) {\n        mbr = mbr || {};\n        if (!this._mbr) {\n            return this.pos(mbr);\n        } else {\n            mbr._x = (this._mbr._x);\n            mbr._y = (this._mbr._y);\n            mbr._w = (this._mbr._w);\n            mbr._h = (this._mbr._h);\n            return mbr;\n        }\n    },\n\n    /**@\n     * #.isAt\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public Boolean .isAt(Number x, Number y)\n     * @param x - X position of the point\n     * @param y - Y position of the point\n     *\n     * Determines whether a point is contained by the entity. Unlike other methods,\n     * an object can't be passed. The arguments require the x and y value.\n     *\n     * The given point is tested against the first of the following that exists: a mapArea associated with \"Mouse\", the hitarea associated with \"Collision\", or the object's MBR.\n     */\n    isAt: function (x, y) {\n        if (this.mapArea) {\n            return this.mapArea.containsPoint(x, y);\n        } else if (this.map) {\n            return this.map.containsPoint(x, y);\n        }\n        var mbr = this._mbr || this;\n        return mbr._x <= x && mbr._x + mbr._w >= x &&\n            mbr._y <= y && mbr._y + mbr._h >= y;\n    },\n\n    /**@\n     * #.move\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public this .move(String dir, Number by)\n     * @param dir - Direction to move (n,s,e,w,ne,nw,se,sw)\n     * @param by - Amount to move in the specified direction\n     *\n     * Quick method to move the entity in a direction (n, s, e, w, ne, nw, se, sw) by an amount of pixels.\n     */\n    move: function (dir, by) {\n        if (dir.charAt(0) === 'n') this.y -= by;\n        if (dir.charAt(0) === 's') this.y += by;\n        if (dir === 'e' || dir.charAt(1) === 'e') this.x += by;\n        if (dir === 'w' || dir.charAt(1) === 'w') this.x -= by;\n\n        return this;\n    },\n\n    /**@\n     * #.shift\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public this .shift(Number x, Number y, Number w, Number h)\n     * @param x - Amount to move X\n     * @param y - Amount to move Y\n     * @param w - Amount to widen\n     * @param h - Amount to increase height\n     *\n     * Shift or move the entity by an amount. Use negative values\n     * for an opposite direction.\n     */\n    shift: function (x, y, w, h) {\n        if (x) this.x += x;\n        if (y) this.y += y;\n        if (w) this.w += w;\n        if (h) this.h += h;\n\n        return this;\n    },\n\n    /**@\n     * #._cascade\n     * @comp 2D\n     * @kind Method\n     * @private\n     * \n     * @sign public void ._cascade(e)\n     * @param e - An object describing the motion\n     *\n     * Move or rotate the entity's children according to a certain motion.\n     * This method is part of a function bound to \"Move\": It is used\n     * internally for ensuring that when a parent moves, the child also\n     * moves in the same way.\n     */\n    _cascade: function (e) {\n        if (!e) return; //no change in position\n        var i = 0,\n            children = this._children,\n            l = children.length,\n            obj;\n        //rotation\n        if ((\"cos\" in e) || (\"sin\" in e)) {\n            for (; i < l; ++i) {\n                obj = children[i];\n                if ('rotate' in obj) obj.rotate(e);\n            }\n        } else {\n            //use current position\n            var dx = this._x - e._x,\n                dy = this._y - e._y,\n                dw = this._w - e._w,\n                dh = this._h - e._h;\n\n            for (; i < l; ++i) {\n                obj = children[i];\n                obj.shift(dx, dy, dw, dh);\n            }\n        }\n    },\n\n    /**@\n     * #.attach\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public this .attach(Entity obj[, .., Entity objN])\n     * @param obj - Child entity(s) to attach\n     *\n     * Sets one or more entities to be children, with the current entity (`this`)\n     * as the parent. When the parent moves or rotates, its children move or\n     * rotate by the same amount. (But not vice-versa: If you move a child, it\n     * will not move the parent.) When the parent is destroyed, its children are\n     * destroyed.\n     *\n     * For any entity, `this._children` is the array of its children entity\n     * objects (if any), and `this._parent` is its parent entity object (if any).\n     *\n     * As many objects as wanted can be attached, and a hierarchy of objects is\n     * possible by attaching.\n     */\n    attach: function () {\n        var i = 0,\n            arg = arguments,\n            l = arguments.length,\n            obj;\n        for (; i < l; ++i) {\n            obj = arg[i];\n            if (obj._parent) {\n                obj._parent.detach(obj);\n            }\n            obj._parent = this;\n            this._children.push(obj);\n        }\n\n        return this;\n    },\n\n    /**@\n     * #.detach\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public this .detach([Entity obj])\n     * @param obj - The entity to detach. Left blank will remove all attached entities\n     *\n     * Stop an entity from following the current entity. Passing no arguments will stop\n     * every entity attached.\n     */\n    detach: function (obj) {\n        var i;\n        //if nothing passed, remove all attached objects\n        if (!obj) {\n            for (i = 0; i < this._children.length; i++) {\n                this._children[i]._parent = null;\n            }\n            this._children = [];\n            return this;\n        }\n\n        //if obj passed, find the handler and unbind\n        for (i = 0; i < this._children.length; i++) {\n            if (this._children[i] === obj) {\n                this._children.splice(i, 1);\n            }\n        }\n        obj._parent = null;\n\n        return this;\n    },\n\n    /**@\n     * #.origin\n     * @comp 2D\n     * @kind Method\n     * \n     * @sign public this .origin(Number x, Number y)\n     * @param x - Pixel value of origin offset on the X axis\n     * @param y - Pixel value of origin offset on the Y axis\n     *\n     * @sign public this .origin(String offset)\n     * @param offset - Alignment identifier, which is a combination of center, top, bottom, middle, left and right\n     *\n     * Set the origin point of an entity for it to rotate around.\n     *\n     * @example\n     * ~~~\n     * this.origin(\"top left\")\n     * this.origin(\"center\")\n     * this.origin(\"bottom right\")\n     * this.origin(\"middle right\")\n     * ~~~\n     *\n     * The origin should be set before changing the `rotation`,\n     * since it does not apply retroactively.\n     * Additionally, setting the origin via an alignment identifier works only\n     * after the entity's dimensions have been set.\n     * These points are shown in the following example:\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D\")\n     *       .attr({w: 100, h: 100})\n     *       .origin('center')\n     *       .attr({x: 25, y: 25, rotation: 180});\n     * ~~~\n     *\n     * @see .rotation\n     */\n    origin: function (x, y) {\n        //text based origin\n        if (typeof x === \"string\") {\n            if (x === \"centre\" || x === \"center\" || x.indexOf(' ') === -1) {\n                x = this._w / 2;\n                y = this._h / 2;\n            } else {\n                var cmd = x.split(' ');\n                if (cmd[0] === \"top\") y = 0;\n                else if (cmd[0] === \"bottom\") y = this._h;\n                else if (cmd[0] === \"middle\" || cmd[1] === \"center\" || cmd[1] === \"centre\") y = this._h / 2;\n\n                if (cmd[1] === \"center\" || cmd[1] === \"centre\" || cmd[1] === \"middle\") x = this._w / 2;\n                else if (cmd[1] === \"left\") x = 0;\n                else if (cmd[1] === \"right\") x = this._w;\n            }\n        }\n\n        this._origin.x = x;\n        this._origin.y = y;\n\n        return this;\n    },\n\n    /**\n     * Method for rotation rather than through a setter\n     */\n    rotate: function (e) {\n        var x2, y2;\n        x2 =  (this._x + this._origin.x - e.o.x) * e.cos + (this._y + this._origin.y - e.o.y) * e.sin + (e.o.x - this._origin.x);\n        y2 =  (this._y + this._origin.y - e.o.y) * e.cos - (this._x + this._origin.x - e.o.x) * e.sin + (e.o.y - this._origin.y);\n        this._setter2d('_rotation', this._rotation - e.deg);\n        this._setter2d('_x', x2 );\n        this._setter2d('_y', y2 );\n    },\n\n    // This is a setter method for all 2D properties including\n    // x, y, w, h, and rotation.\n    _setter2d: function (name, value) {\n        // Return if there is no change\n        if (this[name] === value) {\n            return;\n        }\n        //keep a reference of the old positions\n        var old = Crafty.rectManager._pool.copy(this);\n\n        var mbr;\n        //if rotation, use the rotate method\n        if (name === '_rotation') {\n            this._rotate(value); // _rotate triggers \"Rotate\"\n            //set the global Z and trigger reorder just in case\n        } else if (name === '_x' || name === '_y') {\n            // mbr is the minimal bounding rectangle of the entity\n            mbr = this._mbr;\n            if (mbr) {\n                mbr[name] -= this[name] - value;\n                // cbr is a non-minmal bounding rectangle that contains both hitbox and mbr\n                // It will exist only when the collision hitbox sits outside the entity\n                if (this._cbr){\n                    this._cbr[name] -= this[name] - value;\n                }\n            }\n            this[name] = value;\n\n            this.trigger(\"Move\", old);\n\n        } else if (name === '_h' || name === '_w') {\n            mbr = this._mbr;\n\n            var oldValue = this[name];\n            this[name] = value;\n            if (mbr) {\n                this._calculateMBR();\n            }\n            if (name === '_w') {\n                this.trigger(\"Resize\", {\n                    axis: 'w',\n                    amount: value - oldValue\n                });\n            } else if (name === '_h') {\n                this.trigger(\"Resize\", {\n                    axis: 'h',\n                    amount: value - oldValue\n                });\n            }\n            this.trigger(\"Move\", old);\n\n        } else if (name === '_z') {\n            var intValue = value << 0;\n            value = value === intValue ? intValue : intValue+1;\n            this._globalZ = value * 100000 + this[0]; //magic number 10^5 is the max num of entities\n            this[name] = value;\n            this.trigger(\"Reorder\");\n        }\n\n        //everything will assume the value\n        this[name] = value;\n\n        // flag for redraw\n        this.trigger(\"Invalidate\");\n\n        Crafty.rectManager._pool.recycle(old);\n    }\n});\n\n\n\n\n/**@\n * #Crafty.polygon\n * @category 2D\n * @kind Class\n *\n * The constructor for a polygon object used for hitboxes and click maps. Takes a set of points as an\n * argument, giving alternately the x and y coordinates of the polygon's vertices in order.\n *\n * For a polygon of `n` edges exactly `n` vertex coordinate pairs should be passed to the constructor.\n * It is advised to pass the vertices in a clockwise order.\n *\n * The constructor accepts the coordinates as either a single array or as a set of individual arguments.\n * If passed an array, the current implementation will use that array internally -- do not attempt to reuse it.\n *\n * When creating a polygon for an entity, each point should be offset or relative from the entities `x` and `y`\n * (don't include the absolute values as it will automatically calculate this).\n *\n *\n * @example\n * Two ways to create a triangle with vertices at `(50, 0)`, `(100, 100)` and `(0, 100)`.\n * ~~~\n * new Crafty.polygon([50, 0, 100, 100, 0, 100]);\n * new Crafty.polygon(50, 0, 100, 100, 0, 100);\n * ~~~\n */\nCrafty.polygon = function (poly) {\n    if (arguments.length > 1) {\n        poly = Array.prototype.slice.call(arguments, 0);\n    }\n    this.points = poly;\n};\n\nCrafty.polygon.prototype = {\n    /**@\n     * #.containsPoint\n     * @comp Crafty.polygon\n     * @kind Method\n     * \n     * @sign public Boolean .containsPoint(Number x, Number y)\n     * @param x - X position of the point\n     * @param y - Y position of the point\n     *\n     * Method is used to determine if a given point is contained by the polygon.\n     *\n     * @example\n     * ~~~\n     * var poly = new Crafty.polygon([50, 0, 100, 100, 0, 100]);\n     * poly.containsPoint(50, 50); //TRUE\n     * poly.containsPoint(0, 0); //FALSE\n     * ~~~\n     */\n    containsPoint: function (x, y) {\n        var p = this.points, l = p.length/2,\n            i, j, c = false;\n\n        for (i = 0, j = l - 1; i < l; j = i++) {\n            if (((p[2*i+1] > y) !== (p[2*j+1] > y)) && (x < (p[2*j] - p[2*i]) * (y - p[2*i+1]) / (p[2*j+1] - p[2*i+1]) + p[2*i])) {\n                c = !c;\n            }\n        }\n\n        return c;\n    },\n\n    /**@\n     * #.shift\n     * @comp Crafty.polygon\n     * @kind Method\n     * \n     * @sign public void .shift(Number x, Number y)\n     * @param x - Amount to shift the `x` axis\n     * @param y - Amount to shift the `y` axis\n     *\n     * Shifts every single point in the polygon by the specified amount.\n     *\n     * @example\n     * ~~~\n     * var poly = new Crafty.polygon([50, 0, 100, 100, 0, 100]);\n     * poly.shift(5,5);\n     * //[[55, 5, 105, 5, 5, 105];\n     * ~~~\n     */\n    shift: function (x, y) {\n        var i = 0, p =this.points,\n            l = p.length;\n        for (; i < l; i+=2) {\n            p[i] += x;\n            p[i+1] += y;\n        }\n    },\n\n    /**@\n     * #.clone\n     * @comp Crafty.polygon\n     * @kind Method\n     * \n     * @sign public void .clone()\n     * \n     * Returns a clone of the polygon.\n     *\n     * @example\n     * ~~~\n     * var poly = new Crafty.polygon([50, 0, 100, 100, 0, 100]);\n     * var shiftedpoly = poly.clone().shift(5,5);\n     * //[55, 5, 105, 5, 5, 105], but the original polygon is unchanged\n     * ~~~\n     */\n    clone: function() {\n        //Shallow clone, but points should be full of Number primitives that are copied\n        return new Crafty.polygon(this.points.slice(0));\n    },\n\n    rotate: function (e) {\n        var i = 0, p = this.points,\n            l = p.length,\n            x, y;\n\n        for (; i < l; i+=2) {\n\n            x = e.o.x + (p[i] - e.o.x) * e.cos + (p[i+1] - e.o.y) * e.sin;\n            y = e.o.y - (p[i] - e.o.x) * e.sin + (p[i+1] - e.o.y) * e.cos;\n\n            p[i] = x;\n            p[i+1] = y;\n        }\n    },\n\n    /**@\n     * #.intersectRay\n     * @comp Crafty.polygon\n     * @kind Method\n     * \n     * @sign public Number .intersectRay(Object origin, Object direction)\n     * @param origin - the point of origin from which the ray will be cast. The object must contain the properties `_x` and `_y`.\n     * @param direction - the direction the ray will be cast. It must be normalized. The object must contain the properties `x` and `y`.\n     * @returns a Number indicating the distance from the ray's origin to the closest intersection point of the polygon.\n     *          Returns `Infinity` if there is no intersection.\n     *\n     * Find the distance to the closest intersection point of the supplied ray with any of this polygon's segments.\n     *\n     * @example\n     * ~~~\n     * var poly = new Crafty.polygon([0,0, 50,0, 50,50, 0,50]);\n     *\n     * var origin = {_x: -1, _y: 25};\n     * var direction = new Crafty.math.Vector2D(1, 0).normalize();;\n     *\n     * var distance = poly.intersectRay(origin, direction);\n     * Crafty.log('Distance from origin to closest intersection point', distance); // logs '1'\n     * ~~~\n     */\n\n    // Note that for the algorithm to work, the points of the polygon have to be defined\n    // either clock-wise or counter-clock-wise\n    //\n    // Segment-segment intersection is described here: http://stackoverflow.com/a/565282/3041008\n    // see dot projection: http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/vector/#Projection\n    //\n    // origin = {_x, _y}\n    // direction = {x, y}, must be normalized\n    // edge = end - start (of segment)\n    //\n    //\n    // # Segment - segment intersection equation\n    // origin + d * direction = start + e * edge\n    //\n    // ## Solving for d\n    // (origin + d * direction) x edge = (start + e * edge) x edge\n    // edge x edge == 0\n    // d = (start − origin) × edge / (direction × edge)\n    // d_nominator = (start - origin) x edge =\n    //      (start.x - origin.x, start.y - origin.y) x (edge.x, edge.y) =\n    //      (start.x - origin.x) * edge.y - (start.y - origin.y) * edge.x\n    // d_denominator = direction x edge =\n    //      (direction.x, direction.y) x (edge.x, edge.y) =\n    //      direction.x * edge.y - direction.y * edge.x\n    //\n    // ## Solving for e\n    // (origin + d * direction) x direction = (start + e * edge) x direction\n    // direction x direction == 0\n    // edge factor must be in interval [0, 1]\n    // e = (start − origin) × direction / (direction × edge)\n    // e_nominator = (start − origin) × direction =\n    //      (start.x - origin.x) * direction.y - (start.y - origin.y) * direction.x\n    // e_denominator = d_denominator\n    //\n    //\n    // # If segments are colinear (both nominator and denominator == 0),\n    //    then minDistance is min(d0, d1) >= 0,\n    //    get d0, d1 by doing dot projection onto normalized direction vector\n    //\n    // origin + d0*direction = start\n    // d0*direction = (start - origin)\n    // -> d0 = (start - origin) • direction =\n    //      (start.x - origin.x, start.y - origin.y) • (direction.x, direction.y) =\n    //      (start.x - origin.x) * direction.x + (start.y - origin.y) * direction.y\n    //\n    // origin + d1*direction = end\n    // d1*direction = end - origin\n    // -> d1 = (end - origin) • direction =\n    //      (end.x - origin.x, end.y - origin.y) • (direction.x, direction.y) =\n    //      (end.x - origin.x) * direction.x + (end.y - origin.y) * direction.y\n    intersectRay: function (origin, direction) {\n        var points = this.points,\n            minDistance = Infinity;\n        var d, d_nom,\n            e, e_nom,\n            denom;\n\n        var originX = origin._x, directionX = direction.x,\n            originY = origin._y, directionY = direction.y;\n\n        var i = 0, l = points.length;\n        var startX = points[l - 2], endX, edgeX,\n            startY = points[l - 1], endY, edgeY;\n        for (; i < l; i += 2) {\n            endX = points[i];\n            endY = points[i+1];\n            edgeX = endX - startX;\n            edgeY = endY - startY;\n\n            d_nom = (startX - originX) * edgeY      - (startY - originY) * edgeX;\n            e_nom = (startX - originX) * directionY - (startY - originY) * directionX;\n            denom = directionX * edgeY - directionY * edgeX;\n\n            if (denom !== 0) {\n                d = d_nom / denom;\n                e = e_nom / denom;\n\n                if (e >= 0 && e <= 1 && d >= 0 && d < minDistance)\n                    minDistance = d;\n\n            } else if (d_nom === 0 || e_nom === 0) {\n\n                d = (startX - originX) * directionX + (startY - originY) * directionY;\n                if (d >= 0 && d < minDistance)\n                    minDistance = d;\n\n                d = (endX - originX) * directionX + (endY - originY) * directionY;\n                if (d >= 0 && d < minDistance)\n                    minDistance = d;\n            }\n\n            startX = endX;\n            startY = endY;\n        }\n\n        return minDistance;\n    }\n};\n\n/**@\n * #Crafty.circle\n * @category 2D\n * @kind Class\n * \n * Circle object used for hitboxes and click maps. Must pass a `x`, a `y` and a `radius` value.\n *\n *@example\n * ~~~\n * var centerX = 5,\n *     centerY = 10,\n *     radius = 25;\n *\n * new Crafty.circle(centerX, centerY, radius);\n * ~~~\n *\n * When creating a circle for an entity, each point should be offset or relative from the entities `x` and `y`\n * (don't include the absolute values as it will automatically calculate this).\n */\nCrafty.circle = function (x, y, radius) {\n    this.x = x;\n    this.y = y;\n    this.radius = radius;\n\n    // Creates an octagon that approximate the circle for backward compatibility.\n    this.points = [];\n    var theta;\n\n    for (var i = 0; i < 16; i+=2) {\n        theta = i * Math.PI / 8;\n        this.points[i] = this.x + (Math.sin(theta) * radius);\n        this.points[i+1] = this.y + (Math.cos(theta) * radius);\n    }\n};\n\nCrafty.circle.prototype = {\n    /**@\n     * #.containsPoint\n     * @comp Crafty.circle\n     * @kind Method\n     * \n     * @sign public Boolean .containsPoint(Number x, Number y)\n     * @param x - X position of the point\n     * @param y - Y position of the point\n     *\n     * Method is used to determine if a given point is contained by the circle.\n     *\n     * @example\n     * ~~~\n     * var circle = new Crafty.circle(0, 0, 10);\n     * circle.containsPoint(0, 0); //TRUE\n     * circle.containsPoint(50, 50); //FALSE\n     * ~~~\n     */\n    containsPoint: function (x, y) {\n        var radius = this.radius,\n            deltaX = this.x - x,\n            deltaY = this.y - y;\n\n        return (deltaX * deltaX + deltaY * deltaY) < (radius * radius);\n    },\n\n    /**@\n     * #.shift\n     * @comp Crafty.circle\n     * @kind Method\n     * \n     * @sign public void .shift(Number x, Number y)\n     * @param x - Amount to shift the `x` axis\n     * @param y - Amount to shift the `y` axis\n     *\n     * Shifts the circle by the specified amount.\n     *\n     * @example\n     * ~~~\n     * var circle = new Crafty.circle(0, 0, 10);\n     * circle.shift(5,5);\n     * //{x: 5, y: 5, radius: 10};\n     * ~~~\n     */\n    shift: function (x, y) {\n        this.x += x;\n        this.y += y;\n\n        var i = 0, p = this.points,\n            l = p.length;\n        for (; i < l; i+=2) {\n            p[i] += x;\n            p[i+1] += y;\n        }\n    },\n\n    rotate: function () {\n        // We are a circle, we don't have to rotate :)\n    }\n};\n\n\nCrafty.matrix = function (m) {\n    this.mtx = m;\n    this.width = m[0].length;\n    this.height = m.length;\n};\n\nCrafty.matrix.prototype = {\n    x: function (other) {\n        if (this.width !== other.height) {\n            return;\n        }\n\n        var result = [];\n        for (var i = 0; i < this.height; i++) {\n            result[i] = [];\n            for (var j = 0; j < other.width; j++) {\n                var sum = 0;\n                for (var k = 0; k < this.width; k++) {\n                    sum += this.mtx[i][k] * other.mtx[k][j];\n                }\n                result[i][j] = sum;\n            }\n        }\n        return new Crafty.matrix(result);\n    },\n\n\n    e: function (row, col) {\n        //test if out of bounds\n        if (row < 1 || row > this.mtx.length || col < 1 || col > this.mtx[0].length) return null;\n        return this.mtx[row - 1][col - 1];\n    }\n};\n"},"hash":"fad65d86faa5af93f4752db3714c6285"}