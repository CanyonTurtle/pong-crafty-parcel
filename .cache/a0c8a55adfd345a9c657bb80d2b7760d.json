{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js'),\n    document = window.document;\n\nCrafty.extend({\n    /**@\n     * #Crafty.domHelper\n     * @kind Property\n     * @category Graphics\n     *\n     * Collection of utilities for using the DOM.\n     */\n    domHelper: {\n        /**@\n         * #Crafty.domHelper.innerPosition\n         * @comp Crafty.domHelper\n         * @sign public Object Crafty.domHelper.innerPosition(HTMLElement obj)\n         * @param obj - HTML element to calculate the position\n         * @returns Object with `x` key being the `x` position, `y` being the `y` position\n         *\n         * Find a DOM elements position including\n         * padding and border.\n         */\n        innerPosition: function (obj) {\n            var rect = obj.getBoundingClientRect(),\n                x = rect.left + (window.pageXOffset ? window.pageXOffset : document.body.scrollLeft),\n                y = rect.top + (window.pageYOffset ? window.pageYOffset : document.body.scrollTop),\n\n                //border left\n                borderX = parseInt(this.getStyle(obj, 'border-left-width') || 0, 10) || parseInt(this.getStyle(obj, 'borderLeftWidth') || 0, 10) || 0,\n                borderY = parseInt(this.getStyle(obj, 'border-top-width') || 0, 10) || parseInt(this.getStyle(obj, 'borderTopWidth') || 0, 10) || 0;\n\n            x += borderX;\n            y += borderY;\n\n            return {\n                x: x,\n                y: y\n            };\n        },\n\n        /**@\n         * #Crafty.domHelper.getStyle\n         * @comp Crafty.domHelper\n         * @kind Method\n         * \n         * @sign public Object Crafty.domHelper.getStyle(HTMLElement obj, String property)\n         * @param obj - HTML element to find the style\n         * @param property - Style to return\n         *\n         * Determine the value of a style on an HTML element. Notation can be\n         * in either CSS or JS.\n         */\n        getStyle: function (obj, prop) {\n            var result;\n            if (obj.currentStyle)\n                result = obj.currentStyle[this.camelize(prop)];\n            else if (window.getComputedStyle)\n                result = document.defaultView.getComputedStyle(obj, null).getPropertyValue(this.csselize(prop));\n            return result;\n        },\n\n        /**\n         * Used in the Zepto framework\n         *\n         * Converts CSS notation to JS notation\n         */\n        camelize: function (str) {\n            return str.replace(/-+(.)?/g, function (match, chr) {\n                return chr ? chr.toUpperCase() : '';\n            });\n        },\n\n        /**\n         * Converts JS notation to CSS notation\n         */\n        csselize: function (str) {\n            return str.replace(/[A-Z]/g, function (chr) {\n                return chr ? '-' + chr.toLowerCase() : '';\n            });\n        },\n\n        /**@\n         * #Crafty.domHelper.translate\n         * @comp Crafty.domHelper\n         * @kind Method\n         * \n         * @sign public Object Crafty.domHelper.translate(Number clientX, Number clientY[, DrawLayer layer])\n         * @param clientX - clientX position in the browser screen\n         * @param clientY - clientY position in the browser screen\n         * @param layer - a Crafty draw layer\n         * @return Object `{x: ..., y: ...}` with Crafty coordinates.\n         * \n         * The parameters clientX and clientY are pixel coordinates within the visible\n         * browser window. This function translates those to Crafty coordinates (i.e.,\n         * the coordinates that you might apply to an entity), by taking into account\n         * where the stage is within the screen, what the current viewport is, etc.\n         * \n         * If a draw layer is specified, the returned object will take into account any special scaling rules for that object.\n         */\n        translate: function (clientX, clientY, layer) {\n            var doc = document.documentElement;\n            var body = document.body;\n            var view;\n            // The branch here is to deal with the fact that the viewport position is the distance TO the origin, not from\n            // But the _viewportRect is the opposite -- it uses the same convention as a rectangle that matches the viewport in that layer\n            // At some point this should be simplified, probably by altering the viewport to use the more intuitive coordinates\n            if (layer) {\n                view = layer._viewportRect();\n                return {\n                    x: (clientX - Crafty.stage.x + (doc && doc.scrollLeft || body && body.scrollLeft || 0)) / view._scale + view._x,\n                    y: (clientY - Crafty.stage.y + (doc && doc.scrollTop || body && body.scrollTop || 0)) / view._scale + view._y\n                };\n            } else {\n                view = Crafty.viewport;\n                return {\n                    x: (clientX - Crafty.stage.x + (doc && doc.scrollLeft || body && body.scrollLeft || 0)) / view._scale - view._x,\n                    y: (clientY - Crafty.stage.y + (doc && doc.scrollTop || body && body.scrollTop || 0)) / view._scale - view._y\n                };\n            }\n        }\n    }\n});"},"hash":"7b4e2df8123ab4a6dbbdb79bb74a582e"}