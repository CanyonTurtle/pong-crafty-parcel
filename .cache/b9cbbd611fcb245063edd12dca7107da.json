{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js'),\n    DEG_TO_RAD = Math.PI / 180,\n    EPSILON = 1e-6;\n\nCrafty.extend({\n    /**@\n     * #Crafty.raycast\n     * @category 2D\n     * @kind Method\n     * \n     * @sign public Array .raycast(Object origin, Object direction[, Number maxDistance][, String comp][, Boolean sort])\n     * @param origin - the point of origin from which the ray will be cast. The object must contain the properties `_x` and `_y`.\n     * @param direction - the direction the ray will be cast. It must be normalized. The object must contain the properties `x` and `y`.\n     * @param maxDistance - the maximum distance up to which intersections will be found.\n     *                      This is an optional parameter defaulting to `Infinity`.\n     *                      If it's `Infinity` find all intersections.\n     *                      If it's negative find only first intersection (if there is one).\n     *                      If it's positive find all intersections up to that distance.\n     * @param comp - check for intersection with entities that have this component applied to them.\n     *               This is an optional parameter that is disabled by default.\n     * @param sort - whether to sort the returned array by increasing distance.\n     *               May be disabled to slightly improve performance if sorted results are not needed.\n     *               Defaults to `true`.\n     * @returns an array of raycast-results that may be empty, if no intersection has been found.\n     *          Otherwise, each raycast-result looks like `{obj: Entity, distance: Number, x: Number, y: Number}`,\n     *          describing which `obj` entity has intersected the ray at intersection point `x`,`y`, `distance` px away from `origin`.\n     *\n     * Cast a ray from its `origin` in the `direction` and\n     * report entities that intersect with it, given the parameter constraints.\n     *\n     * Raycasting only reports entities, that have the `Collision` component applied to them.\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D, Collision\")\n     *       .setName('First entity')\n     *       .attr({x: 0, y: 0, w: 10, h: 10});\n     *\n     * Crafty.e(\"2D, Collision\")\n     *       .setName('Second entity')\n     *       .attr({x: 20, y: 20, w: 10, h: 10});\n     *\n     * var origin = {_x: -25, _y: -25};\n     * var direction = new Crafty.math.Vector2D(1, 1).normalize();\n     *\n     * var results = Crafty.raycast(origin, direction, -1); // find only 1st intersection\n     * Crafty.log('Intersections found', results.length); // logs '1'\n     *\n     * var result = results[0];\n     * Crafty.log('1st intersection:');\n     * Crafty.log('Entity name:', result.obj.getName()); // logs 'First entity'\n     * Crafty.log('Distance from origin to intersection point', result.distance); // logs '25 * Math.sqrt(2)'\n     * Crafty.log('Intersection point:', result.x, result.y); // logs '0' '0'\n     * ~~~\n     *\n     * @see Crafty.polygon#.intersectRay\n     * @see Crafty.map#Crafty.map.traverseRay\n     */\n\n    // origin = {_x, _y}\n    // direction = {x, y}, must be normalized\n    //\n    // Add approximate ray intersection with bounding rectangle,\n    // before doing exact ray intersection if needed in future.\n    // https://gist.github.com/mucaho/77846e9fc0cd3c8b600c\n    raycast: function(origin, direction) {\n        // default parameters\n        var comp = 'obj',\n            maxDistance = Infinity,\n            sort = true;\n        // optional arguments\n        var argument, type;\n        for (var i = 2, l = arguments.length; i < l; ++i) {\n            argument = arguments[i];\n            type = typeof argument;\n            if (type === 'number') maxDistance = argument + EPSILON; // make it inclusive\n            else if (type === 'string') comp = argument;\n            else if (type === 'boolean') sort = argument;\n        }\n\n        var ox = origin._x,\n            oy = origin._y,\n            dx = direction.x,\n            dy = direction.y;\n\n\n        var alreadyChecked = {},\n            results = [];\n\n\n        if (maxDistance < 0) { // find first intersection\n\n            var closestObj = null,\n                minDistance = Infinity;\n\n            // traverse map\n            Crafty.map.traverseRay(origin, direction, function(obj, previousCellDistance) {\n                // check if we advanced to next cell\n                //      then report closest object from previous cell\n                //          if intersection point is in previous cell\n                if (closestObj && minDistance < previousCellDistance) {\n                    results.push({\n                        obj: closestObj,\n                        distance: minDistance,\n                        x: ox + minDistance * dx,\n                        y: oy + minDistance * dy\n                    });\n                    closestObj = null;\n                    minDistance = Infinity;\n\n                    return true;\n                }\n\n                // object must contain polygon hitbox, the specified component and must not already be checked\n                if (!obj.map || !obj.__c[comp] || alreadyChecked[obj[0]]) return;\n                alreadyChecked[obj[0]] = true;\n\n                // do exact intersection test\n                var distance = obj.map.intersectRay(origin, direction);\n                if (distance < minDistance) {\n                    closestObj = obj;\n                    minDistance = distance;\n                }\n            });\n\n            // in case traversal ended and we haven't yet pushed nearest intersecting object\n            if (closestObj) {\n                results.push({\n                    obj: closestObj,\n                    distance: minDistance,\n                    x: ox + minDistance * dx,\n                    y: oy + minDistance * dy\n                });\n            }\n\n        } else { // find intersections up to max distance\n\n            // traverse map\n            Crafty.map.traverseRay(origin, direction, function(obj, previousCellDistance) {\n                // check if we advanced to next cell\n                //      then cancel traversal if previousCellDistance > maxDistance\n                if (previousCellDistance > maxDistance) {\n                    return true;\n                }\n\n                // object must contain polygon hitbox, the specified component and must not already be checked\n                if (!obj.map || !obj.__c[comp] || alreadyChecked[obj[0]]) return;\n                alreadyChecked[obj[0]] = true;\n\n                // do exact intersection test\n                var distance = obj.map.intersectRay(origin, direction);\n                if (distance < maxDistance) {\n                    results.push({\n                        obj: obj,\n                        distance: distance,\n                        x: ox + distance * dx,\n                        y: oy + distance * dy\n                    });\n                }\n            });\n        }\n\n\n        if (sort) results.sort(function(a, b) { return a.distance - b.distance; });\n\n\n        return results;\n    }\n});\n\n/**@\n * #Collision\n * @category 2D\n * @kind Component\n * \n * @trigger HitOn - Triggered when collisions occur. Will not trigger again until collisions of this type cease, or an event is requested once more (using `resetHitChecks(component)`). - { hitData }\n * @trigger HitOff - Triggered when collision with a specific component type ceases - String - componentName\n *\n * Component to detect collision between any two convex polygons.\n *\n * If collision checks are registered for multiple component and collisions with\n * multiple types occur simultaniously, each collision will cause an individual\n * event to fire.\n *\n * @note All data received from events is only valid for the duration of the event's callback.\n * If you wish to preserve the data, make a copy of it.\n *\n * For a description of collision event data (hitData above), see the documentation for\n * `.hit()`.\n *\n * @see 2D\n */\nCrafty.c(\"Collision\", {\n    init: function () {\n        this.requires(\"2D\");\n        this._collisionData = {};\n\n        this.collision();\n    },\n\n    // Run by Crafty when the component is removed\n    remove: function() {\n        this._cbr = null;\n        this.unbind(\"Resize\", this._resizeMap);\n        this.unbind(\"Resize\", this._checkBounds);\n    },\n\n    /**@\n     * #.collision\n     * @comp Collision\n     * @kind Method\n     *\n     * @trigger NewHitbox - when a new hitbox is assigned - Crafty.polygon\n     *\n     * @sign public this .collision([Crafty.polygon polygon])\n     * @param polygon - Optional Crafty.polygon object that will act as the hit area.\n     *\n     * @sign public this .collision([Array coordinatePairs])\n     * @param coordinatePairs - Optional array of x, y coordinate pairs to generate a hit area polygon.\n     *\n     * @sign public this .collision([x1, y1,.., xN, yN])\n     * @param point# - Optional list of x, y coordinate pairs to generate a hit area polygon.\n     *\n     * Constructor that takes a polygon, an array of points or a list of points to use as the hit area,\n     * with points being relative to the object's position in its unrotated state.\n     *\n     * The hit area must be a convex shape and not concave for collision detection to work properly.\n     *\n     * If no parameter is passed, the x, y, w, h properties of the entity will be used, and the hitbox will be resized when the entity is.\n     *\n     * If a hitbox is set that is outside of the bounds of the entity itself, there will be a small performance penalty as it is tracked separately.\n     *\n     * In order for your custom hitbox to have any effect, you have to add the `Collision` component to all other entities this entity needs to collide with using this custom hitbox.\n     * On the contrary the collisions will be resolved using the default hitbox. See `.hit()` - `MBR` represents default hitbox collision, `SAT` represents custom hitbox collision.\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D, Collision\").collision(\n     *     new Crafty.polygon([50, 0,  100, 100,  0, 100])\n     * );\n     *\n     * Crafty.e(\"2D, Collision\").collision([50, 0,  100, 100,  0, 100]);\n     *\n     * Crafty.e(\"2D, Collision\").collision(50, 0,  100, 100,  0, 100);\n     * ~~~\n     *\n     * @see Crafty.polygon\n     */\n    collision: function (polygon) {\n        // Unbind anything bound to \"Resize\"\n        this.unbind(\"Resize\", this._resizeMap);\n        this.unbind(\"Resize\", this._checkBounds);\n\n        if (!polygon) {\n            // If no polygon is specified, then a polygon is created that matches the bounds of the entity\n            // It will be adjusted on a \"Resize\" event\n            polygon = new Crafty.polygon([0, 0, this._w, 0, this._w, this._h, 0, this._h]);\n            this.bind(\"Resize\", this._resizeMap);\n            this._cbr = null;\n        } else {\n            // Otherwise, we set the specified hitbox, converting from a list of arguments to a polygon if necessary\n            if (arguments.length > 1) {\n                //convert args to array to create polygon\n                var args = Array.prototype.slice.call(arguments, 0);\n                polygon = new Crafty.polygon(args);\n            // Otherwise, we set the specified hitbox, converting from an array of points to a polygon if necessary\n            } else if (polygon.constructor === Array) {\n                //Clone the array so we don't modify it for anything else that might be using it\n                polygon = new Crafty.polygon(polygon.slice());\n            // Otherwise, we set the specified hitbox\n            } else {\n                //Clone the polygon so we don't modify it for anything else that might be using it\n                polygon = polygon.clone();\n            }\n            // Check to see if the polygon sits outside the entity, and set _cbr appropriately\n            // On resize, the new bounds will be checked if necessary\n            this._findBounds(polygon.points);\n        }\n\n        // If the entity is currently rotated, the points in the hitbox must also be rotated\n        if (this.rotation) {\n            polygon.rotate({\n                cos: Math.cos(-this.rotation * DEG_TO_RAD),\n                sin: Math.sin(-this.rotation * DEG_TO_RAD),\n                o: {\n                    x: this._origin.x,\n                    y: this._origin.y\n                }\n            });\n        }\n\n        // Finally, assign the hitbox, and attach it to the \"Collision\" entity\n        this.map = polygon;\n        this.attach(this.map);\n        this.map.shift(this._x, this._y);\n        this.trigger(\"NewHitbox\", polygon);\n        return this;\n    },\n\n    /**@\n     * #.cbr\n     * @comp Collision\n     * @kind Method\n     * \n     * @sign public Object .cbr([Object cbr])\n     * @param cbr - an object to use as output\n     * @returns an object with `_x`, `_y`, `_w`, and `_h` properties; if an object is passed in, it will be reused rather than creating a new object.\n     *\n     * Return an object containing a copy of this entity's collision bounding rectangle.\n     * The CBR encompasses both the entity's custom collision hitbox and its MBR.\n     * If the custom collision hitbox does not sit outside the entity it will return the entity's minimum bounding rectangle (`.mbr()`) instead.\n     *\n     * @note The keys have an underscore prefix. This is due to the x, y, w, h properties\n     * being setters and getters that wrap the underlying properties with an underscore (_x, _y, _w, _h).\n     *\n     * @see 2D#.mbr\n     */\n    cbr: function (cbr) {\n        cbr = cbr || {};\n        if (!this._cbr) {\n            return this.mbr(cbr);\n        } else {\n            cbr._x = (this._cbr._x);\n            cbr._y = (this._cbr._y);\n            cbr._w = (this._cbr._w);\n            cbr._h = (this._cbr._h);\n            return cbr;\n        }\n    },\n\n    // If the hitbox is set by hand, it might extend beyond the entity.\n    // In such a case, we need to track this separately.\n    // This function finds a (non-minimal) bounding circle around the hitbox.\n    //\n    // It uses a pretty naive algorithm to do so, for more complicated options see [wikipedia](http://en.wikipedia.org/wiki/Bounding_sphere).\n    _findBounds: function(points) {\n        var minX = Infinity, maxX = -Infinity, minY=Infinity, maxY=-Infinity;\n        var l = points.length;\n\n        // Calculate the MBR of the points by finding the min/max x and y\n        for (var i=0; i<l; i+=2) {\n            if (points[i] < minX)\n                minX = points[i];\n            if (points[i] > maxX)\n                maxX = points[i];\n            if (points[i+1] < minY)\n                minY = points[i+1];\n            if (points[i+1] > maxY)\n                maxY = points[i+1];\n        }\n\n        // This describes a circle centered on the MBR of the points, with a diameter equal to its diagonal\n        // It will be used to find a rough bounding box round the points, even if they've been rotated\n        var cbr = {\n            cx: (minX + maxX) / 2,\n            cy: (minY + maxY) / 2,\n            r: Math.sqrt((maxX - minX)*(maxX - minX) + (maxY - minY)*(maxY - minY)) / 2\n        };\n\n        // We need to worry about resizing, but only if resizing could possibly change whether the hitbox is in or out of bounds\n        // Thus if the upper-left corner is out of bounds, then there's no need to recheck on resize\n        if (minX >= 0 && minY >= 0) {\n            this._checkBounds = function() {\n                if (this._cbr === null && this._w < maxX || this._h < maxY) {\n                   this._cbr = cbr;\n                   this._calculateMBR();\n                } else if (this._cbr) {\n                    this._cbr = null;\n                    this._calculateMBR();\n                }\n            };\n            this.bind(\"Resize\", this._checkBounds);\n        }\n\n        // If the hitbox is within the entity, _cbr is null\n        // Otherwise, set it, and immediately calculate the bounding box.\n        if (minX >= 0 && minY >= 0 && maxX <= this._w && maxY <= this._h) {\n            this._cbr = null;\n            return false;\n        } else {\n            this._cbr = cbr;\n            this._calculateMBR();\n            return true;\n        }\n    },\n\n    // The default behavior is to match the hitbox to the entity.\n    // This function will change the hitbox when a \"Resize\" event triggers.\n    _resizeMap: function (e) {\n        var dx, dy, rot = this.rotation * DEG_TO_RAD,\n            points = this.map.points;\n\n        // Depending on the change of axis, move the corners of the rectangle appropriately\n        if (e.axis === 'w') {\n            if (rot) {\n                dx = e.amount * Math.cos(rot);\n                dy = e.amount * Math.sin(rot);\n            } else {\n                dx = e.amount;\n                dy = 0;\n            }\n\n            // \"top right\" point shifts on change of w\n            points[2] += dx;\n            points[3] += dy;\n        } else {\n            if (rot) {\n                dy = e.amount * Math.cos(rot);\n                dx = -e.amount * Math.sin(rot);\n            } else {\n                dx = 0;\n                dy = e.amount;\n            }\n\n            // \"bottom left\" point shifts on change of h\n            points[6] += dx;\n            points[7] += dy;\n        }\n\n        // \"bottom right\" point shifts on either change\n        points[4] += dx;\n        points[5] += dy;\n    },\n\n    /**@\n     * #.hit\n     * @comp Collision\n     * @kind Method\n     * \n     * @sign public Array .hit(String component)\n     * @param component - Check collision with entities that have this component\n     * applied to them.\n     * @return `null` if there is no collision. If a collision is detected,\n     * returns an Array of collision data objects (see below).\n     *\n     * Tests for collisions with entities that have the specified component\n     * applied to them.\n     * If a collision is detected, data regarding the collision will be present in\n     * the array returned by this method.\n     * If no collisions occur, this method returns `null`.\n     *\n     * Following is a description of a collision data object that this method may\n     * return: The returned collision data will be an Array of Objects with the\n     * type of collision used, the object collided and if the type used was SAT (a polygon was used as the hitbox) then an amount of overlap.\n     * ~~~\n     * [{\n     *    obj: [entity],\n     *    type: [\"MBR\" or \"SAT\"],\n     *    overlap: [number]\n     * }]\n     * ~~~\n     *\n     * - **obj:** The entity with which the collision occured.\n     * - **type:** Collision detection method used. One of:\n     *   - *MBR:* Standard axis aligned rectangle intersection (`.intersect` in the 2D component).\n     *   - *SAT:* Collision between any two convex polygons. Used when both colliding entities have the `Collision` component applied to them.\n     * - **overlap:** If SAT collision was used, this will signify the overlap percentage between the colliding entities.\n     *\n     * Keep in mind that both entities need to have the `Collision` component, if you want to check for `SAT` (custom hitbox) collisions between them.\n     *\n     * If you want more fine-grained control consider using `Crafty.map.search()`.\n     *\n     * @example\n     * Resolving collisions with static colliders (walls) for moving entity (player).\n     * ~~~\n     * Crafty.e(\"2D, Fourway, Collision, player\")\n     *       .attr({x: 32, y: 32, w: 32, h: 32})\n     *       .collision([0, 16, 16, 0, 32, 16, 16, 32])\n     *       .fourway()\n     *       .bind('Moved', function(evt) { // after player moved\n     *         var hitDatas, hitData;\n     *         if ((hitDatas = this.hit('wall'))) { // check for collision with walls\n     *           hitData = hitDatas[0]; // resolving collision for just one collider\n     *           if (hitData.type === 'SAT') { // SAT, advanced collision resolution\n     *             // move player back by amount of overlap\n     *             this.x -= hitData.overlap * hitData.normal.x;\n     *             this.y -= hitData.overlap * hitData.normal.y;\n     *           } else { // MBR, simple collision resolution\n     *             // move player to position before he moved (on respective axis)\n     *             this[evt.axis] = evt.oldValue;\n     *           }\n     *         }\n     *       });\n     * ~~~\n     *\n     * @see Crafty.map#Crafty.map.search\n     */\n    hit: function (component) {\n        var area = this._cbr || this._mbr || this,\n            results = Crafty.map.search(area, false),\n            i = 0,\n            l = results.length,\n            dupes = {},\n            id, obj, oarea, key,\n            overlap = Crafty.rectManager.overlap,\n            hasMap = ('map' in this && 'containsPoint' in this.map),\n            finalresult = [];\n\n        if (!l) {\n            return null;\n        }\n\n        for (; i < l; ++i) {\n            obj = results[i];\n            oarea = obj._cbr || obj._mbr || obj; //use the mbr\n\n            if (!obj) continue;\n            id = obj[0];\n\n            //check if not added to hash and that actually intersects\n            if (!dupes[id] && this[0] !== id && obj.__c[component] && overlap(oarea, area))\n                dupes[id] = obj;\n        }\n\n        for (key in dupes) {\n            obj = dupes[key];\n\n            if (hasMap && 'map' in obj) {\n                var SAT = this._SAT(this.map, obj.map);\n                SAT.obj = obj;\n                SAT.type = \"SAT\";\n                if (SAT) finalresult.push(SAT);\n            } else {\n                finalresult.push({\n                    obj: obj,\n                    type: \"MBR\"\n                });\n            }\n        }\n\n        if (!finalresult.length) {\n            return null;\n        }\n\n        return finalresult;\n    },\n\n    /**@\n     * #.onHit\n     * @comp Collision\n     * @kind Method\n     * \n     * @sign public this .onHit(String component, Function callbackOn[, Function callbackOff])\n     * @param component - Component to check collisions for.\n     * @param callbackOn - Callback method to execute upon collision with the component.\n     *                     The first argument passed  will be the results of the collision check in the same format documented for `hit()`.\n     *                     The second argument passed will be a Boolean indicating whether the collision with a component occurs for the first time.\n     * @param callbackOff - Callback method executed once as soon as collision stops.\n     *\n     * Creates an EnterFrame event calling `.hit()` each frame.  When a collision is detected the `callbackOn` will be invoked.\n     *\n     * Note that the `callbackOn` will be invoked every frame the collision is active, not just the first time the collision occurs.\n     * Use the second argument passed to `callbackOn` to differentiate that, which will be `true` if it's the first time the collision occurs.\n     *\n     * If you want more fine-grained control consider using `.checkHits()`, `.hit()` or even `Crafty.map.search()`.\n     *\n     * @example\n     * Respond to collisions between player and bullets.\n     * ~~~\n     * Crafty.e(\"2D, Collision, player\")\n     *       .attr({ health: 100 })\n     *       .onHit('bullet', function(hitDatas) { // on collision with bullets\n     *         for (var i = 0, l = hitDatas.length; i < l; ++i) { // for each bullet hit\n     *           hitDatas[i].obj.destroy(); // destroy the bullet\n     *           this.health -= 25; // player looses health\n     *           if (this.health <= 0) // once player's health depletes\n     *             this.destroy(); // player dies\n     *         }\n     *       });\n     * ~~~\n     *\n     * @see .checkHits\n     * @see .hit\n     * @see Crafty.map#Crafty.map.search\n     */\n    onHit: function (component, callbackOn, callbackOff) {\n        var justHit = false;\n        this.bind(\"EnterFrame\", function () {\n            var hitData = this.hit(component);\n            if (hitData) {\n                callbackOn.call(this, hitData, !justHit);\n                justHit = true;\n            } else if (justHit) {\n                if (typeof callbackOff === 'function') {\n                    callbackOff.call(this);\n                }\n                justHit = false;\n            }\n        });\n        return this;\n    },\n\n    /**\n     * This is a helper method for creating collisions handlers set up by `checkHits`. Do not call this directly.\n     *\n     * @param {String} component - The name of the component for which this handler checks for collisions.\n     * @param {Object} collisionData - Collision data object used to track collisions with the specified component.\n     *\n     * @see .checkHits\n     */\n    _createCollisionHandler: function(component, collisionData) {\n        return function() {\n            var hitData = this.hit(component);\n\n            if (collisionData.occurring === true) {\n                if (hitData !== null) {\n                    // The collision is still in progress\n                    return;\n                }\n\n                collisionData.occurring = false;\n                this.trigger(\"HitOff\", component);\n            } else if (hitData !== null) {\n                collisionData.occurring = true;\n                this.trigger(\"HitOn\", hitData);\n            }\n        };\n    },\n\n    /**@\n     * #.checkHits\n     * @comp Collision\n     * @kind Method\n     * \n     * @sign public this .checkHits(String componentList)\n     * @param componentList - A comma seperated list of components to check for collisions with.\n     * @sign public this .checkHits(String component1[, .., String componentN])\n     * @param component# - A component to check for collisions with.\n     *\n     * Performs collision checks against all entities that have at least one of\n     * the components specified when calling this method. If collisions occur,\n     * a \"HitOn\" event containing the collision information will be fired for the\n     * entity on which this method was invoked. See the documentation for `.hit()`\n     * for a description of collision data contained in the event.\n     * When a collision that was reported ends, a corresponding \"HitOff\" event\n     * will be fired.\n     *\n     * Calling this method more than once for the same component type will not\n     * cause redundant hit checks.\n     *\n     * If you want more fine-grained control consider using `.hit()` or even `Crafty.map.search()`.\n     *\n     * @note Hit checks are performed upon entering each new frame (using\n     * the *EnterFrame* event). It is entirely possible for object to move in\n     * said frame after the checks were performed (even if the more is the\n     * result of *EnterFrame*, as handlers run in no particular order). In such\n     * a case, the hit events will not fire until the next check is performed in\n     * the following frame.\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D, Collision\")\n     *     .checkHits('Solid') // check for collisions with entities that have the Solid component in each frame\n     *     .bind(\"HitOn\", function(hitData) {\n     *         Crafty.log(\"Collision with Solid entity occurred for the first time.\");\n     *     })\n     *     .bind(\"HitOff\", function(comp) {\n     *         Crafty.log(\"Collision with Solid entity ended.\");\n     *     });\n     * ~~~\n     *\n     * @see .hit\n     * @see Crafty.map#Crafty.map.search\n     */\n    checkHits: function () {\n        var components = arguments;\n        var i = 0;\n\n        if (components.length === 1) {\n            components = components[0].split(/\\s*,\\s*/);\n        }\n\n        for (; i < components.length; ++i) {\n            var component = components[i];\n            var collisionData = this._collisionData[component];\n\n            if (collisionData !== undefined) {\n                // There is already a handler for collision with this component\n                continue;\n            }\n\n            this._collisionData[component] = collisionData = { occurring: false, handler: null };\n            collisionData.handler = this._createCollisionHandler(component, collisionData);\n\n            this.bind(\"EnterFrame\", collisionData.handler);\n        }\n\n        return this;\n    },\n\n    /**@\n     * #.ignoreHits\n     * @comp Collision\n     * @kind Method\n     *\n     * @sign public this .ignoreHits()\n     *\n     * @sign public this .ignoreHits(String componentList)\n     * @param componentList - A comma separated list of components to stop checking\n     * for collisions with.\n     *\n     * @sign public this .ignoreHits(String component1[, .., String componentN])\n     * @param component# - A component to stop checking for collisions with.\n     *\n     * Stops checking for collisions with all, or certain, components. If called\n     * without arguments, this method will cause all collision checks on the\n     * entity to cease. To disable checks for collisions with specific\n     * components, specify the components as a comma separated string or as\n     * a set of arguments.\n     *\n     * Calling this method with component names for which there are no collision\n     * checks has no effect.\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D, Collision\")\n     *     .checkHits('Solid')\n     *     ...\n     *     .ignoreHits('Solid'); // stop checking for collisions with entities that have the Solid component\n     * ~~~\n     */\n    ignoreHits: function () {\n        var components = arguments;\n        var i = 0;\n        var collisionData;\n\n        if (components.length === 0) {\n            for (collisionData in this._collisionData) {\n                this.unbind(\"EnterFrame\", collisionData.handler);\n            }\n\n            this._collisionData = {};\n        }\n\n        if (components.length === 1) {\n            components = components[0].split(/\\s*,\\s*/);\n        }\n\n        for (; i < components.length; ++i) {\n            var component = components[i];\n            collisionData = this._collisionData[component];\n\n            if (collisionData === undefined) {\n                continue;\n            }\n\n            this.unbind(\"EnterFrame\", collisionData.handler);\n            delete this._collisionData[component];\n        }\n\n        return this;\n    },\n\n    /**@\n     * #.resetHitChecks\n     * @comp Collision\n     * @kind Method\n     * \n     * @sign public this .resetHitChecks()\n     * @sign public this .resetHitChecks(String componentList)\n     * @param componentList - A comma seperated list of components to re-check\n     * for collisions with.\n     * @sign public this .resetHitChecks(String component1[, .., String componentN])\n     * @param component# - A component to re-check for collisions with.\n     *\n     * Causes collision events to be received for collisions that are already\n     * taking place (normally, an additional event would not fire before said\n     * collisions cease and happen another time).\n     * If called without arguments, this method will cause all collision checks on the\n     * entity to fire events once more. To re-check for collisions with specific\n     * components, specify the components as a comma separated string or as\n     * a set of arguments.\n     *\n     * Calling this method with component names for which there are no collision\n     * checks has no effect.\n     *\n     * @example\n     * ~~~\n     * // this example fires the HitOn event each frame the collision with the Solid entity is active, instead of just the first time the collision occurs.\n     * Crafty.e(\"2D, Collision\")\n     *     .checkHits('Solid')\n     *     .bind(\"HitOn\", function(hitData) {\n     *         Crafty.log(\"Collision with Solid entity was reported in this frame again!\");\n     *         this.resetHitChecks('Solid'); // fire the HitOn event in the next frame also, if the collision is still active.\n     *     })\n     * ~~~\n     */\n    resetHitChecks: function() {\n        var components = arguments;\n        var i = 0;\n        var collisionData;\n\n        if (components.length === 0) {\n            for (collisionData in this._collisionData) {\n                this._collisionData[collisionData].occurring = false;\n            }\n        }\n\n        if (components.length === 1) {\n            components = components[0].split(/\\s*,\\s*/);\n        }\n\n        for (; i < components.length; ++i) {\n            var component = components[i];\n            collisionData = this._collisionData[component];\n\n            if (collisionData === undefined) {\n                continue;\n            }\n\n            collisionData.occurring = false;\n        }\n\n        return this;\n    },\n\n    _SAT: function (poly1, poly2) {\n        var i = 0,\n            points1 = poly1.points, points2 = poly2.points,\n            l = points1.length/2,\n            j, k = points2.length/2,\n            nx=0, ny=0,\n            length,\n            min1, min2,\n            max1, max2,\n            interval,\n            MTV = -Infinity,\n            MNx = null,\n            MNy = null,\n            dot,\n            np;\n\n        //loop through the edges of Polygon 1\n        for (; i < l; i++) {\n            np = (i === l - 1 ? 0 : i + 1);\n\n            //generate the normal for the current edge\n            nx = -(points1[2*i+1] - points1[2*np+1]);\n            ny = (points1[2*i] - points1[2*np]);\n\n            //normalize the vector\n            length = Math.sqrt(nx * nx + ny * ny);\n            nx /= length;\n            ny /= length;\n\n            //default min max\n            min1 = min2 = Infinity;\n            max1 = max2 = -Infinity;\n\n            //project all vertices from poly1 onto axis\n            for (j = 0; j < l; ++j) {\n                dot = points1[2*j] * nx + points1[2*j+1] * ny;\n                if (dot > max1) max1 = dot;\n                if (dot < min1) min1 = dot;\n            }\n\n            //project all vertices from poly2 onto axis\n            for (j = 0; j < k; ++j) {\n                dot = points2[2*j] * nx + points2[2*j+1] * ny;\n                if (dot > max2) max2 = dot;\n                if (dot < min2 ) min2 = dot;\n            }\n\n            //calculate the minimum translation vector should be negative\n            if (min1 < min2) {\n                interval = min2 - max1;\n                nx = -nx;\n                ny = -ny;\n            } else {\n                interval = min1 - max2;\n            }\n\n            //exit early if positive\n            if (interval >= 0) {\n                return false;\n            }\n\n            if (interval > MTV) {\n                MTV = interval;\n                MNx = nx;\n                MNy = ny;\n            }\n        }\n\n        //loop through the edges of Polygon 2\n        for (i = 0; i < k; i++) {\n            np = (i === k - 1 ? 0 : i + 1);\n\n            //generate the normal for the current edge\n            nx = -(points2[2*i+1] - points2[2*np+1]);\n            ny = (points2[2*i] - points2[2*np]);\n\n            //normalize the vector\n            length = Math.sqrt(nx * nx + ny * ny);\n            nx /= length;\n            ny /= length;\n\n            //default min max\n            min1 = min2 = Infinity;\n            max1 = max2 = -Infinity;\n\n            //project all vertices from poly1 onto axis\n            for (j = 0; j < l; ++j) {\n                dot = points1[2*j] * nx + points1[2*j+1] * ny;\n                if (dot > max1) max1 = dot;\n                if (dot < min1) min1 = dot;\n            }\n\n            //project all vertices from poly2 onto axis\n            for (j = 0; j < k; ++j) {\n                dot = points2[2*j] * nx + points2[2*j+1] * ny;\n                if (dot > max2) max2 = dot;\n                if (dot < min2) min2 = dot;\n            }\n\n            //calculate the minimum translation vector should be negative\n            if (min1 < min2) {\n                interval = min2 - max1;\n                nx = -nx;\n                ny = -ny;\n            } else {\n                interval = min1 - max2;\n            }\n\n            //exit early if positive\n            if (interval >= 0) {\n                return false;\n            }\n\n            if (interval > MTV) {\n                MTV = interval;\n                MNx = nx;\n                MNy = ny;\n            }\n        }\n\n        return {\n            overlap: MTV,\n            normal: {\n                x: MNx,\n                y: MNy\n            }\n        };\n    }\n});\n"},"hash":"6ff127fdbe898f51f747567c997da345"}