{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js'),    \n    document = window.document;\n\n/**@\n * #Particles\n * @category Graphics\n * @kind Component\n * \n * @trigger ParticleEnd - when the particle animation has finished\n *\n * Based on Parcycle by Mr. Speaker, licensed under the MIT, Ported by Leo Koppelkamm\n *\n * @note This requires the canvas element, and won't do anything if the browser doesn't support it!\n *\n * For implementation details, check out the source code.\n */\nCrafty.c(\"Particles\", {\n    init: function () {\n        //We need to clone it\n        this._Particles = Crafty.clone(this._Particles);\n        this._Particles.parentEntity = this;\n        this._particlesPaused = false;\n    },\n\n    /**@\n     * #.particles\n     * @comp Particles\n     * @kind Method\n     * \n     * @sign public this .particles(Object options)\n     * @param options - Map of options that specify the behavior and look of the particles.\n     *\n     * @example\n     * ~~~\n     * var options = {\n     *   maxParticles: 150,\n     *   size: 18,\n     *   sizeRandom: 4,\n     *   speed: 1,\n     *   speedRandom: 1.2,\n     *   // Lifespan in frames\n     *   lifeSpan: 29,\n     *   lifeSpanRandom: 7,\n     *   // Angle is calculated clockwise: 12pm is 0deg, 3pm is 90deg etc.\n     *   angle: 65,\n     *   angleRandom: 34,\n     *   startColour: [255, 131, 0, 1],\n     *   startColourRandom: [48, 50, 45, 0],\n     *   endColour: [245, 35, 0, 0],\n     *   endColourRandom: [60, 60, 60, 0],\n     *   // Only applies when fastMode is off, specifies how sharp the gradients are drawn\n     *   sharpness: 20,\n     *   sharpnessRandom: 10,\n     *   // Random spread from origin\n     *   spread: 10,\n     *   // How many frames should this last\n     *   duration: -1,\n     *   // Will draw squares instead of circle gradients\n     *   fastMode: false,\n     *   gravity: { x: 0, y: 0.1 },\n     *   // sensible values are 0-3\n     *   jitter: 0,\n     *   // Offset for the origin of the particles\n     *   originOffset: {x: 0, y: 0}\n     * };\n     *\n     * Crafty.e(\"2D,Canvas,Particles\").particles(options);\n     * ~~~\n     */\n    particles: function (options) {\n\n        if (!Crafty.support.canvas || Crafty.deactivateParticles) return this;\n\n        //If we drew on the main canvas, we'd have to redraw\n        //potentially huge sections of the screen every frame\n        //So we create a separate canvas, where we only have to redraw\n        //the changed particles.\n        var c, ctx, relativeX, relativeY, bounding;\n\n        c = document.createElement(\"canvas\");\n        c.width = Crafty.viewport.width;\n        c.height = Crafty.viewport.height;\n        c.style.position = 'absolute';\n        c.style.left = \"0px\";\n        c.style.top = \"0px\";\n\n        Crafty.stage.elem.appendChild(c);\n\n        ctx = c.getContext('2d');\n\n        this._Particles.init(options);\n\n        // Clean up the DOM when this component is removed\n        this.bind('Remove', function () {\n            Crafty.stage.elem.removeChild(c);\n        }).bind(\"RemoveComponent\", function (id) {\n            if (id === \"particles\")\n                Crafty.stage.elem.removeChild(c);\n        });\n\n        relativeX = this.x + Crafty.viewport.x;\n        relativeY = this.y + Crafty.viewport.y;\n        this._Particles.position = this._Particles.vectorHelpers.create(relativeX, relativeY);\n\n        var oldViewport = {\n            x: Crafty.viewport.x,\n            y: Crafty.viewport.y\n        };\n\n        this.bind('EnterFrame', function () {\n            if (this._particlesPaused) return;\n            relativeX = this.x + Crafty.viewport.x;\n            relativeY = this.y + Crafty.viewport.y;\n            this._Particles.viewportDelta = {\n                x: Crafty.viewport.x - oldViewport.x,\n                y: Crafty.viewport.y - oldViewport.y\n            };\n\n            oldViewport = {\n                x: Crafty.viewport.x,\n                y: Crafty.viewport.y\n            };\n\n            this._Particles.position = this._Particles.vectorHelpers.create(relativeX, relativeY);\n\n            //Selective clearing\n            if (typeof Crafty.rectManager.boundingRect === 'function') {\n                bounding = Crafty.rectManager.boundingRect(this._Particles.register);\n                if (bounding) ctx.clearRect(bounding._x, bounding._y, bounding._w, bounding._h);\n            } else {\n                ctx.clearRect(0, 0, Crafty.viewport.width, Crafty.viewport.height);\n            }\n\n            //This updates all particle colors & positions\n            this._Particles.update();\n\n            //This renders the updated particles\n            this._Particles.render(ctx);\n        });\n        return this;\n    },\n    _Particles: {\n        presets: {\n            maxParticles: 150,\n            size: 18,\n            sizeRandom: 4,\n            speed: 1,\n            speedRandom: 1.2,\n            // Lifespan in frames\n            lifeSpan: 29,\n            lifeSpanRandom: 7,\n            // Angle is calculated clockwise: 12pm is 0deg, 3pm is 90deg etc.\n            angle: 65,\n            angleRandom: 34,\n            startColour: [255, 131, 0, 1],\n            startColourRandom: [48, 50, 45, 0],\n            endColour: [245, 35, 0, 0],\n            endColourRandom: [60, 60, 60, 0],\n            // Only applies when fastMode is off, specifies how sharp the gradients are drawn\n            sharpness: 20,\n            sharpnessRandom: 10,\n            // Random spread from origin\n            spread: 10,\n            // How many frames should this last\n            duration: -1,\n            // Will draw squares instead of circle gradients\n            fastMode: false,\n            gravity: {\n                x: 0,\n                y: 0.1\n            },\n            // sensible values are 0-3\n            jitter: 0,\n            // offset of particles from origin\n            originOffset: {x: 0, y: 0},\n\n            //Don't modify the following\n            particles: [],\n            active: true,\n            particleCount: 0,\n            elapsedFrames: 0,\n            emissionRate: 0,\n            emitCounter: 0,\n            particleIndex: 0\n        },\n\n\n        init: function (options) {\n            this.position = this.vectorHelpers.create(0, 0);\n            if (typeof options === 'undefined') options = {};\n\n            //Create current config by merging given options and presets.\n            for (var key in this.presets) {\n                if (typeof options[key] !== 'undefined') this[key] = options[key];\n                else this[key] = this.presets[key];\n            }\n\n            this.emissionRate = this.maxParticles / this.lifeSpan;\n            this.positionRandom = this.vectorHelpers.create(this.spread, this.spread);\n        },\n\n        addParticle: function () {\n            if (this.particleCount === this.maxParticles) {\n                return false;\n            }\n\n            // Take the next particle out of the particle pool we have created and initialize it\n            var particle = new this.particle(this.vectorHelpers);\n            this.initParticle(particle);\n            this.particles[this.particleCount] = particle;\n            // Increment the particle count\n            this.particleCount++;\n\n            return true;\n        },\n        RANDM1TO1: function () {\n            return Math.random() * 2 - 1;\n        },\n        initParticle: function (particle) {\n            particle.position.x = Crafty.viewport._scale * (this.position.x + this.originOffset.x + this.positionRandom.x * this.RANDM1TO1());\n            particle.position.y = Crafty.viewport._scale * (this.position.y + this.originOffset.y + this.positionRandom.y * this.RANDM1TO1());\n\n            var newAngle = (this.angle + this.angleRandom * this.RANDM1TO1()) * (Math.PI / 180); // convert to radians\n            var vector = this.vectorHelpers.create(Math.sin(newAngle), -Math.cos(newAngle)); // Could move to lookup for speed\n            var vectorSpeed = this.speed + this.speedRandom * this.RANDM1TO1();\n            particle.direction = this.vectorHelpers.multiply(vector, vectorSpeed);\n\n            particle.size = Crafty.viewport._scale * (this.size + this.sizeRandom * this.RANDM1TO1());\n            particle.size = particle.size < 0 ? 0 : ~~particle.size;\n            particle.timeToLive = this.lifeSpan + this.lifeSpanRandom * this.RANDM1TO1();\n\n            particle.sharpness = this.sharpness + this.sharpnessRandom * this.RANDM1TO1();\n            particle.sharpness = particle.sharpness > 100 ? 100 : particle.sharpness < 0 ? 0 : particle.sharpness;\n            // internal circle gradient size - affects the sharpness of the radial gradient\n            particle.sizeSmall = ~~ ((particle.size / 200) * particle.sharpness); //(size/2/100)\n            var start = [\n                this.startColour[0] + this.startColourRandom[0] * this.RANDM1TO1(),\n                this.startColour[1] + this.startColourRandom[1] * this.RANDM1TO1(),\n                this.startColour[2] + this.startColourRandom[2] * this.RANDM1TO1(),\n                this.startColour[3] + this.startColourRandom[3] * this.RANDM1TO1()\n            ];\n\n            var end = [\n                this.endColour[0] + this.endColourRandom[0] * this.RANDM1TO1(),\n                this.endColour[1] + this.endColourRandom[1] * this.RANDM1TO1(),\n                this.endColour[2] + this.endColourRandom[2] * this.RANDM1TO1(),\n                this.endColour[3] + this.endColourRandom[3] * this.RANDM1TO1()\n            ];\n\n            particle.colour = start;\n            particle.deltaColour[0] = (end[0] - start[0]) / particle.timeToLive;\n            particle.deltaColour[1] = (end[1] - start[1]) / particle.timeToLive;\n            particle.deltaColour[2] = (end[2] - start[2]) / particle.timeToLive;\n            particle.deltaColour[3] = (end[3] - start[3]) / particle.timeToLive;\n        },\n        update: function () {\n            if (this.active && this.emissionRate > 0) {\n                var rate = 1 / this.emissionRate;\n                this.emitCounter++;\n                while (this.particleCount < this.maxParticles && this.emitCounter > rate) {\n                    this.addParticle();\n                    this.emitCounter -= rate;\n                }\n                this.elapsedFrames++;\n                if (this.duration !== -1 && this.duration < this.elapsedFrames) {\n                    this.stop();\n                }\n            }\n\n            this.particleIndex = 0;\n            this.register = [];\n            var draw;\n            while (this.particleIndex < this.particleCount) {\n\n                var currentParticle = this.particles[this.particleIndex];\n\n                // If the current particle is alive then update it\n                if (currentParticle.timeToLive > 0) {\n\n                    // Calculate the new direction based on gravity\n                    currentParticle.direction = this.vectorHelpers.add(currentParticle.direction, this.gravity);\n                    currentParticle.position = this.vectorHelpers.add(currentParticle.position, currentParticle.direction);\n                    currentParticle.position = this.vectorHelpers.add(currentParticle.position, this.viewportDelta);\n                    if (this.jitter) {\n                        currentParticle.position.x += this.jitter * this.RANDM1TO1();\n                        currentParticle.position.y += this.jitter * this.RANDM1TO1();\n                    }\n                    currentParticle.timeToLive--;\n\n                    // Update colours\n                    var r = currentParticle.colour[0] += currentParticle.deltaColour[0];\n                    var g = currentParticle.colour[1] += currentParticle.deltaColour[1];\n                    var b = currentParticle.colour[2] += currentParticle.deltaColour[2];\n                    var a = currentParticle.colour[3] += currentParticle.deltaColour[3];\n\n                    // Calculate the rgba string to draw.\n                    draw = [];\n                    draw.push(\"rgba(\" + (r > 255 ? 255 : r < 0 ? 0 : ~~r));\n                    draw.push(g > 255 ? 255 : g < 0 ? 0 : ~~g);\n                    draw.push(b > 255 ? 255 : b < 0 ? 0 : ~~b);\n                    draw.push((a > 1 ? 1 : a < 0 ? 0 : a.toFixed(2)) + \")\");\n                    currentParticle.drawColour = draw.join(\",\");\n\n                    if (!this.fastMode) {\n                        draw[3] = \"0)\";\n                        currentParticle.drawColourEnd = draw.join(\",\");\n                    }\n\n                    this.particleIndex++;\n                } else {\n                    // Replace particle with the last active\n                    if (this.particleIndex !== this.particleCount - 1) {\n                        this.particles[this.particleIndex] = this.particles[this.particleCount - 1];\n                    }\n                    this.particleCount--;\n                }\n                var rect = {};\n                rect._x = ~~currentParticle.position.x;\n                rect._y = ~~currentParticle.position.y;\n                rect._w = currentParticle.size;\n                rect._h = currentParticle.size;\n\n                this.register.push(rect);\n            }\n        },\n\n        stop: function () {\n            this.active = false;\n            this.elapsedFrames = 0;\n            this.emitCounter = 0;\n            this.parentEntity.trigger(\"ParticleEnd\");\n        },\n\n        render: function (context) {\n\n            for (var i = 0, j = this.particleCount; i < j; i++) {\n                var particle = this.particles[i];\n                var size = particle.size;\n                var halfSize = size >> 1;\n\n                if (particle.position.x + size < 0 || particle.position.y + size < 0 || particle.position.x - size > Crafty.viewport.width || particle.position.y - size > Crafty.viewport.height) {\n                    //Particle is outside\n                    continue;\n                }\n                var x = ~~particle.position.x;\n                var y = ~~particle.position.y;\n\n                if (this.fastMode) {\n                    context.fillStyle = particle.drawColour;\n                } else {\n                    var radgrad = context.createRadialGradient(x + halfSize, y + halfSize, particle.sizeSmall, x + halfSize, y + halfSize, halfSize);\n                    radgrad.addColorStop(0, particle.drawColour);\n                    //0.9 to avoid visible boxing\n                    radgrad.addColorStop(0.9, particle.drawColourEnd);\n                    context.fillStyle = radgrad;\n                }\n                context.fillRect(x, y, size, size);\n            }\n        },\n        particle: function (vectorHelpers) {\n            this.position = vectorHelpers.create(0, 0);\n            this.direction = vectorHelpers.create(0, 0);\n            this.size = 0;\n            this.sizeSmall = 0;\n            this.timeToLive = 0;\n            this.colour = [];\n            this.drawColour = \"\";\n            this.deltaColour = [];\n            this.sharpness = 0;\n        },\n        vectorHelpers: {\n            create: function (x, y) {\n                return {\n                    \"x\": x,\n                    \"y\": y\n                };\n            },\n            multiply: function (vector, scaleFactor) {\n                vector.x *= scaleFactor;\n                vector.y *= scaleFactor;\n                return vector;\n            },\n            add: function (vector1, vector2) {\n                vector1.x += vector2.x;\n                vector1.y += vector2.y;\n                return vector1;\n            }\n        }\n    },\n    /**@\n     * #.pauseParticles\n     * @comp Particles\n     * @kind Method\n     * \n     * @sign public this.pauseParticles()\n     *\n     * The pauseParticles will freeze these particles in execution.\n     *\n     * @example\n     * ~~~\n     * // start particle animation\n     * var ent = Crafty.e(\"Particles\").particles(someParticleConfig);\n     *\n     * // and some time later, the gameplay is paused (or only\n     * // a part of it is frozen)\n     * ent.pauseParticles();\n     * ~~~\n     */\n    pauseParticles: function() {\n        this._particlesPaused = true;\n    },\n    /**@\n     * #.resumeParticles\n     * @comp Particles\n     * @kind Method\n     * \n     * @sign public this.resumeParticles()\n     *\n     * The resumeParticles will resume earlier paused particles\n     *\n     * @example\n     * ~~~\n     * // start particle animation\n     * var ent = Crafty.e(\"Particles\").particles(someParticleConfig);\n     *\n     * // and some time later, the gameplay is paused (or only\n     * // a part of it is frozen)\n     * ent.pauseParticles();\n     *\n     * // and we resume the particles again\n     * ent.resumeParticles();\n     * ~~~\n     */\n    resumeParticles: function() {\n        this._particlesPaused = false;\n    }\n});\n"},"hash":"d1d9fe3a442293d7d96cf1e6e155a85f"}