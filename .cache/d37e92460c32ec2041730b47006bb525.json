{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js');\n\n\n/**@\n * #Crafty.rectManager\n * @category 2D\n * @kind CoreObj\n *\n * Collection of methods for handling rectangles\n */\nCrafty.extend({\n    /** recManager: an object for managing dirty rectangles. */\n   rectManager: {\n       /** Finds smallest rectangles that overlaps a and b, merges them into target */\n       merge: function (a, b, target) {\n           if (typeof target === 'undefined')\n               target = {};\n           // Doing it in this order means we can use either a or b as the target, with no conflict\n           target._h = Math.max(a._y + a._h, b._y + b._h);\n           target._w = Math.max(a._x + a._w, b._x + b._w);\n           target._x = Math.min(a._x, b._x);\n           target._y = Math.min(a._y, b._y);\n           target._w -= target._x;\n           target._h -= target._y;\n\n           return target;\n       },\n\n      /**@\n       * #Crafty.rectManager.overlap\n       * @comp Crafty.rectManager\n       * @kind Method\n       * \n       * @sign public Boolean Crafty.rectManager.overlap(Object rectA, Object rectA)\n       * @param rectA - An object that must have the `_x, _y, _w, _h` values as properties\n       * @param rectB - An object that must have the `_x, _y, _w, _h` values as properties\n       * @return true if the rectangles overlap; false otherwise\n       *\n       * Checks whether two rectangles overlap.\n       */\n      overlap: function (rectA, rectB) {\n        return (rectA._x < rectB._x + rectB._w && rectA._x + rectA._w > rectB._x &&\n                rectA._y < rectB._y + rectB._h && rectA._y + rectA._h > rectB._y);\n      },\n      \n      /**@\n       * #Crafty.rectManager.integerBounds\n       * @comp Crafty.rectManager\n       * @kind Method\n       * \n       * @sign public Boolean Crafty.rectManager.integerBounds(Object rect)\n       * @param rect - An object that must have the `_x, _y, _w, _h` values as properties\n       * @return An enclosing rectangle with integer coordinates\n       *\n       * Calculate the smallest rectangle with integer coordinates that encloses the specified rectangle,\n       * modifying the passed object to have those bounds.\n       */\n      integerBounds: function(rect){\n        rect._w = rect._x + rect._w;\n        rect._h = rect._y + rect._h;\n        rect._x = (rect._x > 0) ? (rect._x|0) : (rect._x|0) - 1;\n        rect._y = (rect._y > 0) ? (rect._y|0) : (rect._y|0) - 1;\n        rect._w -= rect._x;\n        rect._h -= rect._y;\n        rect._w = (rect._w === (rect._w|0)) ? rect._w : (rect._w|0) + 1;\n        rect._h = (rect._h === (rect._h|0)) ? rect._h : (rect._h|0) + 1;\n        return rect;\n      },\n\n      /**@\n      * #Crafty.rectManager.mergeSet\n      * @comp Crafty.rectManager\n      * @kind Method\n      *\n      * @sign public Object Crafty.rectManager.mergeSet(Object set)\n      * @param set - an array of rectangular regions\n      *\n      * Merge any consecutive, overlapping rects into each other.\n      * Its an optimization for the redraw regions.\n      *\n      * The order of set isn't strictly meaningful,\n      * but overlapping objects will often cause each other to change,\n      * and so might be consecutive.\n      */\n      mergeSet: function (set) {\n          var i = 0;\n          while (i < set.length - 1) {\n              // If current and next overlap, merge them together into the first, removing the second\n              // Then skip the index backwards to compare the previous pair.\n              // Otherwise skip forward\n              if (this.overlap(set[i], set[i + 1])) {\n                  this.merge(set[i], set[i + 1], set[i]);\n                  set.splice(i + 1, 1);\n                  if (i > 0) {\n                    i--;\n                  }\n              } else {\n                  i++;\n              }\n          }\n\n          return set;\n      },\n\n      /**@\n       * #Crafty.rectManager.boundingRect\n       * @comp Crafty.rectManager\n       * @kind Method\n       * \n       * @sign public Crafty.rectManager.boundingRect(set)\n       * @param set - An array of rectangles\n       *\n       * - Calculate the common bounding rect of multiple canvas entities.\n       * - Returns coords\n       */\n      boundingRect: function (set) {\n          if (!set || !set.length) return;\n          var i = 1,\n              l = set.length,\n              current, master = set[0],\n              tmp;\n          master = [master._x, master._y, master._x + master._w, master._y + master._h];\n          while (i < l) {\n              current = set[i];\n              tmp = [current._x, current._y, current._x + current._w, current._y + current._h];\n              if (tmp[0] < master[0]) master[0] = tmp[0];\n              if (tmp[1] < master[1]) master[1] = tmp[1];\n              if (tmp[2] > master[2]) master[2] = tmp[2];\n              if (tmp[3] > master[3]) master[3] = tmp[3];\n              i++;\n          }\n          tmp = master;\n          master = {\n              _x: tmp[0],\n              _y: tmp[1],\n              _w: tmp[2] - tmp[0],\n              _h: tmp[3] - tmp[1]\n          };\n\n          return master;\n      },\n\n      // Crafty.rectManager._rectPool\n      //\n      // This is a private object used internally by 2D methods\n      // Cascade and _attr need to keep track of an entity's old position,\n      // but we want to avoid creating temp objects every time an attribute is set.\n      // The solution is to have a pool of objects that can be reused.\n      //\n      // The current implementation makes a BIG ASSUMPTION:  that if multiple rectangles are requested,\n      // the later one is recycled before any preceding ones.  This matches how they are used in the code.\n      // Each rect is created by a triggered event, and will be recycled by the time the event is complete.\n      _pool: (function () {\n          var pool = [],\n              pointer = 0;\n          return {\n              get: function (x, y, w, h) {\n                  if (pool.length <= pointer)\n                      pool.push({});\n                  var r = pool[pointer++];\n                  r._x = x;\n                  r._y = y;\n                  r._w = w;\n                  r._h = h;\n                  return r;\n              },\n\n              copy: function (o) {\n                  if (pool.length <= pointer)\n                      pool.push({});\n                  var r = pool[pointer++];\n                  r._x = o._x;\n                  r._y = o._y;\n                  r._w = o._w;\n                  r._h = o._h;\n                  return r;\n              },\n\n              recycle: function (o) {\n                  pointer--;\n              }\n          };\n      })(),\n\n   }\n\n\n});\n"},"hash":"1ab2f0d3ca1d50b4b5d05f199f864942"}