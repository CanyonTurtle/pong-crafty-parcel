{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js');\n\n\n// ToggleInput contract\n// Must provide an isDown method which returns whether the input is down or not\n// May provide a destroy method which can be used for cleanup\n\n\n\n\n// MouseButtonToggleInput\nfunction MouseButtonToggleInput(button) {\n    Crafty.mouseObjs++;\n    this.button = button;\n}\n\nMouseButtonToggleInput.prototype = {\n    isDown: function() {\n        return Crafty.mouseButtonsDown[this.button];\n    },\n    destroy: function() {\n        Crafty.mouseObjs--;\n    }\n};\n\n// KeyboardToggleInput\nfunction KeyboardToggleInput(key) {\n    this.key = key;\n}\n\nKeyboardToggleInput.prototype = {\n    isDown: function() {\n        return Crafty.keydown[this.key];\n    }\n};\n\n\n// ToggleInputGroup\nfunction ToggleInputGroup(inputs) {\n    this.inputs = inputs;\n}\n\n// Handles a group of inputs that represent the same toggle state\nToggleInputGroup.prototype = {\n    timeDown: null,\n    isActive: function () {\n        for (var i in this.inputs) {\n            var input = this.inputs[i];\n            if (input.isDown()) {\n                if (!this.timeDown) {\n                    this.timeDown = Date.now();\n                }\n                return true;\n            }\n        }\n        delete this.timeDown;\n        return false;\n    },\n    destroy: function() {\n        for (var i in this.inputs) {\n            if (typeof this.inputs[i].destroy === 'function') {\n                this.inputs[i].destroy();\n            }\n        }\n    }\n};\n\n// Provides abstractions for specific types of inputs:\n// - DirectionalInput: {x, y}\n// - TriggerInputDown/TriggerInputUp\n\n/**@\n * #Controls\n * @category Controls\n * @kind System\n * \n * A built-in system for linking specific inputs to general types of input events.\n * \n * @note The methods provided by this system are likely to change in future verisons of Crafty, as more input types are supported.\n * \n * @trigger TriggerInputDown - When a trigger group is activated - {name}\n * @trigger TriggerInputUp - When a trigger group is released - {name, downFor}\n * @trigger DirectionalInput - When a directional input changes - {name, x, y}\n * \n * \n */\nCrafty.s(\"Controls\", {\n    init: function () {\n        // internal object to store definitions\n        this._dpads = {};\n        this._triggers = {};\n    },\n\n    events: {\n        \"EnterFrameInput\": function () {\n            this.runEvents();\n        },\n        \"KeyDown\": function () {\n            this.updateTriggers();\n        },\n        \"KeyUp\": function () {\n            this.updateTriggers();\n        },\n        \"MouseDown\": function (e) {\n            this.updateTriggers();\n        },\n        \"MouseUp\": function (e) {\n            this.updateTriggers();\n        },\n    },\n\n    // Runs through all triggers and updates their status\n    updateTriggers: function(e) {\n        for (var t in this._triggers) {\n            var trigger = this._triggers[t];\n            this.updateTriggerInput(trigger);\n        }\n    },\n\n    runEvents: function () { \n        // Trigger DirectionalInput events for dpads\n        for (var d in this._dpads) {\n            var dpad = this._dpads[d];\n            dpad.oldX = dpad.x;\n            dpad.oldY = dpad.y;\n            this.updateDpadInput(dpad, dpad.multipleDirectionBehavior);\n            this.updateActiveDirection(dpad, dpad.normalize);\n            dpad.event.x = dpad.x;\n            dpad.event.y = dpad.y;\n            if (dpad.x !== dpad.oldX || dpad.y !== dpad.oldY) {\n                Crafty.trigger(\"DirectionalInput\", dpad.event);\n            }\n        }\n    },\n\n    getDpad: function (name) {\n        return this._dpads[name];\n    },\n\n    isTriggerDown: function(name) {\n        return this._triggers[name].active;\n    },\n\n    /**@\n     * #.defineTriggerGroup\n     * @comp Controls\n     * @kind Method\n     * \n     * @sign defineTriggerGroup(string name, obj definition)\n     * @param name - a name for the trigger group\n     * @param definition - an object which defines the inputs for the trigger\n     * \n     * A trigger group is a set of togglable inputs mapped to the same event.  \n     * If any of the inputs are down, the trigger is considered down.  If all are up, it is considered up.  \n     * When the trigger state changes, a `TriggerInputUp` or `TriggerInputDown` event is fired.\n     * \n     * The definition object lists the inputs that are mapped to the trigger:\n     * - `keys`: An array of Crafty keycodes\n     * - `mouseButtons`: An array of Crafty mouse button codes\n     * \n     * @example\n     * ~~~\n     * // Define a trigger group mapped to the left mouse button and the A and B keys.\n     * Crafty.s(\"Controls\").defineTriggerGroup(\"MyTrigger\", {\n     *   mouseButtons: [Crafty.mouseButtons.LEFT],\n     *   keys: [Crafty.keys.A, Crafty.keys.B]\n     * });\n     * ~~~\n     * \n     * @see Crafty.mouseButtons\n     * @see Crafty.keys\n     * @see Controllable\n     */\n    defineTriggerGroup: function(name, definition) {\n        var inputs;\n        if (Array.isArray(definition)) {\n            inputs = definition;\n        } else {\n            inputs = [];\n            if (definition.mouseButtons) {\n                for (var b in definition.mouseButtons){\n                    inputs.push(new MouseButtonToggleInput(definition.mouseButtons[b]));\n                }\n            }\n            if (definition.keys) {\n                for (var k in definition.keys) {\n                    inputs.push(new KeyboardToggleInput(definition.keys[k]));\n                }\n            }\n        }\n        if (this._triggers[name]) {\n            this._triggers[name].input.destroy();\n        }\n        this._triggers[name] = {\n            name: name,\n            input: new ToggleInputGroup(inputs),\n            downFor: 0,\n            active: false\n        };\n    },\n\n    /**@\n     * #.defineDpad\n     * @comp Controls\n     * @kind Method\n     * \n     * @sign defineDpad(string name, obj definition[, obj options])\n     * @param name - a name for the dpad input\n     * @param definition - an object which defines the inputs and directions for the dpad\n     * @param options - a set of options for the dpad\n     * \n     * A dpad is a type of directional control which maps a set of triggers to a set of directions.\n     * \n     * The options object has two properties:\n     * - `normalize` *(bool)*: If true, the directional input will be normalized to a unit vector.  Defaults to false.\n     * - `multipleDirectionBehavior` *(string)*: How to behave when multiple directions are active at the same time.  Values are \"first\", \"last\", and \"all\".  Defaults to \"all\".\n     * \n     * @example\n     * ~~~\n     * // Define a two-direction dpad, with two keys each bound to the right and left directions\n     * Crafty.s(\"Controls\").defineDpad(\"MyDpad\", {\n     *   {RIGHT_ARROW: 0, LEFT_ARROW: 180, D: 0, A: 180}\n     * });\n     * ~~~\n     * \n     * @see Crafty.keys\n     * @see Controllable\n     * @see Multiway\n     */\n    defineDpad: function (name, definition, options) {\n        var directionDict = {};\n        for (var k in definition) {\n            var direction = definition[k];\n            var keyCode = Crafty.keys[k] || k;\n\n            // create a mapping of directions to all associated keycodes\n            if (!directionDict[direction]) {\n                directionDict[direction] = [];\n            }\n            directionDict[direction].push(new KeyboardToggleInput(keyCode));\n        }\n\n        // Create a useful definition from the input format that tracks state\n        var parsedDefinition = {};\n        for (var d in directionDict) {\n            parsedDefinition[d] = {\n                input: new ToggleInputGroup(directionDict[d]),\n                active: false,\n                n: this.parseDirection(d)\n            };\n        }\n        if (typeof options === 'undefined') {\n            options = {};\n        }\n        if (typeof options.normalize === 'undefined') {\n            options.normalize = false;\n        }\n        if (typeof options.multipleDirectionBehavior === 'undefined') {\n            options.multipleDirectionBehavior = \"all\";\n        }\n        // Create the fully realized dpad object\n          // Store the name/definition pair\n        if (this._dpads[name]) {\n            for (d in this._dpads[name].parsedDefinition) {\n                this._dpads[name].parsedDefinition[d].input.destroy();\n            }\n            delete this._dpads[name];\n        }\n        this._dpads[name] = {\n            name: name,\n            directions: parsedDefinition,\n            x: 0,\n            y: 0,\n            oldX: 0,\n            oldY: 0,\n            event: { x: 0, y: 0, name: name },\n            normalize: options.normalize,\n            multipleDirectionBehavior: options.multipleDirectionBehavior\n        };\n    },\n\n    // Takes an amount in degrees and converts it to an x/y object.\n    // Clamps to avoid rounding issues with sin/cos\n    parseDirection: function (direction) {\n        return {\n            x: Math.round(Math.cos(direction * (Math.PI / 180)) * 1000) / 1000,\n            y: Math.round(Math.sin(direction * (Math.PI / 180)) * 1000) / 1000\n        };\n    },\n\n    // dpad definition is a map of directions to keys array and active flag\n    updateActiveDirection: function (dpad, normalize) {\n        dpad.x = 0;\n        dpad.y = 0;\n        for (var d in dpad.directions) {\n            var dir = dpad.directions[d];\n            if (!dir.active) continue;\n            dpad.x += dir.n.x;\n            dpad.y += dir.n.y;\n        }\n\n        // Normalize\n        if (normalize) {\n            var m = Math.sqrt(dpad.x * dpad.x + dpad.y * dpad.y);\n            if (m > 0) {\n                dpad.x = dpad.x / m;\n                dpad.y = dpad.y / m;\n            }\n        }\n    },\n\n    updateTriggerInput: function (trigger) {\n        if (!trigger.active) {\n            if (trigger.input.isActive()) {\n                trigger.downFor = Date.now() - trigger.input.timeDown;\n                trigger.active = true;\n                Crafty.trigger(\"TriggerInputDown\", trigger);\n            }\n        } else {\n            if (!trigger.input.isActive()) {\n                trigger.active = false;\n                Crafty.trigger(\"TriggerInputUp\", trigger);\n                trigger.downFor = 0;\n            }\n        }\n    },\n\n    // Has to handle three cases concerning multiple active input groups:\n    // - \"all\": all directions are active\n    // - \"last\": one direction at a time, new directions replace old ones\n    // - \"first\": one direction at a time, new directions are ignored while old ones are still active \n    updateDpadInput: function (dpad, multiBehavior) {\n        var d, dir;\n        var winner;\n\n        for (d in dpad.directions) {\n            dir = dpad.directions[d];\n            dir.active = false;\n\n            if (dir.input.isActive()) {\n                if (multiBehavior === \"all\") {\n                    dir.active = true;\n                } else {\n                    if (!winner) {\n                        winner = dir;\n                    } else {\n                        if (multiBehavior === \"first\") {\n                            if (winner.input.timeDown > dir.input.timeDown) {\n                                winner = dir;\n                            }\n                        }\n                        if (multiBehavior === \"last\") {\n                            if (winner.input.timeDown < dir.input.timeDown) {\n                                winner = dir;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // If we picked a winner, set it active\n        if (winner) winner.active = true;\n    }\n});"},"hash":"8016865b879357ccac307fbec5d4b29c"}