{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js');\n\nCrafty.extend({\n    _drawLayerTemplates: {},\n    _drawLayers: [],\n    _addDrawLayerInstance: function (layer) {\n        Crafty._drawLayers.push(layer);\n        this._drawLayers.sort(function (a, b) { return a.options.z - b.options.z; });\n    },\n\n    _removeDrawLayerInstance: function (layer) {\n        var i = this._drawLayers.indexOf(layer);\n        if (i >= 0) {\n            this._drawLayers.splice(i, 1);\n        }\n        this._drawLayers.sort(function (a, b) { return a.options.z - b.options.z; });\n    },\n\n    _registerLayerTemplate: function (type, layerTemplate) {\n        this._drawLayerTemplates[type] = layerTemplate;\n        var common = this._commonLayerProperties;\n        for (var key in common) {\n            if (layerTemplate[key]) continue;\n            layerTemplate[key] = common[key];\n        }\n        // A marker to avoid creating temporary objects\n        layerTemplate._viewportRectHolder = {};\n    },\n\n    _commonLayerProperties: {\n        // Based on the camera options, find the Crafty coordinates corresponding to the layer's position in the viewport\n        _viewportRect: function () {\n            var options = this.options;\n            var rect = this._viewportRectHolder;\n            var scale = Math.pow(Crafty.viewport._scale, options.scaleResponse);\n            var viewport = Crafty.viewport;\n            rect._scale = scale;\n            rect._w = viewport._width / scale;\n            rect._h = viewport._height / scale;\n\n            \n            // This particular transformation is designed such that,\n            // if a combination pan/scale keeps the center of the screen fixed for a layer with x/y response of 1,\n            // then it will also be fixed for layers with other values for x/y response\n            // (note that the second term vanishes when either the response or scale are 1)\n            rect._x = options.xResponse * (-viewport._x) - \n                0.5 * (options.xResponse - 1) * (1 - 1 / scale) * viewport._width;  \n            rect._y = options.yResponse * (-viewport._y) - \n                0.5 * (options.yResponse - 1) * (1 - 1 / scale) * viewport._height; \n            return rect;\n        },\n        // A tracker for whether any elements in this layer need to listen to mouse/touch events\n        _pointerEntities: 0\n    },\n\n    /**@\n     * #Crafty.createLayer\n     * @kind Method\n     * @category Graphics\n     *\n     * @sign public void Crafty.createLayer(string name, string type[, object options])\n     * @param name - the name that will refer to the layer\n     * @param type - the type of the draw layer to create ('DOM', 'Canvas', or 'WebGL')\n     * @param options - this will override the default values of each layer\n     *\n     * Creates a new system which implements the specified type of layer.  The options (and their default values) are\n     *\n     * ```\n     * {\n     *   xResponse: 1,  // How the layer will pan in response to the viewport x position\n     *   yResponse: 1,  // How the layer will pan in response to the viewport y position\n     *   scaleResponse: 1, // How the layer will scale in response to the viewport scale.  (Layer scale will be scale^scaleResponse.)\n     *   z: 0 // The zIndex of the layer relative to other layers\n     * }\n     * ```\n     *\n     * Crafty will automatically define three built-in layers: \"DefaultDOMLayer\", DefaultCanvasLayer\",  and \"DefaultWebGLLayer\".\n     * They will have `z` values of `30`, `20`, and `10` respectively, and will be initialized if a \"DOM\", \"Canvas\" or \"WebGL\" component\n     * is used with an entity not attached to any user-specified layer.\n     * \n     * @note Layers are implemented as systems, so the layer name must be distinct from other systems.\n     * \n     * @note By default, layers will persist across scene changes.  You can manually clean up a layer by removing all it's entities and then destroying it.\n     *\n     * @example\n     * ```\n     * Crafty.createLayer(\"MyCanvasLayer\", \"Canvas\")\n     * Crafty.e(\"2D, MyCanvasLayer, Color\");\n     * ```\n     * Define a custom canvas layer, then create an entity that uses the custom layer to render.\n     *\n     * @example\n     * ```\n     * Crafty.createLayer(\"UILayer\", \"DOM\", {scaleResponse: 0, xResponse: 0, yResponse: 0})\n     * Crafty.e(\"2D, UILayer, Text\");\n     * ```\n     * Define a custom DOM layer that will not move with the camera.  (Useful for static UI elements!)\n     *\n     * @example\n     * ```\n     * Crafty.createLayer(\"MyCanvasLayer\", \"Canvas\");\n     * Crafty.s(\"MyCanvasLayer\").one(\"RenderScene\", function(){ this.everRendered = true; }); \n     * ```\n     * Create a custom layer, and then bind a method to run the first time it renders.\n     * * @example\n     * ```\n     * Crafty(\"MyCanvasLayer\").destroy();\n     * Crafty.s(\"MyCanvasLayer\").destroy(); \n     * ```\n     * For a previously defined \"MyCanvasLayer\", destroy it and all the entities rendered by it.\n     */\n    createLayer: function createLayer(name, type, options) {\n        var layerTemplate = this._drawLayerTemplates[type];\n        Crafty.s(name, layerTemplate, options);\n        Crafty.c(name, {\n            init: function () {\n                this.requires(\"Renderable\"); \n                \n                // Flag to indicate that the base component doesn't need to attach a layer\n                this._customLayer = true;\n                this.requires(layerTemplate.type);\n                this._attachToLayer(Crafty.s(name));\n            },\n\n            remove: function () {\n                this._detachFromLayer();\n            }\n        });\n    }\n});"},"hash":"bde4232aa4858345c0ef99f52de6a24e"}