{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js'),\n    document = window.document;\n\n// Object for abstracting out all the gl calls to handle rendering entities with a particular program\nfunction RenderProgramWrapper(layer, shader){\n    this.shader = shader;\n    this.layer = layer;\n    this.context = layer.context;\n    this.draw = function() { };\n\n    this.array_size = 16;\n    this.max_size = 1024;\n    this._indexArray = new Uint16Array(6 * this.array_size);\n    this._indexBuffer = layer.context.createBuffer();\n}\n\nRenderProgramWrapper.prototype = {\n    // Takes an array of attributes; see WebGLLayer's getProgramWrapper method\n    initAttributes: function(attributes) {\n        this.attributes = attributes;\n        this._attribute_table = {};\n        var offset = 0;\n        for (var i = 0; i < attributes.length; i++) {\n            var a = attributes[i];\n            this._attribute_table[a.name] = a;\n\n            a.bytes = a.bytes || Float32Array.BYTES_PER_ELEMENT;\n            a.type = a.type || this.context.FLOAT;\n            a.offset = offset;\n            a.location = this.context.getAttribLocation(this.shader, a.name);\n\n            this.context.enableVertexAttribArray(a.location);\n\n            offset += a.width;\n        }\n\n        // Stride is the full width including the last set\n        this.stride = offset;\n\n        // Create attribute array of correct size to hold max elements\n        this._attributeArray = new Float32Array(this.array_size * 4 * this.stride);\n        this._attributeBuffer = this.context.createBuffer();\n        this._registryHoles = [];\n        this._registrySize = 0;\n    },\n\n    // increase the size of the typed arrays\n    // does so by creating a new array of that size and copying the existing one into it\n    growArrays: function(size) {\n        if (this.array_size >= this.max_size) return;\n\n        var newsize = Math.min(size, this.max_size);\n\n        var newAttributeArray = new Float32Array(newsize * 4 * this.stride);\n        var newIndexArray = new Uint16Array(6 * newsize);\n\n        newAttributeArray.set(this._attributeArray);\n        newIndexArray.set(this._indexArray);\n\n        this._attributeArray = newAttributeArray;\n        this._indexArray = newIndexArray;\n        this.array_size = newsize;\n    },\n\n    // Add an entity that needs to be rendered by this program\n    // Needs to be assigned an index in the buffer\n    registerEntity: function(e) {\n        if (this._registryHoles.length === 0) {\n            if (this._registrySize >= this.max_size) {\n                throw (\"Number of entities exceeds maximum limit.\");\n            } else if (this._registrySize >= this.array_size) {\n                this.growArrays(2 * this.array_size);\n            }\n            e._glBufferIndex = this._registrySize;\n            this._registrySize++;\n        } else {\n            e._glBufferIndex = this._registryHoles.pop();\n        }\n    },\n\n    // remove an entity; allow its buffer index to be reused\n    unregisterEntity: function(e) {\n        if (typeof e._glBufferIndex === \"number\")\n            this._registryHoles.push(e._glBufferIndex);\n        e._glBufferIndex = null;\n    },\n\n    resetRegistry: function() {\n        this._maxElement = 0;\n        this._registryHoles.length = 0;\n    },\n\n    setCurrentEntity: function(ent) {\n        // offset is 4 * buffer index, because each entity has 4 vertices\n        this.ent_offset = ent._glBufferIndex * 4;\n        this.ent = ent;\n    },\n\n    // Called before a batch of entities is prepped for rendering\n    switchTo: function() {\n        var gl = this.context;\n        gl.useProgram(this.shader);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._attributeBuffer);\n        var a, attributes = this.attributes;\n        // Process every attribute\n        for (var i = 0; i < attributes.length; i++) {\n            a = attributes[i];\n            gl.vertexAttribPointer(a.location, a.width, a.type, false, this.stride * a.bytes, a.offset * a.bytes);\n        }\n\n        // For now, special case the need for texture objects\n        var t = this.texture_obj;\n        if (t && t.unit === null) {\n            this.layer.texture_manager.bindTexture(t);\n        }\n\n        this.index_pointer = 0;\n    },\n\n    // Sets a texture\n    setTexture: function(texture_obj) {\n        // Only needs to be done once\n        if (this.texture_obj !== undefined)\n            return;\n        // Set the texture buffer to use\n        texture_obj.setToProgram(this.shader, \"uSampler\", \"uTextureDimensions\");\n        this.texture_obj = texture_obj;\n    },\n\n    // adds a set of 6 indices to the index array\n    // Corresponds to 2 triangles that make up a rectangle\n    addIndices: function(offset) {\n        var index = this._indexArray, l = this.index_pointer;\n        index[0 + l] = 0 + offset;\n        index[1 + l] = 1 + offset;\n        index[2 + l] = 2 + offset;\n        index[3 + l] = 1 + offset;\n        index[4 + l] = 2 + offset;\n        index[5 + l] = 3 + offset;\n        this.index_pointer += 6;\n    },\n\n\n    // Writes data from the attribute and index arrays to the appropriate buffers, and then calls drawElements.\n    renderBatch: function() {\n        var gl = this.context;\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._attributeBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this._attributeArray, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indexArray, gl.STATIC_DRAW);\n        gl.drawElements(gl.TRIANGLES, this.index_pointer, gl.UNSIGNED_SHORT, 0);\n    },\n\n    setViewportUniforms: function(viewport, cameraOptions) {\n        var gl = this.context;\n        gl.useProgram(this.shader);\n        gl.uniform4f(this.shader.viewport, -viewport._x, -viewport._y, viewport._w , viewport._h );\n    },\n\n    // Fill in the attribute with the given arguments, cycling through the data if necessary\n    // If the arguments provided match the width of the attribute, that means it'll fill the same values for each of the four vertices.\n    // TODO determine if this abstraction is a performance hit!\n    writeVector: function(name, x, y) {\n        var a = this._attribute_table[name];\n        var stride = this.stride, offset = a.offset + this.ent_offset * stride, w = a.width;\n        var l = (arguments.length - 1);\n        var data = this._attributeArray;\n\n        for (var r = 0; r < 4; r++)\n            for (var c = 0; c < w; c++) {\n                data[offset + stride * r + c] = arguments[(w * r + c) % l + 1];\n            }\n    }\n};\n\n/**@\n * #WebGLLayer\n * @category Graphics\n * @kind System\n *\n * A collection of methods to handle webgl contexts.\n */\nCrafty._registerLayerTemplate(\"WebGL\", {\n    type: \"WebGL\",\n    // Layer options\n    options: {\n        xResponse: 1,\n        yResponse: 1,\n        scaleResponse: 1,\n        z: 0\n    },\n    /**@\n     * #.context\n     * @comp WebGLLayer\n     * @kind Property\n     *\n     * This will return the context of the webgl canvas element.\n     */\n    context: null,\n    changed_objects: [],\n\n    // Create a vertex or fragment shader, given the source and type\n    _compileShader: function(src, type) {\n        var gl = this.context;\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            throw (gl.getShaderInfoLog(shader));\n        }\n        return shader;\n    },\n\n    // Create and return a complete, linked shader program, given the source for the fragment and vertex shaders.\n    // Will compile the two shaders and then link them together\n    _makeProgram: function(shader) {\n        var gl = this.context;\n        var fragmentShader = this._compileShader(shader.fragmentCode, gl.FRAGMENT_SHADER);\n        var vertexShader = this._compileShader(shader.vertexCode, gl.VERTEX_SHADER);\n\n        var shaderProgram = gl.createProgram();\n        gl.attachShader(shaderProgram, vertexShader);\n        gl.attachShader(shaderProgram, fragmentShader);\n        gl.linkProgram(shaderProgram);\n\n        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n            throw (\"Could not initialise shaders\");\n        }\n\n        shaderProgram.viewport = gl.getUniformLocation(shaderProgram, \"uViewport\");\n        return shaderProgram;\n    },\n\n    // Will create and return a RenderProgramWrapper for a shader program.\n    // name is a unique id, attributes an array of attribute names with their metadata.\n    // Each attribute needs at least a `name`  and `width` property:\n    // ~~~\n    //   [\n    //      {name:\"aPosition\", width: 2},\n    //      {name:\"aOrientation\", width: 3},\n    //      {name:\"aLayer\", width:2},\n    //      {name:\"aColor\",  width: 4}\n    //   ]\n    // ~~~\n    // The \"aPositon\", \"aOrientation\", and \"aLayer\" attributes should be the same for any webgl entity,\n    // since they support the basic 2D properties\n    getProgramWrapper: function(name, shader) {\n        if (this.programs[name] === undefined) {\n            var compiledShader = this._makeProgram(shader);\n            var program = new RenderProgramWrapper(this, compiledShader);\n            program.name = name;\n            program.initAttributes(shader.attributeList);\n            program.draw = shader.drawCallback;\n            program.setViewportUniforms(this._viewportRect(), this.options);\n            this.programs[name] = program;\n        }\n        return this.programs[name];\n    },\n\n    // Make a texture out of the given image element\n    // The url is just used as a unique ID\n    makeTexture: function(url, image, repeating) {\n        return this.texture_manager.makeTexture(url, image, repeating);\n    },\n\n    init: function() {\n\n        //check if we support webgl is supported\n        if (!Crafty.support.webgl) {\n            Crafty.trigger(\"NoWebGL\");\n            Crafty.stop();\n            return;\n        }\n\n        // Avoid shared state between systems\n        this.changed_objects = [];\n        this.programs = {};\n\n        //create an empty canvas element\n        var c;\n        c = document.createElement(\"canvas\");\n        c.width = Crafty.viewport.width;\n        c.height = Crafty.viewport.height;\n        c.style.position = 'absolute';\n        c.style.left = \"0px\";\n        c.style.top = \"0px\";\n        c.style.zIndex = this.options.z;\n\n        Crafty.stage.elem.appendChild(c);\n\n        // Try to get a webgl context\n        var gl;\n        try {\n            gl = c.getContext(\"webgl\", { premultipliedalpha: true }) || c.getContext(\"experimental-webgl\", { premultipliedalpha: true });\n            gl.viewportWidth = c.width;\n            gl.viewportHeight = c.height;\n        } catch (e) {\n            Crafty.trigger(\"NoWebGL\");\n            Crafty.stop();\n            return;\n        }\n\n        // assign to this renderer\n        this.context = gl;\n        this._canvas = c;\n\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n\n        // These commands allow partial transparency, but require drawing in z-order\n        gl.disable(gl.DEPTH_TEST);\n        // This particular blend function requires the shader programs to output pre-multiplied alpha\n        // This is necessary to match the blending of canvas/dom entities against the background color\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.enable(gl.BLEND);\n\n        //Bind rendering of canvas context (see drawing.js)\n        this.uniqueBind(\"RenderScene\", this.render);\n        this.uniqueBind(\"ViewportResize\", this._resize);\n        this.uniqueBind(\"InvalidateViewport\", function() { this.dirtyViewport = true; });\n        this.uniqueBind(\"PixelartSet\", this._setPixelart);\n        this._setPixelart(Crafty._pixelartEnabled);\n        this.dirtyViewport = true;\n\n        this.texture_manager = new Crafty.TextureManager(gl, this);\n        Crafty._addDrawLayerInstance(this);\n    },\n\n    // Cleanup the DOM when the system is destroyed\n    remove: function() {\n        this._canvas.parentNode.removeChild(this._canvas);\n        Crafty._removeDrawLayerInstance(this);\n    },\n\n    // Called when the viewport resizes\n    _resize: function() {\n        var c = this._canvas;\n        c.width = Crafty.viewport.width;\n        c.height = Crafty.viewport.height;\n\n        var gl = this.context;\n        gl.viewportWidth = c.width;\n        gl.viewportHeight = c.height;\n    },\n\n    // TODO consider shifting to texturemanager\n    _setPixelart: function(enabled) {\n        var gl = this.context;\n        if (enabled) {\n            this.texture_filter = gl.NEAREST;\n        } else {\n            this.texture_filter = gl.LINEAR;\n        }\n    },\n\n    // convenicne to sort array by global Z\n    zsort: function(a, b) {\n        return a._globalZ - b._globalZ;\n    },\n\n    // Hold an array ref to avoid garbage\n    visible_gl: [],\n\n    // Render any entities associated with this context; called in response to a draw event\n    render: function(rect) {\n        rect = rect || this._viewportRect();\n        var gl = this.context;\n\n        // Set viewport and clear it\n        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n        //Set the viewport uniform variables used by each registered program\n        var programs = this.programs;\n        if (this.dirtyViewport) {\n            var view = this._viewportRect();\n            for (var comp in programs) {\n                programs[comp].setViewportUniforms(view, this.options);\n            }\n            this.dirtyViewport = false;\n        }\n\n        // Search for any entities in the given area (viewport unless otherwise specified)\n        var q = Crafty.map.search(rect),\n            i = 0,\n            l = q.length,\n            current;\n        //From all potential candidates, build a list of visible entities, then sort by zorder\n        var visible_gl = this.visible_gl;\n        visible_gl.length = 0;\n        for (i = 0; i < l; i++) {\n            current = q[i];\n            if (current._visible && current.program && (current._drawLayer === this)) {\n                visible_gl.push(current);\n            }\n        }\n        visible_gl.sort(this.zsort);\n        l = visible_gl.length;\n\n\n        // Now iterate through the z-sorted entities to be rendered\n        // Each entity writes it's data into a typed array\n        // The entities are rendered in batches, where the entire array is copied to a buffer in one operation\n        // A batch is rendered whenever the next element needs to use a different type of program\n        // Therefore, you get better performance by grouping programs by z-order if possible.\n        // (Each sprite sheet will use a different program, but multiple sprites on the same sheet can be rendered in one batch)\n        var shaderProgram = null;\n        for (i = 0; i < l; i++) {\n            current = visible_gl[i];\n            if (shaderProgram !== current.program) {\n                if (shaderProgram !== null) {\n                    shaderProgram.renderBatch();\n                }\n\n                shaderProgram = current.program;\n                shaderProgram.index_pointer = 0;\n                shaderProgram.switchTo();\n            }\n            current.draw();\n            current._changed = false;\n        }\n\n        if (shaderProgram !== null) {\n            shaderProgram.renderBatch();\n        }\n\n    },\n\n    /**@\n     * #.dirty\n     * @comp WebGLLayer\n     * @kind Method\n     * @private\n     * \n     * @sign public .dirty(ent)\n     * @param ent - The entity to mark as dirty\n     *\n     * Add an entity to the list of DOM object to draw\n     */\n    dirty: function dirty(ent) {\n        // WebGL doens't need to do any special tracking of changed objects\n    },\n\n    /**@\n     * #.attach\n     * @comp WebGLLayer\n     * @kind Method\n     * @private\n     * \n     * @sign public .attach(ent)\n     * @param ent - The entity to add\n     *\n     * Add an entity to the layer\n     */\n    attach: function attach(ent) {\n        // WebGL entities really need to be added to a specific program, which is handled in the LayerAttached event by components\n        ent._drawContext = this.context;\n    },\n\n    /**@\n     * #.detach\n     * @comp WebGLLayer\n     * @kind Method\n     * @private\n     * \n     * @sign public .detach(ent)\n     * @param ent - The entity to remove\n     *\n     * Removes an entity from the layer\n     */\n    detach: function detach(ent) {\n        // This could, like attach, be handled by components\n        // We instead handle it in a central place for now\n        if (ent.program) {\n            ent.program.unregisterEntity(ent);\n        }\n    }\n\n});\n\n"},"hash":"73b9fb173ef918dd20e4a0528acd9045"}