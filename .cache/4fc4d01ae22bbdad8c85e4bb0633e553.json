{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js'),\n    document = window.document;\n\nCrafty.extend({\n    over: null, //object mouseover, waiting for out\n    mouseObjs: 0,\n    mousePos: {},   \n    touchObjs: 0,\n\n    /**@\n     * #Crafty.lastEvent\n     * @category Input\n     * @kind Property\n     * Check which mouse event occured most recently (useful for determining mouse position in every frame).\n     *\n     * The native [`MouseEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) is augmented with additional properties.\n     * @example\n     * ~~~\n     * // (x,y) coordinates of newest mouse event in web-browser (screen) space\n     * Crafty.lastEvent.clientX\n     * Crafty.lastEvent.clientY\n     *\n     * //(x,y) coordinates of newest mouse event in world (default viewport) space\n     * Crafty.lastEvent.realX\n     * Crafty.lastEvent.realY\n     *\n     * // Normalized mouse button according to Crafty.mouseButtons:\n     * // Crafty.mouseButtons.LEFT, Crafty.mouseButtons.RIGHT or Crafty.mouseButtons.MIDDLE\n     * Crafty.lastEvent.mouseButton\n     * ~~~\n     * @see Mouse, Crafty.mouseButtons, Crafty.mouseDispatch\n     */\n\n    lastEvent: null,\n    /**@\n     * #Crafty.keydown\n     * @category Input\n     * @kind Property\n     * Check which keys (referred by `Crafty.keys` key codes) are currently down.\n     *\n     * @example\n     * ~~~\n     * // is \"Shift\" currently pressed?\n     * var shiftDown = !!Crafty.keydown[Crafty.keys.SHIFT];\n     * ~~~\n     * @see Keyboard, Crafty.keys, Crafty.keyboardDispatch\n     */\n    keydown: {},\n\n    /**@\n     * #Crafty.selected\n     * @category Input\n     * @kind Property\n     * @trigger CraftyFocus - is triggered when Crafty's stage gets selected\n     * @trigger CraftyBlur - is triggered when Crafty's stage is no longer selected\n     *\n     * Check whether Crafty's stage (`Crafty.stage.elem`) is currently selected.\n     *\n     * After a click occurs inside Crafty's stage, this property is set to `true`.\n     * After a click occurs outside Crafty's stage, this property is set to `false`.\n     *\n     * @see Crafty.stage#Crafty.stage.elem\n     */\n    selected: false,\n\n    detectBlur: function (e) {\n        var selected = ((e.clientX > Crafty.stage.x && e.clientX < Crafty.stage.x + Crafty.viewport.width) &&\n            (e.clientY > Crafty.stage.y && e.clientY < Crafty.stage.y + Crafty.viewport.height));\n\n        if (!Crafty.selected && selected) {\n            Crafty.trigger(\"CraftyFocus\");\n        }\n\n        if (Crafty.selected && !selected) {\n            Crafty.trigger(\"CraftyBlur\");\n        }\n\n        Crafty.selected = selected;\n    },\n\n    /**@\n     * #Crafty.multitouch\n     * @category Input\n     * @kind Method\n     * @sign public this .multitouch(Boolean bool)\n     * @param bool - Turns multitouch on and off.  The initial state is off (false).\n     *\n     * @sign public Boolean .multitouch()\n     * @returns Whether multitouch is currently enabled;\n     *\n     * Enables/disables support for multitouch feature.\n     * \n     * If this is set to true, it is expected that your entities have the Touch component instead of Mouse component.\n     * If false (default), then only entities with the Mouse component will respond to touch.\n     *\n     * If no boolean is passed to the function call, it will just return whether multitouch is on or not.\n     * \n     * @note The Touch component (and thus the multitouch feature) is currently incompatible with the Draggable component.\n     * \n     * @example\n     * ~~~\n     * Crafty.multitouch(true);\n     * \n     * var myEntity1 = Crafty.e('2D, Canvas, Color, Touch')\n     *    .attr({x: 100, y: 100, w:200, h:200, z:1 })\n     *    .color('black')\n     *    .bind('TouchStart',function(e){ alert('big black box was touched', e); }),\n     *  myEntity2 = Crafty.e('2D, Canvas, Color, Touch')\n     *    .attr({x: 40, y: 150, w:90, h:300, z:2 })\n     *    .color('green')\n     *    .bind('TouchStart',function(e){ alert('big GREEN box was touched', e); });\n     * \n     * Crafty.log(\"multitouch is \"+Crafty.multitouch());\n     * ~~~\n     * @see Crafty.touchDispatch\n     * @see Touch\n     */\n    multitouch: function (bool) {\n        if (typeof bool !== \"boolean\") return this._touchHandler.multitouch;\n        this._touchHandler.multitouch = bool;\n    },\n\n    resetKeyDown: function () {\n        // Tell all the keys they're no longer held down\n        for (var k in Crafty.keys) {\n            if (Crafty.keydown[Crafty.keys[k]]) {\n                this.trigger(\"KeyUp\", {\n                    key: Crafty.keys[k]\n                });\n            }\n        }\n\n        Crafty.keydown = {};\n    },\n\n    /**@\n     * #Crafty.mouseDispatch\n     * @category Input\n     * @private\n     * @kind Method\n     *\n     * Internal method which dispatches mouse events received by Crafty.\n     *\n     * This method processes a native [`MouseEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) received by `Crafty.stage.elem`,\n     * augments it with additional properties and\n     * dispatches it to the closest (visible & `Mouse`-enhanced) entity to the source of the event (if available).\n     *\n     * This method also updates `Crafty.lastEvent`.\n     *\n     * @see Crafty.mouseButtons, Crafty.lastEvent, Mouse\n     */\n    mouseButtonsDown: {    },\n    mouseDispatch: function (e) {\n        if (!Crafty.mouseObjs) return;\n        Crafty.lastEvent = e;\n\n        var tar = e.target ? e.target : e.srcElement,\n            closest,\n            pos = Crafty.domHelper.translate(e.clientX, e.clientY),\n            type = e.type;\n\n        //Normalize button according to http://unixpapa.com/js/mouse.html\n        if (typeof e.which === 'undefined') {\n            e.mouseButton = (e.button < 2) ? Crafty.mouseButtons.LEFT : ((e.button === 4) ? Crafty.mouseButtons.MIDDLE : Crafty.mouseButtons.RIGHT);\n        } else {\n            e.mouseButton = (e.which < 2) ? Crafty.mouseButtons.LEFT : ((e.which === 2) ? Crafty.mouseButtons.MIDDLE : Crafty.mouseButtons.RIGHT);\n        }\n\n        // Set the mouse position based on standard viewport coordinates\n        Crafty.mousePos.x = pos.x;\n        Crafty.mousePos.y = pos.y;\n\n        // Track button state\n        if (type === \"mousedown\") {\n            this.mouseButtonsDown[e.mouseButton] = true;\n        }\n        if (type === \"mouseup\") {\n            delete this.mouseButtonsDown[e.mouseButton];\n        }\n\n        closest = Crafty.findPointerEventTargetByComponent(\"Mouse\", e, tar);\n        //found closest object to mouse\n        if (closest) {\n            //click must mousedown and out on tile\n            if (type === \"mousedown\") {\n                closest.trigger(\"MouseDown\", e);\n            } else if (type === \"mouseup\") {\n                closest.trigger(\"MouseUp\", e);\n            } else if (type === \"dblclick\") {\n                closest.trigger(\"DoubleClick\", e);\n            } else if (type === \"click\") {\n                closest.trigger(\"Click\", e);\n            } else if (type === \"mousemove\") {\n                closest.trigger(\"MouseMove\", e);\n                if (this.over !== closest) { //if new mousemove, it is over\n                    if (this.over) { \n                        this.over.trigger(\"MouseOut\", e); //if over wasn't null, send mouseout\n                        this.over = null;\n                    }\n                    this.over = closest;\n                    closest.trigger(\"MouseOver\", e);\n                }\n            } else closest.trigger(type, e); //trigger whatever it is\n        } else {\n            if (type === \"mousemove\" && this.over) {\n                this.over.trigger(\"MouseOut\", e);\n                this.over = null;\n            }\n            if (type === \"mousedown\") {\n                Crafty.viewport.mouselook('start', e);\n            } else if (type === \"mousemove\") {\n                Crafty.viewport.mouselook('drag', e);\n            } else if (type === \"mouseup\") {\n                Crafty.viewport.mouselook('stop');\n            }\n\n            // If nothing in particular was clicked, the controls system should get fed the event\n            if (type === \"mousedown\") {\n                Crafty.s(\"Controls\").trigger(\"MouseDown\", e);\n            } else if (type === \"mouseup\") {\n                Crafty.s(\"Controls\").trigger(\"MouseUp\", e);\n            } else if (type === \"dblclick\") {\n                Crafty.s(\"Controls\").trigger(\"DoubleClick\", e);\n            } else if (type === \"click\") {\n                Crafty.s(\"Controls\").trigger(\"Click\", e);\n            }\n        }\n\n        if (type === \"mousemove\") {\n            this.lastEvent = e;\n        }\n\n    },\n\n\n    /**@\n     * #Crafty.touchDispatch\n     * @category Input\n     * @kind Method\n     * @private\n     *\n     * Internal method which dispatches touch events received by Crafty (crafty.stage.elem).\n     * The touch events get dispatched to the closest entity to the source of the event (if available).\n     * \n     * By default, touch events are treated as mouse events. To change this behaviour (and enable multitouch)\n     * you must use Crafty.multitouch.\n     * \n     * If using multitouch feature, this method sets the array Crafty.touchHandler.fingers, which holds data \n     * of the most recent touches that occured (useful for determining positions of fingers in every frame) \n     * as well as last entity touched by each finger. Data is lost as soon as the finger is raised.\n     * \n     * You can read about the MouseEvent, which is the parameter passed to the Mouse entity's callback.\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     *\n     * You can also read about the TouchEvent.\n     * https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * \n     * And about the touch point interface, which is the parameter passed to the Touch entity's callback.\n     * http://www.w3.org/TR/touch-events/#dfn-active-touch-point\n     * \n     * @see Crafty.multitouch\n     * @see Touch\n     */\n    touchDispatch: function (e) {\n        if (!Crafty.touchObjs && !Crafty.mouseObjs) return;\n\n        if (this._touchHandler.multitouch)\n            switch (e.type) {\n                case \"touchstart\":\n                    this._touchHandler.handleStart(e);\n                    break;\n                case \"touchmove\":\n                    this._touchHandler.handleMove(e);\n                    break;\n                case \"touchleave\": // touchleave is treated as touchend\n                case \"touchcancel\": // touchcancel is treated as touchend, but triggers a TouchCancel event\n                case \"touchend\":\n                    this._touchHandler.handleEnd(e);\n                    break;\n            }\n        else\n            this._touchHandler.mimicMouse(e);\n\n        //Don't prevent default actions if target node is input or textarea.\n        if (e.target && e.target.nodeName !== 'INPUT' && e.target.nodeName !== 'TEXTAREA')\n            if (e.preventDefault) {\n                e.preventDefault();\n            } else {\n                e.returnValue = false;\n            }\n    },\n\n    _touchHandler: {\n        fingers: [], // keeps track of touching fingers\n        multitouch: false,\n\n        handleStart: function (e) {\n            var touches = e.changedTouches;\n            for (var i = 0, l = touches.length; i < l; i++) {\n                var idx = false,\n                    tar = e.target ? e.target : e.srcElement,\n                    closest;\n                closest = this.findClosestTouchEntity(touches[i], tar);\n\n                if (closest) {\n                    closest.trigger(\"TouchStart\", touches[i]);\n                    // In case the entity was already being pressed, get the finger index\n                    idx = this.fingerDownIndexByEntity(closest);\n                }\n                var touch = this.setTouch(touches[i], closest);\n                if (idx !== false && idx >= 0) {\n                    // Recycling finger...\n                    this.fingers[idx] = touch;\n                } else {\n                    this.fingers.push(touch);\n                }\n            }\n        },\n\n        handleMove: function (e) {\n            var touches = e.changedTouches;\n            for (var i = 0, l = touches.length; i < l; i++) {\n                var idx = this.fingerDownIndexById(touches[i].identifier),\n                    tar = e.target ? e.target : e.srcElement;\n                var closest = this.findClosestTouchEntity(touches[i], tar);\n\n                if (idx >= 0) {\n                    var finger = this.fingers[idx];\n                    if(typeof finger.entity !== \"undefined\")\n                        if (finger.entity === closest) {\n                            finger.entity.trigger(\"TouchMove\", touches[i]);\n                        } else {\n                            if (typeof closest === \"object\") closest.trigger(\"TouchStart\", touches[i]);\n                            finger.entity.trigger(\"TouchEnd\");\n                        }\n                    finger.entity = closest;\n                    finger.realX = touches[i].realX;\n                    finger.realY = touches[i].realY;\n                }\n            }\n        },\n\n        handleEnd: function (e) {\n            var touches = e.changedTouches, \n                eventName = e.type === \"touchcancel\" ? \"TouchCancel\" : \"TouchEnd\";\n            for (var i = 0, l = touches.length; i < l; i++) {\n                var idx = this.fingerDownIndexById(touches[i].identifier);\n\n                if (idx >= 0) {\n                    if (this.fingers[idx].entity)\n                        this.fingers[idx].entity.trigger(eventName);\n                    this.fingers.splice(idx, 1);\n                }\n            }\n        },\n\n        setTouch: function (touch, entity) {\n            return { identifier: touch.identifier, realX: touch.realX, realY: touch.realY, entity: entity };\n        },\n\n        findClosestTouchEntity: function (touchEvent, tar) {\n            return Crafty.findPointerEventTargetByComponent(\"Touch\", touchEvent, tar);\n        },\n\n        fingerDownIndexById: function (idToFind) {\n            for (var i = 0, l = this.fingers.length; i < l; i++) {\n                var id = this.fingers[i].identifier;\n                if (id === idToFind) {\n                    return i;\n                }\n            }\n            return -1;\n        },\n\n        fingerDownIndexByEntity: function (entityToFind) {\n            for (var i = 0, l = this.fingers.length; i < l; i++) {\n                var ent = this.fingers[i].entity;\n\n                if (ent === entityToFind) {\n                    return i;\n                }\n            }\n            return -1;\n        },\n\n        mimicMouse: function (e) {\n            var type, first,\n                lastEvent = Crafty.lastEvent;\n            if (e.type === \"touchstart\") type = \"mousedown\";\n            else if (e.type === \"touchmove\") type = \"mousemove\";\n            else if (e.type === \"touchend\") type = \"mouseup\";\n            else if (e.type === \"touchcancel\") type = \"mouseup\";\n            else if (e.type === \"touchleave\") type = \"mouseup\";\n            if (e.touches && e.touches.length) {\n                first = e.touches[0];\n            } else if (e.changedTouches && e.changedTouches.length) {\n                first = e.changedTouches[0];\n            }\n            var simulatedEvent = document.createEvent(\"MouseEvent\");\n            simulatedEvent.initMouseEvent(type, true, true, window, 1,\n                first.screenX,\n                first.screenY,\n                first.clientX,\n                first.clientY,\n                false, false, false, false, 0, e.relatedTarget\n            );\n            first.target.dispatchEvent(simulatedEvent);\n            // trigger click when it should be triggered\n            if (lastEvent !== null && lastEvent.type === 'mousedown' && type === 'mouseup') {\n                type = 'click';\n                simulatedEvent = document.createEvent(\"MouseEvent\");\n                simulatedEvent.initMouseEvent(type, true, true, window, 1,\n                    first.screenX,\n                    first.screenY,\n                    first.clientX,\n                    first.clientY,\n                    false, false, false, false, 0, e.relatedTarget\n                );\n                first.target.dispatchEvent(simulatedEvent);\n            }\n        },\n    },\n\n    /**@\n     * #Crafty.findPointerEventTargetByComponent\n     * @category Input\n     * @kind Method\n     * @private\n     * \n     * @sign public this .findPointerEventTargetByComponent(String comp, Event e[, Object target])\n     * Finds closest entity with certain component at a given event.\n     * @param comp - Component name\n     * @param e - The pointer event, which will be modifed to add `realX` and `realY` properties \n     * @param target - Target element wherein to look for entities \n     * \n     * This method is used internally by the .mouseDispatch and .touchDispatch methods, but can be used otherwise for \n     * Canvas entities.\n     * \n     * Finds the top most entity (with the highest z) with a given component at a given point (x, y) associated with the event.\n     * For having a detection area specified for the enity, add the AreaMap component to the entity expected to be found.\n     * \n     * The 'target' argument is only meant to be used by .mouseDispatch and touchDispatch; defaults to Crafty.stage.elem, \n     * thus using this function directly is only worth anything for canvas entities.\n     * \n     * Returns the found entity, or undefined if no entity was found.  \n     * Updates the event object to have two additional properties, `realX` and `realY`, which correspond to the point in the Crafty layer that the event targeted.\n     * \n     */\n    findPointerEventTargetByComponent: function (comp, e, target) {\n        var tar = target ? target : Crafty.stage.elem,\n            closest, current, q, l, i, pos, layerPos, maxz = -Infinity;\n        var x = e.clientX;\n        var y = e.clientY;\n\n        //if it's a DOM element with component we are done\n        if (tar.nodeName !== \"CANVAS\") {\n            while (typeof (tar.id) !== 'string' && tar.id.indexOf('ent') === -1) {\n                tar = tar.parentNode;\n            }\n            var ent = Crafty(parseInt(tar.id.replace('ent', ''), 10));\n            pos = Crafty.domHelper.translate(x, y, ent._drawLayer);\n            if (ent.__c[comp] && ent.isAt(pos.x, pos.y)) {\n                closest = ent;\n                layerPos = pos;\n            }\n        }\n\n        //else we search for an entity with component\n        if (!closest) {\n\n            // Loop through each layer\n            for (var layerIndex in Crafty._drawLayers) {\n                var layer = Crafty._drawLayers[layerIndex];\n\n                // Skip a layer if it has no entities listening for pointer events\n                if (layer._pointerEntities <= 0) continue;\n\n                // Get the position in this layer\n                pos = Crafty.domHelper.translate(x, y, layer);\n                q = Crafty.map.search({\n                    _x: pos.x,\n                    _y: pos.y,\n                    _w: 1,\n                    _h: 1\n                }, false);\n\n                for (i = 0, l = q.length; i < l; ++i) {\n                    current = q[i];\n                    if (current._visible && current._drawLayer === layer && current._globalZ > maxz &&\n                        current.__c[comp] && current.isAt(pos.x, pos.y)) {\n                        maxz = current._globalZ;\n                        closest = current;\n                        layerPos = pos;\n                    }\n                }\n            }\n        }\n        \n        // If the pointer event isn't related to a specific layer, \n        // find the Crafty position in the default coordinate set\n        if (!layerPos) {\n            layerPos = Crafty.domHelper.translate(x, y);\n        }\n\n        // Update the event coordinates and return the event target\n        e.realX = layerPos.x;\n        e.realY = layerPos.y;\n            \n        return closest;\n    },\n\n    /**@\n     * #Crafty.mouseWheelDispatch\n     * @category Input\n     * @kind Method\n     * @private\n     *\n     * Internal method which dispatches mouse wheel events received by Crafty.\n     * @trigger MouseWheelScroll - is triggered when mouse is scrolled on stage - { direction: +1 | -1} - Scroll direction (up | down)\n     *\n     * This method processes a native [`mousewheel` event](https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel) (all browsers except Firefox)\n     * or a native [`DOMMouseScroll` event](https://developer.mozilla.org/en-US/docs/Web/Events/DOMMouseScroll) (Firefox only) received by `Crafty.stage.elem`,\n     * augments it with the additional `.direction` property (see below) and dispatches it to the global Crafty object and thus to every entity.\n     *\n     * Note that the wheel delta properties of the event vary in magnitude across browsers, thus it is recommended to check for `.direction` instead.\n     * The `.direction` equals `+1` if wheel was scrolled up, `-1` if wheel was scrolled down\n     * (see [details](http://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers)).\n     *\n     * @example\n     * Zoom the viewport (camera) in response to mouse scroll events.\n     * ~~~\n     * Crafty.bind(\"MouseWheelScroll\", function(evt) {\n     *     Crafty.viewport.scale(Crafty.viewport._scale * (1 + evt.direction * 0.1));\n     * });\n     * ~~~\n     *\n     * @example\n     * Interactive, map-like zooming of the viewport (camera) in response to mouse scroll events.\n     * ~~~\n     * // sign public void zoomTowards(Number amt, Number posX, Number posY, Number time[, String|function easingFn])\n     * // param Number amt - amount to zoom in on the target by (eg. `2`, `4`, `0.5`)\n     * // param Number posX - the x coordinate to zoom towards\n     * // param Number posY - the y coordinate to zoom towards\n     * // param Number time - the duration in ms of the entire zoom operation\n     * // param easingFn - A string or custom function specifying an easing.\n     * //                   (Defaults to linear behavior.)\n     * //                   See `Crafty.easing` for more information.\n     * //\n     * // Zooms the camera towards a given point, preserving the current center.\n     * // `amt > 1` will bring the camera closer to the subject,\n     * // `amt < 1` will bring it farther away,\n     * // `amt = 0` will reset to the default zoom level.\n     * // Zooming is multiplicative. To reset the zoom amount, pass `0`.\n     * //\n     * // <example>\n     * // // Make the entities appear twice as large by zooming in towards (100,100) over the duration of 3 seconds using linear easing behavior\n     * // zoomTowards(2, 100, 100, 3000);\n     * // </example>\n     * //\n     * function zoomTowards (amt, posX, posY, time, easingFn) {\n     *     var scale = Crafty.viewport._scale,\n     *         // current viewport center\n     *         centX = -Crafty.viewport._x + Crafty.viewport._width / 2 / scale,\n     *         centY = -Crafty.viewport._y + Crafty.viewport._height / 2 / scale,\n     *         // direction vector from viewport center to position\n     *         deltaX = posX - centX,\n     *         deltaY = posY - centY;\n     *     var f = amt - 1;\n     *\n     *     Crafty.viewport.zoom(amt, centX + deltaX * f, centY + deltaY * f, time, easingFn);\n     * }\n     *\n     * // don't restrict panning of viewport in any way\n     * Crafty.viewport.clampToEntities = false;\n     *\n     * // enable panning of viewport by dragging the mouse\n     * Crafty.viewport.mouselook(true);\n     *\n     * // enable interactive map-like zooming by scrolling the mouse\n     * Crafty.bind(\"MouseWheelScroll\", function (evt) {\n     *     var pos = Crafty.domHelper.translate(evt.clientX, evt.clientY);\n     *     zoomTowards(1 + evt.direction/10, pos.x, pos.y, 5);\n     * });\n     * ~~~\n     */\n    mouseWheelDispatch: function (e) {\n        e.direction = (e.detail < 0 || e.wheelDelta > 0) ? 1 : -1;\n        Crafty.trigger(\"MouseWheelScroll\", e);\n    },\n\n    /**@\n     * #Crafty.keyboardDispatch\n     * @category Input\n     * @kind Method\n     * @private\n     *\n     * Internal method which dispatches keyboard events received by Crafty.\n     * @trigger KeyDown - is triggered for each entity when the DOM 'keydown' event is triggered. - { key: `Crafty.keys` keyCode (Number), originalEvent: original KeyboardEvent } - Crafty's KeyboardEvent\n     * @trigger KeyUp - is triggered for each entity when the DOM 'keyup' event is triggered. - { key: `Crafty.keys` keyCode (Number), originalEvent: original KeyboardEvent } - Crafty's KeyboardEvent\n     *\n     * This method processes a native [`KeyboardEvent`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) received by `window.document`,\n     * wraps it in a custom event object (for cross-browser compatibility) and dispatches it to the global Crafty object and thus to every entity.\n     *\n     * This method also updates `Crafty.keydown`.\n     *\n     * @example\n     * ~~~\n     * Crafty.bind('KeyDown', function(e) {\n     *     if (e.key === Crafty.keys.LEFT_ARROW) {\n     *       Crafty.viewport.x++;\n     *     } else if (e.key === Crafty.keys.RIGHT_ARROW) {\n     *       Crafty.viewport.x--;\n     *     } else if (e.key === Crafty.keys.UP_ARROW) {\n     *       Crafty.viewport.y++;\n     *     } else if (e.key === Crafty.keys.DOWN_ARROW) {\n     *       Crafty.viewport.y--;\n     *     }\n     *   });\n     * ~~~\n     *\n     * @see Crafty.keys, Crafty.keydown, Keyboard\n     */\n    keyboardDispatch: function (e) {\n        // Use a Crafty-standard event object to avoid cross-browser issues\n        var original = e,\n            evnt = {},\n            props = \"char charCode keyCode type shiftKey ctrlKey metaKey timestamp\".split(\" \");\n        for (var i = props.length; i;) {\n            var prop = props[--i];\n            evnt[prop] = original[prop];\n        }\n        evnt.which = original.charCode !== null ? original.charCode : original.keyCode;\n        evnt.key = original.keyCode || original.which;\n        evnt.originalEvent = original;\n        e = evnt;\n\n        if (e.type === \"keydown\") {\n            if (Crafty.keydown[e.key] !== true) {\n                Crafty.keydown[e.key] = true;\n                Crafty.trigger(\"KeyDown\", e);\n            }\n        } else if (e.type === \"keyup\") {\n            delete Crafty.keydown[e.key];\n            Crafty.trigger(\"KeyUp\", e);\n        }\n\n        //prevent default actions for all keys except backspace and F1-F12 and except actions in INPUT and TEXTAREA.\n        //prevent bubbling up for all keys except backspace and F1-F12.\n        //Among others this prevent the arrow keys from scrolling the parent page\n        //of an iframe hosting the game\n        if (Crafty.selected && !(e.key === 8 || e.key >= 112 && e.key <= 135)) {\n            if (original.stopPropagation) original.stopPropagation();\n            else original.cancelBubble = true;\n\n            //Don't prevent default actions if target node is input or textarea.\n            if (original.target && original.target.nodeName !== 'INPUT' && original.target.nodeName !== 'TEXTAREA') {\n                if (original.preventDefault) {\n                    original.preventDefault();\n                } else {\n                    original.returnValue = false;\n                }\n            }\n            return false;\n        }\n    }\n});\n\n//initialize the input events onload\nCrafty._preBind(\"Load\", function () {\n    Crafty.addEvent(this, \"keydown\", Crafty.keyboardDispatch);\n    Crafty.addEvent(this, \"keyup\", Crafty.keyboardDispatch);\n\n    Crafty.addEvent(this, Crafty.stage.elem, \"mousedown\", Crafty.mouseDispatch);\n    Crafty.addEvent(this, Crafty.stage.elem, \"mouseup\", Crafty.mouseDispatch);\n    Crafty.addEvent(this, document.body, \"mouseup\", Crafty.detectBlur);\n    Crafty.addEvent(this, window, \"blur\", Crafty.resetKeyDown);\n    Crafty.addEvent(this, Crafty.stage.elem, \"mousemove\", Crafty.mouseDispatch);\n    Crafty.addEvent(this, Crafty.stage.elem, \"click\", Crafty.mouseDispatch);\n    Crafty.addEvent(this, Crafty.stage.elem, \"dblclick\", Crafty.mouseDispatch);\n\n    Crafty.addEvent(this, Crafty.stage.elem, \"touchstart\", Crafty.touchDispatch);\n    Crafty.addEvent(this, Crafty.stage.elem, \"touchmove\", Crafty.touchDispatch);\n    Crafty.addEvent(this, Crafty.stage.elem, \"touchend\", Crafty.touchDispatch);\n    Crafty.addEvent(this, Crafty.stage.elem, \"touchcancel\", Crafty.touchDispatch);\n    Crafty.addEvent(this, Crafty.stage.elem, \"touchleave\", Crafty.touchDispatch);\n\n    if (Crafty.support.prefix === \"Moz\") // mouse wheel event for firefox\n        Crafty.addEvent(this, Crafty.stage.elem, \"DOMMouseScroll\", Crafty.mouseWheelDispatch);\n    else // mouse wheel event for rest of browsers\n        Crafty.addEvent(this, Crafty.stage.elem, \"mousewheel\", Crafty.mouseWheelDispatch);\n});\n\nCrafty._preBind(\"CraftyStop\", function () {\n    Crafty.removeEvent(this, \"keydown\", Crafty.keyboardDispatch);\n    Crafty.removeEvent(this, \"keyup\", Crafty.keyboardDispatch);\n\n    if (Crafty.stage) {\n        Crafty.removeEvent(this, Crafty.stage.elem, \"mousedown\", Crafty.mouseDispatch);\n        Crafty.removeEvent(this, Crafty.stage.elem, \"mouseup\", Crafty.mouseDispatch);\n        Crafty.removeEvent(this, Crafty.stage.elem, \"mousemove\", Crafty.mouseDispatch);\n        Crafty.removeEvent(this, Crafty.stage.elem, \"click\", Crafty.mouseDispatch);\n        Crafty.removeEvent(this, Crafty.stage.elem, \"dblclick\", Crafty.mouseDispatch);\n\n        Crafty.removeEvent(this, Crafty.stage.elem, \"touchstart\", Crafty.touchDispatch);\n        Crafty.removeEvent(this, Crafty.stage.elem, \"touchmove\", Crafty.touchDispatch);\n        Crafty.removeEvent(this, Crafty.stage.elem, \"touchend\", Crafty.touchDispatch);\n        Crafty.removeEvent(this, Crafty.stage.elem, \"touchcancel\", Crafty.touchDispatch);\n        Crafty.removeEvent(this, Crafty.stage.elem, \"touchleave\", Crafty.touchDispatch);\n\n        if (Crafty.support.prefix === \"Moz\") // mouse wheel event for firefox\n            Crafty.removeEvent(this, Crafty.stage.elem, \"DOMMouseScroll\", Crafty.mouseWheelDispatch);\n        else // mouse wheel event for rest of browsers\n            Crafty.removeEvent(this, Crafty.stage.elem, \"mousewheel\", Crafty.mouseWheelDispatch);\n    }\n\n    Crafty.removeEvent(this, document.body, \"mouseup\", Crafty.detectBlur);\n    Crafty.removeEvent(this, window, \"blur\", Crafty.resetKeyDown);\n});\n\n/**@\n * #Mouse\n * @category Input\n * @kind Component\n *\n * Provides the entity with mouse related events.\n *\n * If you do not add this component, mouse events will not be triggered on the entity.\n *\n * @trigger MouseOver - when the mouse enters - MouseEvent\n * @trigger MouseOut - when the mouse leaves - MouseEvent\n * @trigger MouseDown - when the mouse button is pressed on - MouseEvent\n * @trigger MouseUp - when the mouse button is released on - MouseEvent\n * @trigger Click - when the user clicks - MouseEvent\n * @trigger DoubleClick - when the user double clicks - MouseEvent\n * @trigger MouseMove - when the mouse is over and moves - MouseEvent\n *\n * The event callbacks are triggered with a native [`MouseEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) parameter,\n * which is further augmented with additional properties:\n * ~~~\n * //(x,y) coordinates of mouse event in web-browser (screen) space\n * e.clientX\n * e.clientY\n *\n * //(x,y) coordinates of mouse event in world (default viewport) space\n * e.realX\n * e.realY\n *\n * // Normalized mouse button according to Crafty.mouseButtons:\n * // Crafty.mouseButtons.LEFT, Crafty.mouseButtons.RIGHT or Crafty.mouseButtons.MIDDLE\n * e.mouseButton\n * ~~~\n *\n * @note If you're targeting mobile, you should know that by default Crafty turns touch events into mouse events, \n * making mouse dependent components work with touch. However, if you need multitouch, you'll have \n * to make use of the Touch component instead, which can break compatibility with things which directly interact with the Mouse component.\n *\n * @example\n * ~~~\n * var myEntity = Crafty.e('2D, Canvas, Color, Mouse')\n * .attr({x: 10, y: 10, w: 40, h: 40})\n * .color('red')\n * .bind('Click', function(MouseEvent){\n *   alert('clicked', MouseEvent);\n * });\n *\n * myEntity.bind('MouseUp', function(e) {\n *    if( e.mouseButton == Crafty.mouseButtons.RIGHT )\n *        Crafty.log(\"Clicked right button\");\n * })\n * ~~~\n * @see Crafty.mouseButtons\n * @see Crafty.mouseDispatch\n * @see Crafty.multitouch\n * @see Crafty.touchDispatch\n */\nCrafty.c(\"Mouse\", {\n    init: function () {\n        Crafty.mouseObjs++;\n        this.requires(\"AreaMap\")\n            .bind(\"Remove\", function () {\n                Crafty.mouseObjs--;\n            });\n    }\n});\n\n/**@\n * #Touch\n * @category Input\n * @kind Component\n * Provides the entity with touch related events\n * @trigger TouchStart - when entity is touched - TouchPoint\n * @trigger TouchMove - when finger is moved over entity - TouchPoint\n * @trigger TouchCancel - when a touch event has been disrupted in some way - TouchPoint\n * @trigger TouchEnd - when the finger is raised over the entity, or when finger leaves entity.  (Passes no data) - null\n *\n * To be able to use multitouch, you must enable it with  `Crafty.multitouch(true)`.\n *\n * If you don't need multitouch, you can probably use the Mouse component instead, since by default Crafty will trigger mouse events for touch input.\n *\n * You can read more about the TouchEvent.\n * - [TouchEvent.touches and TouchEvent.changedTouches](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent)\n * - [TouchPoint](http://www.w3.org/TR/touch-events/#dfn-active-touch-point) is the parameter passed to the event callback in the related touch.\n * \n *\n * @example\n * ~~~\n * Crafty.multitouch(true);\n * \n * var myEntity = Crafty.e('2D, Canvas, Color, Touch')\n * .attr({x: 10, y: 10, w: 40, h: 40})\n * .color('green')\n * .bind('TouchStart', function(TouchPoint){\n *   Crafty.log('myEntity has been touched', TouchPoint);\n * }).bind('TouchMove', function(TouchPoint) {\n *   Crafty.log('Finger moved over myEntity at the { x: ' + TouchPoint.realX + ', y: ' + TouchPoint.realY + ' } coordinates.');\n * }).bind('TouchEnd', function() {\n *   Crafty.log('Touch over myEntity has finished.');\n * });\n * ~~~\n * @see Crafty.multitouch\n * @see Crafty.touchDispatch\n */\nCrafty.c(\"Touch\", {\n    init: function () {\n        Crafty.touchObjs++;\n        this.requires(\"AreaMap\")\n            .bind(\"Remove\", function () {\n                Crafty.touchObjs--;\n            });\n    }\n});\n\n/**@\n * #AreaMap\n * @category Input\n * @kind Component\n * \n * Component used by Mouse and Touch.\n * Can be added to other entities for use with the Crafty.findClosestEntityByComponent method.\n * \n * @see Button\n * @see Crafty.polygon\n */\nCrafty.c(\"AreaMap\", {\n    init: function () {\n        if (this.has(\"Renderable\") && this._drawLayer) {\n            this._drawLayer._pointerEntities++;\n        }\n    },\n\n    remove: function () {\n        if (this.has(\"Renderable\") && this._drawLayer) {\n            this._drawLayer._pointerEntities--;\n        }\n    },\n\n    events: {\n        \"LayerAttached\": function (layer) {\n            layer._pointerEntities++;\n        },\n        \"LayerDetached\": function (layer) {\n            layer._pointerEntities--;\n        }\n    },\n\n    /**@\n     * #.areaMap\n     * @comp AreaMap\n     * @kind Method\n     *\n     * @trigger NewAreaMap - when a new areaMap is assigned - Crafty.polygon\n     *\n     * @sign public this .areaMap(Crafty.polygon polygon)\n     * @param polygon - Instance of Crafty.polygon used to check if the mouse coordinates are inside this region\n     *\n     * @sign public this .areaMap(Array coordinatePairs)\n     * @param coordinatePairs - Array of `x`, `y` coordinate pairs to generate a polygon\n     *\n     * @sign public this .areaMap(x1, y1,.., xN, yN)\n     * @param point# - List of `x`, `y` coordinate pairs to generate a polygon\n     *\n     * Assign a polygon to the entity so that pointer (mouse or touch) events will only be triggered if\n     * the coordinates are inside the given polygon.\n     *\n     * @example\n     * ~~~\n     * Crafty.e(\"2D, DOM, Color, Mouse\")\n     *     .color(\"red\")\n     *     .attr({ w: 100, h: 100 })\n     *     .bind('MouseOver', function() {Crafty.log(\"over\")})\n     *     .areaMap(0, 0, 50, 0, 50, 50, 0, 50);\n     *\n     * Crafty.e(\"2D, Mouse\")\n     *     .areaMap([0, 0, 50, 0, 50, 50, 0, 50]);\n     *\n     * Crafty.e(\"2D, Mouse\").areaMap(\n     *     new Crafty.polygon([0, 0, 50, 0, 50, 50, 0, 50])\n     * );\n     * ~~~\n     *\n     * @see Crafty.polygon\n     */\n    areaMap: function (poly) {\n        //create polygon\n        if (arguments.length > 1) {\n            //convert args to array to create polygon\n            var args = Array.prototype.slice.call(arguments, 0);\n            poly = new Crafty.polygon(args);\n        } else if (poly.constructor === Array) {\n            poly = new Crafty.polygon(poly.slice());\n        } else {\n            poly = poly.clone();\n        }\n\n        poly.shift(this._x, this._y);\n        this.mapArea = poly;\n        this.attach(this.mapArea);\n        this.trigger(\"NewAreaMap\", poly);\n        return this;\n    }\n});\n\n/**@\n * #Button\n * @category Input\n * @kind Component\n * \n * Provides the entity with touch or mouse functionality, depending on whether this is a pc \n * or mobile device, and also on multitouch configuration.\n *\n * @see Mouse\n * @see Touch\n * @see Crafty.multitouch\n */\nCrafty.c(\"Button\", {\n    init: function () {\n        var req = (!Crafty.mobile || (Crafty.mobile && !Crafty.multitouch())) ? \"Mouse\" : \"Touch\";\n        this.requires(req);\n    }\n});\n\n/**@\n * #MouseDrag\n * @category Input\n * @kind Component\n * \n * Provides the entity with drag and drop mouse events.\n * @trigger Dragging - is triggered each frame the entity is being dragged - MouseEvent\n * @trigger StartDrag - is triggered when dragging begins - MouseEvent\n * @trigger StopDrag - is triggered when dragging ends - MouseEvent\n *\n * @see Mouse\n */\nCrafty.c(\"MouseDrag\", {\n    _dragging: false,\n\n    init: function () {\n        this.requires(\"Mouse\");\n        this.bind(\"MouseDown\", this._ondown);\n    },\n\n    remove: function () {\n        this.unbind(\"MouseDown\", this._ondown);\n    },\n\n    // When dragging is enabled, this method is bound to the MouseDown crafty event\n    _ondown: function (e) {\n        if (e.mouseButton !== Crafty.mouseButtons.LEFT) return;\n        this.startDrag(e);\n    },\n\n    // While a drag is occurring, this method is bound to the mousemove DOM event\n    _ondrag: function (e) {\n        // ignore invalid 0 position - strange problem on ipad\n        if (!this._dragging || e.realX === 0 || e.realY === 0) return false;\n        this.trigger(\"Dragging\", e);\n    },\n\n    // While a drag is occurring, this method is bound to mouseup DOM event\n    _onup: function (e) {\n        if (e.mouseButton !== Crafty.mouseButtons.LEFT) return;\n        this.stopDrag(e);\n    },\n\n    /**@\n     * #.startDrag\n     * @comp MouseDrag\n     * @kind Method\n     * \n     * @sign public this .startDrag(void)\n     *\n     * Make the entity produce drag events, essentially making the entity follow the mouse positions.\n     *\n     * @see .stopDrag\n     */\n    startDrag: function (e) {\n        if (this._dragging) return;\n        this._dragging = true;\n\n        Crafty.addEvent(this, Crafty.stage.elem, \"mousemove\", this._ondrag);\n        Crafty.addEvent(this, Crafty.stage.elem, \"mouseup\", this._onup);\n\n        // if event undefined, use the last known position of the mouse\n        this.trigger(\"StartDrag\", e || Crafty.lastEvent);\n        return this;\n    },\n\n    /**@\n     * #.stopDrag\n     * @comp MouseDrag\n     * @kind Method\n     * \n     * @sign public this .stopDrag(void)\n     *\n     * Stop the entity from producing drag events, essentially reproducing the drop.\n     *\n     * @see .startDrag\n     */\n    stopDrag: function (e) {\n        if (!this._dragging) return;\n        this._dragging = false;\n\n        Crafty.removeEvent(this, Crafty.stage.elem, \"mousemove\", this._ondrag);\n        Crafty.removeEvent(this, Crafty.stage.elem, \"mouseup\", this._onup);\n\n        // if event undefined, use the last known position of the mouse\n        this.trigger(\"StopDrag\", e || Crafty.lastEvent);\n        return this;\n    }\n});\n\n/**@\n * #Keyboard\n * @category Input\n * @kind Component\n *\n * Provides entity with keyboard events.\n * @trigger KeyDown - is triggered for each entity when the DOM 'keydown' event is triggered. - { key: `Crafty.keys` keyCode (Number), originalEvent: original KeyboardEvent } - Crafty's KeyboardEvent\n * @trigger KeyUp - is triggered for each entity when the DOM 'keyup' event is triggered. - { key: `Crafty.keys` keyCode (Number), originalEvent: original KeyboardEvent } - Crafty's KeyboardEvent\n *\n * In addition to binding to these events, the current state (pressed/released) of a key can also be queried using the `.isDown` method.\n *\n * @example\n * ~~~\n * Crafty.e(\"2D, DOM, Color, Keyboard\")\n *   .attr({x: 100, y: 100, w: 50, h: 50})\n *   .color(\"red\")\n *   .bind('KeyDown', function(e) {\n *     if (e.key == Crafty.keys.LEFT_ARROW) {\n *       this.x = this.x-1;\n *     } else if (e.key == Crafty.keys.RIGHT_ARROW) {\n *       this.x = this.x+1;\n *     } else if (e.key == Crafty.keys.UP_ARROW) {\n *       this.y = this.y-1;\n *     } else if (e.key == Crafty.keys.DOWN_ARROW) {\n *       this.y = this.y+1;\n *     }\n *   });\n * ~~~\n *\n * @see Crafty.keys\n * @see Crafty.keydown\n * @see Crafty.keyboardDispatch\n */\nCrafty.c(\"Keyboard\", {\n    /**@\n     * #.isDown\n     * @comp Keyboard\n     * @kind Method\n     * \n     * @sign public Boolean isDown(String keyName)\n     * @param keyName - Name of the key to check. See `Crafty.keys`.\n     * @sign public Boolean isDown(Number keyCode)\n     * @param keyCode - Key code in `Crafty.keys`.\n     *\n     * Determine if a certain key is currently down.\n     *\n     * @example\n     * ~~~\n     * ent.requires('Keyboard')\n     *    .bind('EnterFrame', function() {\n     *       if (this.isDown('SPACE'))\n     *          this.y--;\n     *    });\n     * ~~~\n     *\n     * @see Crafty.keys\n     */\n    isDown: function (key) {\n        if (typeof key === \"string\") {\n            key = Crafty.keys[key];\n        }\n        return !!Crafty.keydown[key];\n    }\n});"},"hash":"936b2f55b5b06acef8755f8027e63e14"}