{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js');\n\n\n/**@\n * #Crafty.math\n * @category Utilities\n * @kind CoreObj\n *\n * A set of utility functions for common (and not so common) operations.\n */\nCrafty.math = {\n    /**@\n     * #Crafty.math.abs\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public this Crafty.math.abs(Number n)\n     * @param n - Some value.\n     * @return Absolute value.\n     *\n     * Returns the absolute value.\n     */\n    abs: function (x) {\n        return x < 0 ? -x : x;\n    },\n\n    /**@\n     * #Crafty.math.amountOf\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Number Crafty.math.amountOf(Number checkValue, Number minValue, Number maxValue)\n     * @param checkValue - Value that should checked with minimum and maximum.\n     * @param minValue - Bottom of the range\n     * @param maxValue - Top of the range\n     * @return The position of the checked value in a coordinate system normalized such that `minValue` is 0 and `maxValue` is 1.\n     *\n     * If checkValue is within the range, this will return a number between 0 and 1.\n     */\n    amountOf: function (checkValue, minValue, maxValue) {\n        if (minValue < maxValue)\n            return (checkValue - minValue) / (maxValue - minValue);\n        else\n            return (checkValue - maxValue) / (minValue - maxValue);\n    },\n\n\n    /**@\n     * #Crafty.math.clamp\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Number Crafty.math.clamp(Number value, Number min, Number max)\n     * @param value - A value.\n     * @param max - Maximum that value can be.\n     * @param min - Minimum that value can be.\n     * @return The value between minimum and maximum.\n     *\n     * Restricts a value to be within a specified range.\n     */\n    clamp: function (value, min, max) {\n        if (value > max)\n            return max;\n        else if (value < min)\n            return min;\n        else\n            return value;\n    },\n\n    /**@\n     * #Crafty.math.degToRad\n     * Converts angle from degree to radian.\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Number degToRad(angleInDeg)\n     * @param angleInDeg - The angle in degrees.\n     * @return The angle in radians.\n     */\n    degToRad: function (angleInDeg) {\n        return angleInDeg * Math.PI / 180;\n    },\n\n    /**@\n     * #Crafty.math.distance\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Number Crafty.math.distance(Number x1, Number y1, Number x2, Number y2)\n     * @param x1 - First x coordinate.\n     * @param y1 - First y coordinate.\n     * @param x2 - Second x coordinate.\n     * @param y2 - Second y coordinate.\n     * @return The distance between the two points.\n     *\n     * Distance between two points.\n     */\n    distance: function (x1, y1, x2, y2) {\n        var squaredDistance = Crafty.math.squaredDistance(x1, y1, x2, y2);\n        return Math.sqrt(parseFloat(squaredDistance));\n    },\n\n    /**@\n     * #Crafty.math.lerp\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Number Crafty.math.lerp(Number value1, Number value2, Number amount)\n     * @param value1 - One value.\n     * @param value2 - Another value.\n     * @param amount - Amount of value2 to value1.\n     * @return Linear interpolated value.\n     *\n     * Linear interpolation. Passing amount with a value of 0 will cause value1 to be returned,\n     * a value of 1 will cause value2 to be returned.\n     */\n    lerp: function (value1, value2, amount) {\n        return value1 + (value2 - value1) * amount;\n    },\n\n    /**@\n     * #Crafty.math.negate\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Number Crafty.math.negate(Number percent)\n     * @param percent - The probability of returning `-1`\n     * @return 1 or -1.\n     *\n     * Returns `1` or `-1` randomly.\n     */\n    negate: function (percent) {\n        if (Math.random() < percent)\n            return -1;\n        else\n            return 1;\n    },\n\n    /**@\n     * #Crafty.math.radToDeg\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Number Crafty.math.radToDeg(Number angle)\n     * @param angleInRad - The angle in radian.\n     * @return The angle in degree.\n     *\n     * Converts angle from radian to degree.\n     */\n    radToDeg: function (angleInRad) {\n        return angleInRad * 180 / Math.PI;\n    },\n\n    /**@\n     * #Crafty.math.randomElementOfArray\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Object Crafty.math.randomElementOfArray(Array array)\n     * @param array - A specific array.\n     * @return A random element of a specific array.\n     *\n     * Returns a random element of a specific array.\n     */\n    randomElementOfArray: function (array) {\n        return array[Math.floor(array.length * Math.random())];\n    },\n\n    /**@\n     * #Crafty.math.randomInt\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Number Crafty.math.randomInt(Number start, Number end)\n     * @param start - Smallest int value that can be returned.\n     * @param end - Biggest int value that can be returned.\n     * @return A random int.\n     *\n     * Returns a random int within a specific range.\n     */\n    randomInt: function (start, end) {\n        return start + Math.floor((1 + end - start) * Math.random());\n    },\n\n    /**@\n     * #Crafty.math.randomNumber\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Number Crafty.math.randomNumber(Number start, Number end)\n     * @param start - Smallest number value that can be returned.\n     * @param end - Biggest number value that can be returned.\n     * @return A random number.\n     *\n     * Returns a random number in within a specific range.\n     */\n    randomNumber: function (start, end) {\n        return start + (end - start) * Math.random();\n    },\n\n    /**@\n     * #Crafty.math.squaredDistance\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Number Crafty.math.squaredDistance(Number x1, Number y1, Number x2, Number y2)\n     * @param x1 - First x coordinate.\n     * @param y1 - First y coordinate.\n     * @param x2 - Second x coordinate.\n     * @param y2 - Second y coordinate.\n     * @return The squared distance between the two points.\n     *\n     * Squared distance between two points.\n     */\n    squaredDistance: function (x1, y1, x2, y2) {\n        return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n    },\n\n    /**@\n     * #Crafty.math.withinRange\n     * @comp Crafty.math\n     * @kind Method\n     * \n     * @sign public Boolean Crafty.math.withinRange(Number value, Number min, Number max)\n     * @param value - The specific value.\n     * @param min - Minimum value.\n     * @param max - Maximum value.\n     * @return Returns true if value is within a specific range.\n     *\n     * Check if a value is within a specific range.\n     */\n    withinRange: function (value, min, max) {\n        return (value >= min && value <= max);\n    }\n};\n\nCrafty.math.Vector2D = (function () {\n    /**@\n     * #Crafty.math.Vector2D\n     * @category 2D\n     * @kind Class\n     * \n     * @class This is a general purpose 2D vector class\n     *\n     * Vector2D uses the following form:\n     * <x, y>\n     *\n     * @public\n     * @sign public {Vector2D} Vector2D();\n     * @sign public {Vector2D} Vector2D(Vector2D);\n     * @sign public {Vector2D} Vector2D(Number, Number);\n     * @param {Vector2D|Number=0} x\n     * @param {Number=0} y\n     */\n\n    function Vector2D(x, y) {\n        if (x instanceof Vector2D) {\n            this.x = x.x;\n            this.y = x.y;\n        } else if (arguments.length === 2) {\n            this.x = x;\n            this.y = y;\n        } else if (arguments.length > 0)\n            throw \"Unexpected number of arguments for Vector2D()\";\n    } // class Vector2D\n\n    Vector2D.prototype.x = 0;\n    Vector2D.prototype.y = 0;\n\n    /**@\n     * #.add\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Adds the passed vector to this vector\n     *\n     * @public\n     * @sign public {Vector2D} add(Vector2D);\n     * @param {vector2D} vecRH\n     * @returns {Vector2D} this after adding\n     */\n    Vector2D.prototype.add = function (vecRH) {\n        this.x += vecRH.x;\n        this.y += vecRH.y;\n        return this;\n    }; // add\n\n    /**@\n     * #.angleBetween\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Calculates the angle between the passed vector and this vector, using <0,0> as the point of reference.\n     * Angles returned have the range (−π, π].\n     *\n     * @public\n     * @sign public {Number} angleBetween(Vector2D);\n     * @param {Vector2D} vecRH\n     * @returns {Number} the angle between the two vectors in radians\n     */\n    Vector2D.prototype.angleBetween = function (vecRH) {\n        return Math.atan2(this.x * vecRH.y - this.y * vecRH.x, this.x * vecRH.x + this.y * vecRH.y);\n    }; // angleBetween\n\n    /**@\n     * #.angleTo\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Calculates the angle to the passed vector from this vector, using this vector as the point of reference.\n     *\n     * @public\n     * @sign public {Number} angleTo(Vector2D);\n     * @param {Vector2D} vecRH\n     * @returns {Number} the angle to the passed vector in radians\n     */\n    Vector2D.prototype.angleTo = function (vecRH) {\n        return Math.atan2(vecRH.y - this.y, vecRH.x - this.x);\n    };\n\n    /**@\n     * #.clone\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Creates and exact, numeric copy of this vector\n     *\n     * @public\n     * @sign public {Vector2D} clone();\n     * @returns {Vector2D} the new vector\n     */\n    Vector2D.prototype.clone = function () {\n        return new Vector2D(this);\n    }; // clone\n\n    /**@\n     * #.distance\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Calculates the distance from this vector to the passed vector.\n     *\n     * @public\n     * @sign public {Number} distance(Vector2D);\n     * @param {Vector2D} vecRH\n     * @returns {Number} the distance between the two vectors\n     */\n    Vector2D.prototype.distance = function (vecRH) {\n        return Math.sqrt((vecRH.x - this.x) * (vecRH.x - this.x) + (vecRH.y - this.y) * (vecRH.y - this.y));\n    }; // distance\n\n    /**@\n     * #.distanceSq\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Calculates the squared distance from this vector to the passed vector.\n     * This function avoids calculating the square root, thus being slightly faster than .distance( ).\n     *\n     * @public\n     * @sign public {Number} distanceSq(Vector2D);\n     * @param {Vector2D} vecRH\n     * @returns {Number} the squared distance between the two vectors\n     * @see .distance\n     */\n    Vector2D.prototype.distanceSq = function (vecRH) {\n        return (vecRH.x - this.x) * (vecRH.x - this.x) + (vecRH.y - this.y) * (vecRH.y - this.y);\n    }; // distanceSq\n\n    /**@\n     * #.divide\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Divides this vector by the passed vector.\n     *\n     * @public\n     * @sign public {Vector2D} divide(Vector2D);\n     * @param {Vector2D} vecRH\n     * @returns {Vector2D} this vector after dividing\n     */\n    Vector2D.prototype.divide = function (vecRH) {\n        this.x /= vecRH.x;\n        this.y /= vecRH.y;\n        return this;\n    }; // divide\n\n    /**@\n     * #.dotProduct\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Calculates the dot product of this and the passed vectors\n     *\n     * @public\n     * @sign public {Number} dotProduct(Vector2D);\n     * @param {Vector2D} vecRH\n     * @returns {Number} the resultant dot product\n     */\n    Vector2D.prototype.dotProduct = function (vecRH) {\n        return this.x * vecRH.x + this.y * vecRH.y;\n    }; // dotProduct\n\n    /**@\n     * #.crossProduct\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Calculates the z component of the cross product of the two vectors augmented to 3D.\n     *\n     * @public\n     * @sign public {Number} crossProduct(Vector2D);\n     * @param {Vector2D} vecRH\n     * @returns {Number} the resultant cross product\n     */\n    Vector2D.prototype.crossProduct = function (vecRH) {\n        return this.x * vecRH.y - this.y * vecRH.x;\n    }; // crossProduct\n\n    /**@\n     * #.equals\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Determines if this vector is numerically equivalent to the passed vector.\n     *\n     * @public\n     * @sign public {Boolean} equals(Vector2D);\n     * @param {Vector2D} vecRH\n     * @returns {Boolean} true if the vectors are equivalent\n     */\n    Vector2D.prototype.equals = function (vecRH) {\n        return vecRH instanceof Vector2D &&\n            this.x === vecRH.x && this.y === vecRH.y;\n    }; // equals\n\n    /**@\n     * #.perpendicular\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Calculates a new vector that is perpendicular to this vector.\n     * The perpendicular vector has the same magnitude as this vector and is obtained by a counter-clockwise rotation of 90° of this vector.\n     *\n     * @public\n     * @sign public {Vector2D} perpendicular([Vector2D]);\n     * @param {Vector2D} [result] - An optional parameter to save the result in\n     * @returns {Vector2D} the perpendicular vector\n     */\n    Vector2D.prototype.perpendicular = function (result) {\n        result = result || new Vector2D();\n        return result.setValues(-this.y, this.x);\n    }; // perpendicular\n\n    /**@\n     * #.getNormal\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     *\n     * Calculates a new right-handed unit vector that is perpendicular to the line created by this and the passed vector.\n     *\n     * @public\n     * @sign public {Vector2D} getNormal(Vector2D[, Vector2D]);\n     * @param {Vector2D} vecRH\n     * @param {Vector2D} [result] - An optional parameter to save the result in\n     * @returns {Vector2D} the new normal vector\n     */\n    Vector2D.prototype.getNormal = function (vecRH, result) {\n        result = result || new Vector2D();\n        return result.setValues(vecRH.y - this.y, this.x - vecRH.x).normalize();\n    }; // getNormal\n\n    /**@\n     * #.isZero\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     *\n     * Determines if this vector is equal to <0,0>\n     *\n     * @public\n     * @sign public {Boolean} isZero();\n     * @returns {Boolean} true if this vector is equal to <0,0>\n     */\n    Vector2D.prototype.isZero = function () {\n        return this.x === 0 && this.y === 0;\n    }; // isZero\n\n    /**@\n     * #.magnitude\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     *\n     * Calculates the magnitude of this vector.\n     * Note: Function objects in JavaScript already have a 'length' member, hence the use of magnitude instead.\n     *\n     * @public\n     * @sign public {Number} magnitude();\n     * @returns {Number} the magnitude of this vector\n     */\n    Vector2D.prototype.magnitude = function () {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }; // magnitude\n\n    /**@\n     * #.magnitudeSq\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Calculates the square of the magnitude of this vector.\n     * This function avoids calculating the square root, thus being slightly faster than .magnitude( ).\n     *\n     * @public\n     * @sign public {Number} magnitudeSq();\n     * @returns {Number} the square of the magnitude of this vector\n     * @see .magnitude\n     */\n    Vector2D.prototype.magnitudeSq = function () {\n        return this.x * this.x + this.y * this.y;\n    }; // magnitudeSq\n\n    /**@\n     * #.multiply\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Multiplies this vector by the passed vector\n     *\n     * @public\n     * @sign public {Vector2D} multiply(Vector2D);\n     * @param {Vector2D} vecRH\n     * @returns {Vector2D} this vector after multiplying\n     */\n    Vector2D.prototype.multiply = function (vecRH) {\n        this.x *= vecRH.x;\n        this.y *= vecRH.y;\n        return this;\n    }; // multiply\n\n    /**@\n     * #.negate\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Negates this vector (ie. <-x,-y>)\n     *\n     * @public\n     * @sign public {Vector2D} negate();\n     * @returns {Vector2D} this vector after negation\n     */\n    Vector2D.prototype.negate = function () {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    }; // negate\n\n    /**@\n     * #.normalize\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Normalizes this vector (scales the vector so that its new magnitude is 1)\n     * For vectors where magnitude is 0, <1,0> is returned.\n     *\n     * @public\n     * @sign public {Vector2D} normalize();\n     * @returns {Vector2D} this vector after normalization\n     */\n    Vector2D.prototype.normalize = function () {\n        var lng = Math.sqrt(this.x * this.x + this.y * this.y);\n\n        if (lng === 0) {\n            // default due East\n            this.x = 1;\n            this.y = 0;\n        } else {\n            this.x /= lng;\n            this.y /= lng;\n        } // else\n\n        return this;\n    }; // normalize\n\n    /**@\n     * #.scale\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Scales this vector by the passed amount(s)\n     * If scalarY is omitted, scalarX is used for both axes\n     *\n     * @public\n     * @sign public {Vector2D} scale(Number[, Number]);\n     * @param {Number} scalarX\n     * @param {Number} [scalarY]\n     * @returns {Vector2D} this after scaling\n     */\n    Vector2D.prototype.scale = function (scalarX, scalarY) {\n        if (scalarY === undefined)\n            scalarY = scalarX;\n\n        this.x *= scalarX;\n        this.y *= scalarY;\n\n        return this;\n    }; // scale\n\n    /**@\n     * #.scaleToMagnitude\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Scales this vector such that its new magnitude is equal to the passed value.\n     *\n     * @public\n     * @sign public {Vector2D} scaleToMagnitude(Number);\n     * @param {Number} mag\n     * @returns {Vector2D} this vector after scaling\n     */\n    Vector2D.prototype.scaleToMagnitude = function (mag) {\n        var k = mag / this.magnitude();\n        this.x *= k;\n        this.y *= k;\n        return this;\n    }; // scaleToMagnitude\n\n    /**@\n     * #.setValues\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Sets the values of this vector using a passed vector or pair of numbers.\n     *\n     * @public\n     * @sign public {Vector2D} setValues(Vector2D);\n     * @sign public {Vector2D} setValues(Number, Number);\n     * @param {Number|Vector2D} x\n     * @param {Number} y\n     * @returns {Vector2D} this vector after setting of values\n     */\n    Vector2D.prototype.setValues = function (x, y) {\n        if (x instanceof Vector2D) {\n            this.x = x.x;\n            this.y = x.y;\n        } else {\n            this.x = x;\n            this.y = y;\n        } // else\n\n        return this;\n    }; // setValues\n\n    /**@\n     * #.subtract\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Subtracts the passed vector from this vector.\n     *\n     * @public\n     * @sign public {Vector2D} subtract(Vector2D);\n     * @param {Vector2D} vecRH\n     * @returns {vector2D} this vector after subtracting\n     */\n    Vector2D.prototype.subtract = function (vecRH) {\n        this.x -= vecRH.x;\n        this.y -= vecRH.y;\n        return this;\n    }; // subtract\n\n    /**@\n     * #.toString\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Returns a string representation of this vector.\n     *\n     * @public\n     * @sign public {String} toString();\n     * @returns {String}\n     */\n    Vector2D.prototype.toString = function () {\n        return \"Vector2D(\" + this.x + \", \" + this.y + \")\";\n    }; // toString\n\n    /**@\n     * #.translate\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Translates (moves) this vector by the passed amounts.\n     * If dy is omitted, dx is used for both axes.\n     *\n     * @public\n     * @sign public {Vector2D} translate(Number[, Number]);\n     * @param {Number} dx\n     * @param {Number} [dy]\n     * @returns {Vector2D} this vector after translating\n     */\n    Vector2D.prototype.translate = function (dx, dy) {\n        if (dy === undefined)\n            dy = dx;\n\n        this.x += dx;\n        this.y += dy;\n\n        return this;\n    }; // translate\n\n    /**@\n     * #.tripleProduct\n     * @comp Crafty.math.Vector2D\n     * @kind Method\n     * \n     * Calculates the triple product of three vectors.\n     * triple vector product = b(a•c) - a(b•c)\n     *\n     * @public\n     * @static\n     * @sign public {Vector2D} tripleProduct(Vector2D, Vector2D, Vector2D, [Vector2D]);\n     * @param {Vector2D} a\n     * @param {Vector2D} b\n     * @param {Vector2D} c\n     * @param {Vector2D} [result] - An optional parameter to save the result in\n     * @return {Vector2D} the triple product as a new vector\n     */\n    Vector2D.tripleProduct = function (a, b, c, result) {\n        result = result || new Crafty.math.Vector2D();\n        var ac = a.dotProduct(c);\n        var bc = b.dotProduct(c);\n        return result.setValues(b.x * ac - a.x * bc, b.y * ac - a.y * bc);\n    };\n\n    return Vector2D;\n})();\n\nCrafty.math.Matrix2D = (function () {\n    /**@\n     * #Crafty.math.Matrix2D\n     * @category 2D\n     * @kind Class\n     * \n     * @class This is a 2D Matrix2D class. It is 3x3 to allow for affine transformations in 2D space.\n     * The third row is always assumed to be [0, 0, 1].\n     *\n     * Matrix2D uses the following form, as per the whatwg.org specifications for canvas.transform():\n     * [a, c, e]\n     * [b, d, f]\n     * [0, 0, 1]\n     *\n     * @public\n     * @sign public {Matrix2D} new Matrix2D();\n     * @sign public {Matrix2D} new Matrix2D(Matrix2D);\n     * @sign public {Matrix2D} new Matrix2D(Number, Number, Number, Number, Number, Number);\n     * @param {Matrix2D|Number=1} a\n     * @param {Number=0} b\n     * @param {Number=0} c\n     * @param {Number=1} d\n     * @param {Number=0} e\n     * @param {Number=0} f\n     */\n    function Matrix2D (a, b, c, d, e, f) {\n        if (a instanceof Matrix2D) {\n            this.a = a.a;\n            this.b = a.b;\n            this.c = a.c;\n            this.d = a.d;\n            this.e = a.e;\n            this.f = a.f;\n        } else if (arguments.length === 6) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n            this.d = d;\n            this.e = e;\n            this.f = f;\n        } else if (arguments.length > 0)\n            throw \"Unexpected number of arguments for Matrix2D()\";\n    } // class Matrix2D\n\n    Matrix2D.prototype.a = 1;\n    Matrix2D.prototype.b = 0;\n    Matrix2D.prototype.c = 0;\n    Matrix2D.prototype.d = 1;\n    Matrix2D.prototype.e = 0;\n    Matrix2D.prototype.f = 0;\n\n    /**@\n     * #.apply\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Applies the matrix transformations to the passed object\n     *\n     * @public\n     * @sign public {Vector2D} apply(Vector2D);\n     * @param {Vector2D} vecRH - vector to be transformed\n     * @returns {Vector2D} the passed vector object after transforming\n     */\n    Matrix2D.prototype.apply = function (vecRH) {\n        // I'm not sure of the best way for this function to be implemented. Ideally\n        // support for other objects (rectangles, polygons, etc) should be easily\n        // addable in the future. Maybe a function (apply) is not the best way to do\n        // this...?\n\n        var tmpX = vecRH.x;\n        vecRH.x = tmpX * this.a + vecRH.y * this.c + this.e;\n        vecRH.y = tmpX * this.b + vecRH.y * this.d + this.f;\n        // no need to homogenize since the third row is always [0, 0, 1]\n\n        return vecRH;\n    }; // apply\n\n    /**@\n     * #.clone\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Creates an exact, numeric copy of the current matrix\n     *\n     * @public\n     * @sign public {Matrix2D} clone();\n     * @returns {Matrix2D}\n     */\n    Matrix2D.prototype.clone = function () {\n        return new Matrix2D(this);\n    }; // clone\n\n    /**@\n     * #.combine\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     *\n     * Multiplies this matrix with another, overriding the values of this matrix.\n     * The passed matrix is assumed to be on the right-hand side.\n     *\n     * @public\n     * @sign public {Matrix2D} combine(Matrix2D);\n     * @param {Matrix2D} mtrxRH\n     * @returns {Matrix2D} this matrix after combination\n     */\n    Matrix2D.prototype.combine = function (mtrxRH) {\n        var tmp = this.a;\n        this.a = tmp * mtrxRH.a + this.b * mtrxRH.c;\n        this.b = tmp * mtrxRH.b + this.b * mtrxRH.d;\n        tmp = this.c;\n        this.c = tmp * mtrxRH.a + this.d * mtrxRH.c;\n        this.d = tmp * mtrxRH.b + this.d * mtrxRH.d;\n        tmp = this.e;\n        this.e = tmp * mtrxRH.a + this.f * mtrxRH.c + mtrxRH.e;\n        this.f = tmp * mtrxRH.b + this.f * mtrxRH.d + mtrxRH.f;\n        return this;\n    }; // combine\n\n    /**@\n     * #.equals\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     *\n     * Checks for the numeric equality of this matrix versus another.\n     *\n     * @public\n     * @sign public {Boolean} equals(Matrix2D);\n     * @param {Matrix2D} mtrxRH\n     * @returns {Boolean} true if the two matrices are numerically equal\n     */\n    Matrix2D.prototype.equals = function (mtrxRH) {\n        return mtrxRH instanceof Matrix2D &&\n            this.a === mtrxRH.a && this.b === mtrxRH.b && this.c === mtrxRH.c &&\n            this.d === mtrxRH.d && this.e === mtrxRH.e && this.f === mtrxRH.f;\n    }; // equals\n\n    /**@\n     * #.determinant\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     *\n     * Calculates the determinant of this matrix\n     *\n     * @public\n     * @sign public {Number} determinant();\n     * @returns {Number} det(this matrix)\n     */\n    Matrix2D.prototype.determinant = function () {\n        return this.a * this.d - this.b * this.c;\n    }; // determinant\n\n    /**@\n     * #.invert\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     *\n     * Inverts this matrix if possible\n     *\n     * @public\n     * @sign public {Matrix2D} invert();\n     * @returns {Matrix2D} this inverted matrix or the original matrix on failure\n     * @see .isInvertible\n     */\n    Matrix2D.prototype.invert = function () {\n        var det = this.determinant();\n\n        // matrix is invertible if its determinant is non-zero\n        if (det !== 0) {\n            var old = {\n                a: this.a,\n                b: this.b,\n                c: this.c,\n                d: this.d,\n                e: this.e,\n                f: this.f\n            };\n            this.a = old.d / det;\n            this.b = -old.b / det;\n            this.c = -old.c / det;\n            this.d = old.a / det;\n            this.e = (old.c * old.f - old.e * old.d) / det;\n            this.f = (old.e * old.b - old.a * old.f) / det;\n        } // if\n\n        return this;\n    }; // invert\n\n    /**@\n     * #.isIdentity\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Returns true if this matrix is the identity matrix\n     *\n     * @public\n     * @sign public {Boolean} isIdentity();\n     * @returns {Boolean}\n     */\n    Matrix2D.prototype.isIdentity = function () {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.e === 0 && this.f === 0;\n    }; // isIdentity\n\n    /**@\n     * #.isInvertible\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Determines is this matrix is invertible.\n     *\n     * @public\n     * @sign public {Boolean} isInvertible();\n     * @returns {Boolean} true if this matrix is invertible\n     * @see .invert\n     */\n    Matrix2D.prototype.isInvertible = function () {\n        return this.determinant() !== 0;\n    }; // isInvertible\n\n    /**@\n     * #.preRotate\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Applies a counter-clockwise pre-rotation to this matrix\n     *\n     * @public\n     * @sign public {Matrix2D} preRotate(Number);\n     * @param {number} rads - angle to rotate in radians\n     * @returns {Matrix2D} this matrix after pre-rotation\n     */\n    Matrix2D.prototype.preRotate = function (rads) {\n        var nCos = Math.cos(rads);\n        var nSin = Math.sin(rads);\n\n        var tmp = this.a;\n        this.a = nCos * tmp - nSin * this.b;\n        this.b = nSin * tmp + nCos * this.b;\n        tmp = this.c;\n        this.c = nCos * tmp - nSin * this.d;\n        this.d = nSin * tmp + nCos * this.d;\n\n        return this;\n    }; // preRotate\n\n    /**@\n     * #.preScale\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Applies a pre-scaling to this matrix\n     *\n     * @public\n     * @sign public {Matrix2D} preScale(Number[, Number]);\n     * @param {Number} scalarX\n     * @param {Number} [scalarY] scalarX is used if scalarY is undefined\n     * @returns {Matrix2D} this after pre-scaling\n     */\n    Matrix2D.prototype.preScale = function (scalarX, scalarY) {\n        if (scalarY === undefined)\n            scalarY = scalarX;\n\n        this.a *= scalarX;\n        this.b *= scalarY;\n        this.c *= scalarX;\n        this.d *= scalarY;\n\n        return this;\n    }; // preScale\n\n    /**@\n     * #.preTranslate\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Applies a pre-translation to this matrix\n     *\n     * @public\n     * @sign public {Matrix2D} preTranslate(Vector2D);\n     * @sign public {Matrix2D} preTranslate(Number, Number);\n     * @param {Number|Vector2D} dx\n     * @param {Number} dy\n     * @returns {Matrix2D} this matrix after pre-translation\n     */\n    Matrix2D.prototype.preTranslate = function (dx, dy) {\n        if (typeof dx === \"number\") {\n            this.e += dx;\n            this.f += dy;\n        } else {\n            this.e += dx.x;\n            this.f += dx.y;\n        } // else\n\n        return this;\n    }; // preTranslate\n\n    /**@\n     * #.rotate\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Applies a counter-clockwise post-rotation to this matrix\n     *\n     * @public\n     * @sign public {Matrix2D} rotate(Number);\n     * @param {Number} rads - angle to rotate in radians\n     * @returns {Matrix2D} this matrix after rotation\n     */\n    Matrix2D.prototype.rotate = function (rads) {\n        var nCos = Math.cos(rads);\n        var nSin = Math.sin(rads);\n\n        var tmp = this.a;\n        this.a = nCos * tmp - nSin * this.b;\n        this.b = nSin * tmp + nCos * this.b;\n        tmp = this.c;\n        this.c = nCos * tmp - nSin * this.d;\n        this.d = nSin * tmp + nCos * this.d;\n        tmp = this.e;\n        this.e = nCos * tmp - nSin * this.f;\n        this.f = nSin * tmp + nCos * this.f;\n\n        return this;\n    }; // rotate\n\n    /**@\n     * #.scale\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Applies a post-scaling to this matrix\n     *\n     * @public\n     * @sign public {Matrix2D} scale(Number[, Number]);\n     * @param {Number} scalarX\n     * @param {Number} [scalarY] scalarX is used if scalarY is undefined\n     * @returns {Matrix2D} this after post-scaling\n     */\n    Matrix2D.prototype.scale = function (scalarX, scalarY) {\n        if (scalarY === undefined)\n            scalarY = scalarX;\n\n        this.a *= scalarX;\n        this.b *= scalarY;\n        this.c *= scalarX;\n        this.d *= scalarY;\n        this.e *= scalarX;\n        this.f *= scalarY;\n\n        return this;\n    }; // scale\n\n    /**@\n     * #.setValues\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Sets the values of this matrix\n     *\n     * @public\n     * @sign public {Matrix2D} setValues(Matrix2D);\n     * @sign public {Matrix2D} setValues(Number, Number, Number, Number, Number, Number);\n     * @param {Matrix2D|Number} a\n     * @param {Number} b\n     * @param {Number} c\n     * @param {Number} d\n     * @param {Number} e\n     * @param {Number} f\n     * @returns {Matrix2D} this matrix containing the new values\n     */\n    Matrix2D.prototype.setValues = function (a, b, c, d, e, f) {\n        if (a instanceof Matrix2D) {\n            this.a = a.a;\n            this.b = a.b;\n            this.c = a.c;\n            this.d = a.d;\n            this.e = a.e;\n            this.f = a.f;\n        } else {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n            this.d = d;\n            this.e = e;\n            this.f = f;\n        } // else\n\n        return this;\n    }; // setValues\n\n    /**@\n     * #.toString\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Returns the string representation of this matrix.\n     *\n     * @public\n     * @sign public {String} toString();\n     * @returns {String}\n     */\n    Matrix2D.prototype.toString = function () {\n        return \"Matrix2D([\" + this.a + \", \" + this.c + \", \" + this.e +\n            \"] [\" + this.b + \", \" + this.d + \", \" + this.f + \"] [0, 0, 1])\";\n    }; // toString\n\n    /**@\n     * #.translate\n     * @comp Crafty.math.Matrix2D\n     * @kind Method\n     * \n     * Applies a post-translation to this matrix\n     *\n     * @public\n     * @sign public {Matrix2D} translate(Vector2D);\n     * @sign public {Matrix2D} translate(Number, Number);\n     * @param {Number|Vector2D} dx\n     * @param {Number} dy\n     * @returns {Matrix2D} this matrix after post-translation\n     */\n    Matrix2D.prototype.translate = function (dx, dy) {\n        if (typeof dx === \"number\") {\n            this.e += this.a * dx + this.c * dy;\n            this.f += this.b * dx + this.d * dy;\n        } else {\n            this.e += this.a * dx.x + this.c * dx.y;\n            this.f += this.b * dx.x + this.d * dx.y;\n        } // else\n\n        return this;\n    }; // translate\n\n    return Matrix2D;\n})();"},"hash":"d8e1503b5048ce305c2ba6a122fd874e"}