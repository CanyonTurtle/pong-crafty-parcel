{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}},{"name":"fs","loc":{"line":4,"column":17}},{"name":"C:\\Users\\canno\\Documents\\Code\\parcel-crafty\\node_modules\\craftyjs\\src\\graphics\\shaders\\sprite.vert","includedInParent":true},{"name":"C:\\Users\\canno\\Documents\\Code\\parcel-crafty\\node_modules\\craftyjs\\src\\graphics\\shaders\\sprite.frag","includedInParent":true}],"generated":{"js":"var Crafty = require('../core/core.js');\n\n// Define some variables required for webgl\nvar fs = require('fs');\n\nCrafty.defaultShader(\"Sprite\", new Crafty.WebGLShader(\"attribute vec2 aPosition;\\nattribute vec3 aOrientation;\\nattribute vec2 aLayer;\\nattribute vec2 aTextureCoord;\\n\\nvarying mediump vec3 vTextureCoord;\\n\\nuniform vec4 uViewport;\\nuniform mediump vec2 uTextureDimensions;\\n\\nmat4 viewportScale = mat4(2.0 / uViewport.z, 0, 0, 0,    0, -2.0 / uViewport.w, 0,0,    0, 0,1,0,    -1,+1,0,1);\\nvec4 viewportTranslation = vec4(uViewport.xy, 0, 0);\\n\\nvoid main() {\\n  vec2 pos = aPosition;\\n  vec2 entityOrigin = aOrientation.xy;\\n  mat2 entityRotationMatrix = mat2(cos(aOrientation.z), sin(aOrientation.z), -sin(aOrientation.z), cos(aOrientation.z));\\n  \\n  pos = entityRotationMatrix * (pos - entityOrigin) + entityOrigin ;\\n  gl_Position = viewportScale * (viewportTranslation + vec4(pos, 1.0/(1.0+exp(aLayer.x) ), 1) );\\n  vTextureCoord = vec3(aTextureCoord, aLayer.y);\\n}\", \"varying mediump vec3 vTextureCoord;\\n  \\nuniform sampler2D uSampler;\\nuniform mediump vec2 uTextureDimensions;\\n\\nvoid main(void) {\\n  highp vec2 coord =   vTextureCoord.xy / uTextureDimensions;\\n  mediump vec4 base_color = texture2D(uSampler, coord);\\n  gl_FragColor = vec4(base_color.rgb*base_color.a*vTextureCoord.z, base_color.a*vTextureCoord.z);\\n}\", [{ name: \"aPosition\", width: 2 }, { name: \"aOrientation\", width: 3 }, { name: \"aLayer\", width: 2 }, { name: \"aTextureCoord\", width: 2 }], function (e, _entity) {\n  var co = e.co;\n  // Write texture coordinates\n  e.program.writeVector(\"aTextureCoord\", co.x, co.y, co.x, co.y + co.h, co.x + co.w, co.y, co.x + co.w, co.y + co.h);\n}));\n\nCrafty.extend({\n  /**@\n   * #Crafty.sprite\n   * @kind Method\n   * \n   * @category Graphics\n   * @sign public this Crafty.sprite([Number tile, [Number tileh]], String url, Object map[, Number paddingX[, Number paddingY[, Boolean paddingAroundBorder]]])\n   * @param tile - Tile size of the sprite map, defaults to 1\n   * @param tileh - Height of the tile; if provided, tile is interpreted as the width\n   * @param url - URL of the sprite image\n   * @param map - Object where the key is what becomes a new component and the value points to a position on the sprite map\n   * @param paddingX - Horizontal space in between tiles. Defaults to 0.\n   * @param paddingY - Vertical space in between tiles. Defaults to paddingX.\n   * @param paddingAroundBorder - If padding should be applied around the border of the sprite sheet. If enabled the first tile starts at (paddingX,paddingY) instead of (0,0). Defaults to false.\n   *\n   * Generates components based on positions in a sprite image to be applied to entities.\n   *\n   * Accepts a tile size, URL and map for the name of the sprite and its position.\n   *\n   * The position must be an array containing the position of the sprite where index `0`\n   * is the `x` position, `1` is the `y` position and optionally `2` is the width and `3`\n   * is the height. If the sprite map has padding, pass the values for the `x` padding\n   * or `y` padding. If they are the same, just add one value.\n   *\n   * If the sprite image has no consistent tile size, `1` or no argument need be\n   * passed for tile size.\n   *\n   * Entities that add the generated components are also given the `2D` component, and\n   * a component called `Sprite`.\n   *\n   * @example\n   * ~~~\n   * Crafty.sprite(\"imgs/spritemap6.png\", {flower:[0,0,20,30]});\n   * var flower_entity = Crafty.e(\"2D, DOM, flower\");\n   * ~~~\n   * The first line creates a component called `flower` associated with the sub-image of\n   * spritemap6.png with top-left corner (0,0), width 20 pixels, and height 30 pixels.\n   * The second line creates an entity with that image. (Note: The `2D` is not really\n   * necessary here, because adding the `flower` component automatically also adds the\n   * `2D` component.)\n   * ~~~\n   * Crafty.sprite(50, \"imgs/spritemap6.png\", {flower:[0,0], grass:[0,1,3,1]});\n   * ~~~\n   * In this case, the `flower` component is pixels 0 <= x < 50, 0 <= y < 50, and the\n   * `grass` component is pixels 0 <= x < 150, 50 <= y < 100. (The `3` means grass has a\n   * width of 3 tiles, i.e. 150 pixels.)\n   * ~~~\n   * Crafty.sprite(50, 100, \"imgs/spritemap6.png\", {flower:[0,0], grass:[0,1]}, 10);\n   * ~~~\n   * In this case, each tile is 50x100, and there is a spacing of 10 pixels between\n   * consecutive tiles. So `flower` is pixels 0 <= x < 50, 0 <= y < 100, and `grass` is\n   * pixels 0 <= x < 50, 110 <= y < 210.\n   *\n   * @see Sprite\n   */\n  sprite: function (tile, tileh, url, map, paddingX, paddingY, paddingAroundBorder) {\n    var spriteName, temp, img;\n\n    //if no tile value, default to 1.\n    //(if the first passed argument is a string, it must be the url.)\n    if (typeof tile === \"string\") {\n      paddingY = paddingX;\n      paddingX = map;\n      map = tileh;\n      url = tile;\n      tile = 1;\n      tileh = 1;\n    }\n\n    if (typeof tileh === \"string\") {\n      paddingY = paddingX;\n      paddingX = map;\n      map = url;\n      url = tileh;\n      tileh = tile;\n    }\n\n    //if no paddingY, use paddingX\n    if (!paddingY && paddingX) paddingY = paddingX;\n    paddingX = parseInt(paddingX || 0, 10); //just incase\n    paddingY = parseInt(paddingY || 0, 10);\n\n    var markSpritesReady = function () {\n      this.ready = true;\n      this.trigger(\"Invalidate\");\n    };\n\n    img = Crafty.asset(url);\n    if (!img) {\n      img = new Image();\n      img.src = url;\n      Crafty.asset(url, img);\n      img.onload = function () {\n        //all components with this img are now ready\n        for (var spriteName in map) {\n          Crafty(spriteName).each(markSpritesReady);\n        }\n      };\n    }\n\n    var sharedSpriteInit = function () {\n      this.requires(\"2D, Sprite\");\n      this.__trim = [0, 0, 0, 0];\n      this.__image = url;\n      this.__map = map;\n      this.__coord = [this.__coord[0], this.__coord[1], this.__coord[2], this.__coord[3]];\n      this.__tile = tile;\n      this.__tileh = tileh;\n      this.__padding = [paddingX, paddingY];\n      this.__padBorder = paddingAroundBorder;\n      this.sprite(this.__coord[0], this.__coord[1], this.__coord[2], this.__coord[3]);\n\n      this.img = img;\n      //draw now\n      if (this.img.complete && this.img.width > 0) {\n        this.ready = true;\n        this.trigger(\"Invalidate\");\n      }\n\n      //set the width and height to the sprite size\n      this.w = this.__coord[2];\n      this.h = this.__coord[3];\n      this._setupSpriteImage(this._drawLayer);\n    };\n\n    for (spriteName in map) {\n      if (!map.hasOwnProperty(spriteName)) continue;\n\n      temp = map[spriteName];\n\n      //generates sprite components for each tile in the map\n      Crafty.c(spriteName, {\n        ready: false,\n        __coord: [temp[0], temp[1], temp[2] || 1, temp[3] || 1],\n\n        init: sharedSpriteInit\n      });\n    }\n\n    return this;\n  }\n});\n\n/**@\n * #Sprite\n * @category Graphics\n * @kind Component\n * \n * @trigger Invalidate - when the sprites change\n *\n * A component for using tiles in a sprite map.\n *\n * This is automatically added to entities which use the components created by `Crafty.sprite` or `Crafty.load`.\n * Since these are also used to define tile size, you'll rarely need to use this components methods directly.\n *\n * @see Crafty.sprite, Crafty.load\n */\nCrafty.c(\"Sprite\", {\n  __image: '',\n  /*\n   * #.__tile\n   * @comp Sprite\n   *\n   * Horizontal sprite tile size.\n   */\n  __tile: 0,\n  /*\n   * #.__tileh\n   * @comp Sprite\n   *\n   * Vertical sprite tile size.\n   */\n  __tileh: 0,\n  __padding: null,\n  __trim: null,\n  img: null,\n  //ready is changed to true in Crafty.sprite\n  ready: false,\n\n  init: function () {\n    this.__trim = [0, 0, 0, 0];\n    this.bind(\"Draw\", this._drawSprite);\n    this.bind(\"LayerAttached\", this._setupSpriteImage);\n  },\n\n  remove: function () {\n    this.unbind(\"Draw\", this._drawSprite);\n    this.unbind(\"LayerAttached\", this._setupSpriteImage);\n  },\n\n  _setupSpriteImage: function (layer) {\n    if (!this.__image || !this.img || !layer) return;\n    if (layer.type === \"WebGL\") {\n      this._establishShader(this.__image, Crafty.defaultShader(\"Sprite\"));\n      this.program.setTexture(layer.makeTexture(this.__image, this.img, false));\n    }\n  },\n\n  _drawSprite: function (e) {\n    var co = e.co,\n        pos = e.pos,\n        context = e.ctx;\n\n    if (e.type === \"canvas\") {\n      //draw the image on the canvas element\n      context.drawImage(this.img, //image element\n      co.x, //x position on sprite\n      co.y, //y position on sprite\n      co.w, //width on sprite\n      co.h, //height on sprite\n      pos._x, //x position on canvas\n      pos._y, //y position on canvas\n      pos._w, //width on canvas\n      pos._h //height on canvas\n      );\n    } else if (e.type === \"DOM\") {\n      // Get scale (ratio of entity dimensions to sprite's dimensions)\n      // If needed, we will scale up the entire sprite sheet, and then modify the position accordingly\n      var vscale = this._h / co.h,\n          hscale = this._w / co.w,\n          style = this._element.style,\n          bgColor = style.backgroundColor;\n\n      if (bgColor === \"initial\") bgColor = \"\";\n\n      // Don't change background if it's not necessary -- this can cause some browsers to reload the image\n      // See [this chrome issue](https://code.google.com/p/chromium/issues/detail?id=102706)\n      var newBackground = bgColor + \" url('\" + this.__image + \"') no-repeat\";\n      if (newBackground !== style.background) {\n        style.background = newBackground;\n      }\n      style.backgroundPosition = \"-\" + co.x * hscale + \"px -\" + co.y * vscale + \"px\";\n      // style.backgroundSize must be set AFTER style.background!\n      if (vscale !== 1 || hscale !== 1) {\n        style.backgroundSize = this.img.width * hscale + \"px\" + \" \" + this.img.height * vscale + \"px\";\n      }\n    } else if (e.type === \"webgl\") {\n      // Write texture coordinates\n      e.program.draw(e, this);\n    }\n  },\n\n  /**@\n   * #.sprite\n   * @comp Sprite\n   * @kind Method\n   *\n   * @sign public this .sprite(Number x, Number y[, Number w, Number h])\n   * @param x - X cell position\n   * @param y - Y cell position\n   * @param w - Width in cells. Optional.\n   * @param h - Height in cells. Optional.\n   *\n   * Uses a new location on the sprite map as its sprite.\n   * If w or h are ommitted, the width and height are not changed.\n   * Values should be in tiles or cells (not pixels).\n   *\n   * @sign public this .sprite(String tileName)\n   * @param tileName - the name of a tile specified in the sprite map\n   *\n   * Uses a new location on the sprite map as its sprite.\n   * The location is retrieved by name from the previously supplied sprite map.\n   * An invalid name will be silently ignored.\n   *\n   * @example\n   * ~~~\n   * Crafty.e(\"2D, DOM, Sprite\")\n   *   .sprite(0, 0, 2, 2);\n   *\n   * Crafty.e(\"2D, DOM, flower\")\n   *   .sprite('grass');\n   * ~~~\n   */\n\n  /**@\n   * #.__coord\n   * @comp Sprite\n   * @kind Property\n   *\n   * The coordinate of the slide within the sprite in the format of [x, y, w, h].\n   */\n  sprite: function (x, y, w, h) {\n    if (typeof x === 'string') {\n      // retrieve location from sprite map by name\n      var temp = this.__map[x];\n      if (!temp) return this;\n\n      x = temp[0];\n      y = temp[1];\n      w = temp[2] || 1;\n      h = temp[3] || 1;\n    }\n\n    this.__coord = this.__coord || [0, 0, 0, 0];\n\n    this.__coord[0] = x * (this.__tile + this.__padding[0]) + (this.__padBorder ? this.__padding[0] : 0) + this.__trim[0];\n    this.__coord[1] = y * (this.__tileh + this.__padding[1]) + (this.__padBorder ? this.__padding[1] : 0) + this.__trim[1];\n    if (typeof w !== 'undefined' && typeof h !== 'undefined') {\n      this.__coord[2] = this.__trim[2] || w * this.__tile || this.__tile;\n      this.__coord[3] = this.__trim[3] || h * this.__tileh || this.__tileh;\n    }\n\n    this.trigger(\"Invalidate\");\n    return this;\n  },\n\n  /**@\n   * #.crop\n   * @comp Sprite\n   * @kind Method\n   * \n   * @sign public this .crop(Number x, Number y, Number w, Number h)\n   * @param x - Offset x position\n   * @param y - Offset y position\n   * @param w - New width\n   * @param h - New height\n   *\n   * If the entity needs to be smaller than the tile size, use this method to crop it.\n   *\n   * The values should be in pixels rather than tiles.\n   *\n   * @example\n   * ~~~\n   * Crafty.e(\"2D, DOM, Sprite\")\n   *   .crop(40, 40, 22, 23);\n   * ~~~\n   */\n  crop: function (x, y, w, h) {\n    var old = this._mbr || this.pos();\n    this.__trim = [];\n    this.__trim[0] = x;\n    this.__trim[1] = y;\n    this.__trim[2] = w;\n    this.__trim[3] = h;\n\n    this.__coord[0] += x;\n    this.__coord[1] += y;\n    this.__coord[2] = w;\n    this.__coord[3] = h;\n    this._w = w;\n    this._h = h;\n\n    this.trigger(\"Invalidate\", old);\n    return this;\n  }\n});"},"hash":"089cb2acbfc7593f234cafcc74f9275c"}