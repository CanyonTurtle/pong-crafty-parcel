{"dependencies":[],"generated":{"js":"/**\n * Spatial HashMap for broad phase collision\n *\n * @author Louis Stowasser\n */\n\n    /**@\n     * #Crafty.HashMap.constructor\n     * @comp Crafty.HashMap\n     * @kind Class\n     * \n     * @sign public void Crafty.HashMap([cellsize])\n     * @param cellsize - the cell size. If omitted, `cellsize` is 64.\n     *\n     * Set `cellsize`.\n     * And create `this.map`.\n     */\n    var cellsize,\n\n        HashMap = function (cell) {\n            cellsize = cell || 64;\n            this.map = {};\n\n            this.boundsDirty = false;\n            this.boundsHash = {\n                max: {\n                    x: -Infinity,\n                    y: -Infinity\n                },\n                min: {\n                    x: Infinity,\n                    y: Infinity\n                }\n            };\n            this.boundsCoords = {\n                max: {\n                    x: -Infinity,\n                    y: -Infinity\n                },\n                min: {\n                    x: Infinity,\n                    y: Infinity\n                }\n            };\n        },\n\n        SPACE = \" \",\n        keyHolder = {};\n\n    HashMap.prototype = {\n        /**@\n         * #Crafty.map.insert\n         * @comp Crafty.map\n         * @kind Method\n         * \n         * @sign public Object Crafty.map.insert(Object obj)\n         * @param obj - An entity to be inserted.\n         * @returns An object representing this object's entry in the HashMap\n         * \n         * `obj` is inserted in '.map' of the corresponding broad phase cells. An object of the following fields is returned.\n         * ~~~\n         * {\n         *   keys: the object that keep track of cells\n         *   obj: The inserted object\n         *   map: the HashMap object\n         * }\n         * ~~~\n         */\n        insert: function (obj) {\n            var keys = HashMap.key(obj),\n                entry = new Entry(keys, obj, this),\n                i = 0,\n                j,\n                hash;\n\n            //insert into all x buckets\n            for (i = keys.x1; i <= keys.x2; i++) {\n                //insert into all y buckets\n                for (j = keys.y1; j <= keys.y2; j++) {\n                    hash = (i << 16) ^ j;\n                    if (!this.map[hash]) this.map[hash] = [];\n                    this.map[hash].push(obj);\n                }\n            }\n\n            //mark map boundaries as dirty\n            this.boundsDirty = true;\n\n            return entry;\n        },\n\n        /**@\n         * #Crafty.map.search\n         * @comp Crafty.map\n         * @kind Method\n         * \n         * @sign public Object Crafty.map.search(Object rect[, Boolean filter])\n         * @param rect - the rectangular region to search for entities.\n         *               This object must contain the properties `_x`,`_y`,`_w`,`_h`.\n         * @param filter - If `false`, only performs a broad-phase collision check.  The default value is `true`.\n         * @return an (possibly empty) array of entities that have been found in the given region\n         *\n         * Search for entities in the given region, using their broadphase bounding rectangles.\n         *\n         * - If `filter` is `false`, just search for all the entries in the give `rect` region by broad phase collision. Entity may be returned duplicated.\n         * - If `filter` is `true`, filter the above results by checking that they actually overlap `rect`.\n         *\n         * The easier usage is with `filter == true`. For performance reason, you may use `filter == false`, and filter the result yourself. See examples in drawing.js and collision.js.\n         *\n         * @example\n         * ~~~\n         * // search for entities located in the current visible region of the viewport\n         * var results = Crafty.map.search(Crafty.viewport.rect());\n         * // iterate over all those entities\n         * var ent;\n         * for (var i = 0, l = results.length; i < l; ++i) {\n         *     // do something with an entity\n         *     ent = results[i];\n         *     Crafty.log('Found entity with id', ent.getId());\n         * }\n         * ~~~\n         */\n\n        search: function (rect, filter) {\n            var keys = HashMap.key(rect, keyHolder),\n                i, j, k, l, cell,\n                results = [];\n\n            if (filter === undefined) filter = true; //default filter to true\n\n            //search in all x buckets\n            for (i = keys.x1; i <= keys.x2; i++) {\n                //insert into all y buckets\n                for (j = keys.y1; j <= keys.y2; j++) {\n                    if ((cell = this.map[(i << 16) ^ j])) {\n                        for (k = 0; k < cell.length; k++)\n                            results.push(cell[k]);\n                    }\n                }\n            }\n\n            if (filter) {\n                var obj, id, finalresult = [],\n                    found = {};\n                //add unique elements to lookup table with the entity ID as unique key\n                for (i = 0, l = results.length; i < l; i++) {\n                    obj = results[i];\n                    if (!obj) continue; //skip if deleted\n                    id = obj[0]; //unique ID\n                    obj = obj._cbr || obj._mbr || obj;\n                    //check if not added to hash and that actually intersects\n                    if (!found[id] && obj._x < rect._x + rect._w && obj._x + obj._w > rect._x &&\n                                      obj._y < rect._y + rect._h && obj._y + obj._h > rect._y)\n                        found[id] = results[i];\n                }\n\n                //loop over lookup table and copy to final array\n                for (obj in found) finalresult.push(found[obj]);\n\n                return finalresult;\n            } else {\n                return results;\n            }\n        },\n\n        /**@\n         * #Crafty.map.remove\n         * @comp Crafty.map\n         * @kind Method\n         * \n         * @sign public void Crafty.map.remove(Entry entry)\n         * @param entry - An entry to remove from the hashmap\n         *\n         * Remove an entry from the broad phase map.\n         *\n         * @example\n         * ~~~\n         * Crafty.map.remove(e);\n         * ~~~\n         */\n        remove: function (entry) {\n            var keys = entry.keys;\n            var obj = entry.obj;\n            var i = 0,\n                j, hash;\n\n            //search in all x buckets\n            for (i = keys.x1; i <= keys.x2; i++) {\n                //insert into all y buckets\n                for (j = keys.y1; j <= keys.y2; j++) {\n                    hash = (i << 16) ^ j;\n\n                    if (this.map[hash]) {\n                        var cell = this.map[hash],\n                            m, n = cell.length;\n                        //loop over objs in cell and delete\n                        for (m = 0; m < n; m++)\n                            if (cell[m] && cell[m][0] === obj[0])\n                                cell.splice(m, 1);\n                    }\n                }\n            }\n\n            //mark map boundaries as dirty\n            this.boundsDirty = true;\n        },\n\n        /**@\n         * #Crafty.map.refresh\n         * @comp Crafty.map\n         * @kind Method\n         * \n         * @sign public void Crafty.map.refresh(Entry entry)\n         * @param entry - An entry to update\n         *\n         * Update an entry's keys, and its position in the broad phrase map.\n         *\n         * @example\n         * ~~~\n         * Crafty.map.refresh(e);\n         * ~~~\n         */\n        refresh: function (entry) {\n            var keys = entry.keys;\n            var obj = entry.obj;\n            var cell, i, j, m, n;\n\n            //First delete current object from appropriate cells\n            for (i = keys.x1; i <= keys.x2; i++) {\n                for (j = keys.y1; j <= keys.y2; j++) {\n                    cell = this.map[(i << 16) ^ j];\n                    if (cell) {\n                        n = cell.length;\n                        //loop over objs in cell and delete\n                        for (m = 0; m < n; m++)\n                            if (cell[m] && cell[m][0] === obj[0])\n                                cell.splice(m, 1);\n                    }\n                }\n            }\n\n            //update keys\n            HashMap.key(obj, keys);\n\n            //insert into all rows and columns\n            for (i = keys.x1; i <= keys.x2; i++) {\n                for (j = keys.y1; j <= keys.y2; j++) {\n                    cell = this.map[(i << 16) ^ j];\n                    if (!cell) cell = this.map[(i << 16) ^ j] = [];\n                    cell.push(obj);\n                }\n            }\n\n            //mark map boundaries as dirty\n            this.boundsDirty = true;\n\n            return entry;\n        },\n\n\n        /**@\n         * #Crafty.map.boundaries\n         * @comp Crafty.map\n         * @kind Method\n         * \n         * @sign public Object Crafty.map.boundaries()\n         * @returns An object with the following structure, which represents an MBR which contains all entities\n         *\n         * Note that the returned object is a reference to the internally used object.\n         * Use `Crafty.clone` to get a copy instead.\n         *\n         * ~~~\n         * {\n         *   min: {\n         *     x: val_x,\n         *     y: val_y\n         *   },\n         *   max: {\n         *     x: val_x,\n         *     y: val_y\n         *   }\n         * }\n         * ~~~\n         */\n        boundaries: function() {\n            this._updateBoundaries();\n            return this.boundsCoords;\n        },\n\n        /**\n         * #Crafty.map._keyBoundaries\n         * @comp Crafty.map\n         * @kind Method\n         * \n         * @sign private Object Crafty.map._keyBoundaries()\n         * @returns An object with the following structure, which represents an MBR which contains all hash keys\n         *\n         * Find boundaries of row/col cell grid keys instead of actual x/y pixel coordinates.\n         *\n         * ~~~\n         * {\n         *   min: {\n         *     x: val_x,\n         *     y: val_y\n         *   },\n         *   max: {\n         *     x: val_x,\n         *     y: val_y\n         *   }\n         * }\n         * ~~~\n         */\n        _keyBoundaries: function() {\n            this._updateBoundaries();\n            return this.boundsHash;\n        },\n\n        _updateBoundaries: function() {\n            // update map boundaries if they were changed\n            if (!this.boundsDirty) return;\n\n            var hash = this.boundsHash;\n            hash.max.x = -Infinity;\n            hash.max.y = -Infinity;\n            hash.min.x = Infinity;\n            hash.min.y = Infinity;\n\n            var coords = this.boundsCoords;\n            coords.max.x = -Infinity;\n            coords.max.y = -Infinity;\n            coords.min.x = Infinity;\n            coords.min.y = Infinity;\n\n            var k, ent;\n            //Using broad phase hash to speed up the computation of boundaries.\n            for (var h in this.map) {\n                if (!this.map[h].length) continue;\n\n                //broad phase coordinate\n                var i = h >> 16,\n                    j = (h << 16) >> 16;\n                if (j < 0) {\n                    i = i ^ -1;\n                }\n                if (i >= hash.max.x) {\n                    hash.max.x = i;\n                    for (k in this.map[h]) {\n                        ent = this.map[h][k];\n                        //make sure that this is a Crafty entity\n                        if (typeof ent === 'object' && 'requires' in ent) {\n                            coords.max.x = Math.max(coords.max.x, ent.x + ent.w);\n                        }\n                    }\n                }\n                if (i <= hash.min.x) {\n                    hash.min.x = i;\n                    for (k in this.map[h]) {\n                        ent = this.map[h][k];\n                        if (typeof ent === 'object' && 'requires' in ent) {\n                            coords.min.x = Math.min(coords.min.x, ent.x);\n                        }\n                    }\n                }\n                if (j >= hash.max.y) {\n                    hash.max.y = j;\n                    for (k in this.map[h]) {\n                        ent = this.map[h][k];\n                        if (typeof ent === 'object' && 'requires' in ent) {\n                            coords.max.y = Math.max(coords.max.y, ent.y + ent.h);\n                        }\n                    }\n                }\n                if (j <= hash.min.y) {\n                    hash.min.y = j;\n                    for (k in this.map[h]) {\n                        ent = this.map[h][k];\n                        if (typeof ent === 'object' && 'requires' in ent) {\n                            coords.min.y = Math.min(coords.min.y, ent.y);\n                        }\n                    }\n                }\n            }\n\n            // mark map boundaries as clean\n            this.boundsDirty = false;\n        },\n\n\n        /**@\n         * #Crafty.map.traverseRay\n         * @comp Crafty.map\n         * @kind Method\n         * \n         * @sign public void Crafty.map.traverseRay(Object origin, Object direction, Function callback)\n         * @param origin - the point of origin from which the ray will be cast. The object must contain the properties `_x` and `_y`.\n         * @param direction - the direction the ray will be cast. It must be normalized. The object must contain the properties `x` and `y`.\n         * @param callback - a callback that will be called for each object that is encountered along the ray.\n         *                   This function is called with two arguments: The first one represents the object encountered;\n         *                   the second one represents the distance up to which all objects have been reported so far.\n         *                   The callback can return a truthy value in order to stop the traversal early.\n         *\n         * Traverse the spatial map in the direction of the supplied ray.\n         *\n         * Given the `origin` and `direction` the ray is cast and the `callback` is called\n         * for each object encountered in map cells traversed by the ray.\n         *\n         * The callback is called for each object that may be intersected by the ray.\n         * Whether an actual intersection occurs shall be determined by the callback's implementation.\n         *\n         * @example\n         * ~~~\n         * Crafty.e(\"2D\")\n         *       .setName('First entity')\n         *       .attr({x: 0, y: 0, w: 10, h: 10});\n         *\n         * Crafty.e(\"2D\")\n         *       .setName('Second entity')\n         *       .attr({x: 20, y: 20, w: 10, h: 10});\n         *\n         * var origin = {_x: -25, _y: -25};\n         * var direction = new Crafty.math.Vector2D(1, 1).normalize();\n         *\n         * Crafty.map.traverseRay(origin, direction, function(ent, processedDistance) {\n         *   Crafty.log('Encountered entity named', ent.getName()); // logs 'First entity'\n         *   Crafty.log('All entities up to', processedDistance, 'px away have been reported thus far.');\n         *   Crafty.log('Stopping traversal after encountering the first entity.');\n         *   return true;\n         * });\n         * ~~~\n         */\n\n        // See [this tutorial](http://www.flipcode.com/archives/Raytracing_Topics_Techniques-Part_4_Spatial_Subdivisions.shtml) and linked materials\n        // Segment-segment intersection is described here: http://stackoverflow.com/a/565282/3041008\n        //\n        // origin = {_x, _y}\n        // direction = {x, y}, must be normalized\n        //\n        //\n        // # Let\n        //  edge = end - start\n        //  edge x edge == 0\n        //\n        // # Segment - segment intersection equation\n        //  origin + d * direction = start + e * edge\n        //\n        // # Solving for d\n        //  (origin + d * direction) x edge = (start + e * edge) x edge\n        //  d = (start − origin) × edge / (direction × edge)\n        //\n        //      (start.x - origin.x) * edge.y - (start.y - origin.y) * edge.x\n        //  d = --------------------------------------------------------------\n        //               direction.x * edge.y - direction.y * edge.x\n        //\n        //\n        // # In case ray intersects vertical cell grid edge\n        // start = (x, 0)\n        // edge = (0, 1)\n        //\n        //      start.x - origin.x\n        //  d = -------------------\n        //         direction.x\n        //\n        // # In case ray intersects horizontal cell grid edge\n        // start = (0, y)\n        // edge = (1, 0)\n        //\n        //      start.y - origin.y\n        //  d = -------------------\n        //         direction.y\n        //\n        traverseRay: function(origin, direction, callback) {\n            var dirX = direction.x,\n                dirY = direction.y;\n            // copy input data\n            // TODO maybe allow HashMap.key search with point only\n            origin = {\n                _x: origin._x,\n                _y: origin._y,\n                _w: 0,\n                _h: 0\n            };\n\n\n            var keyBounds = this._keyBoundaries();\n            var keys = HashMap.key(origin, keyHolder);\n\n            // calculate col & row cell indices\n            var currentCol = keys.x1,\n                currentRow = keys.y1;\n            var minCol = keyBounds.min.x,\n                minRow = keyBounds.min.y,\n                maxCol = keyBounds.max.x,\n                maxRow = keyBounds.max.y;\n            // direction to traverse cells\n            var stepCol = dirX > 0 ? 1 : (dirX < 0 ? -1 : 0),\n                stepRow = dirY > 0 ? 1 : (dirY < 0 ? -1 : 0);\n\n\n            // first, next cell edge in absolute coordinates\n            var firstCellEdgeX = (dirX >= 0) ? (currentCol + 1) * cellsize : currentCol * cellsize,\n                firstCellEdgeY = (dirY >= 0) ? (currentRow + 1) * cellsize : currentRow * cellsize;\n\n            // distance from origin to previous cell edge\n            var previousDistance = -Infinity;\n\n            // distances to next horizontal and vertical cell edge\n            var deltaDistanceX = 0, // distance for the ray to be advanced to cross a whole cell horizontally\n                deltaDistanceY = 0, // distance for the ray to be advanced to cross a whole cell vertically\n                nextDistanceX = Infinity, // distance we can advance(increase magnitude) ray until we advance to next horizontal cell\n                nextDistanceY = Infinity; // distance we can advance(increase magnitude) ray until we advance to next vertical cell\n\n            var norm;\n            if (dirX !== 0) {\n                norm = 1.0 / dirX;\n                nextDistanceX = (firstCellEdgeX - origin._x) * norm;\n                deltaDistanceX = (cellsize * stepCol) * norm;\n            }\n            if (dirY !== 0) {\n                norm = 1.0 / dirY;\n                nextDistanceY = (firstCellEdgeY - origin._y) * norm;\n                deltaDistanceY = (cellsize * stepRow) * norm;\n            }\n\n\n            // advance starting cell to be inside of map bounds\n            while ((stepCol === 1 && currentCol < minCol && minCol !== Infinity) || (stepCol === -1 && currentCol > maxCol && maxCol !== -Infinity) ||\n                   (stepRow === 1 && currentRow < minRow && minRow !== Infinity) || (stepRow === -1 && currentRow > maxRow && maxRow !== -Infinity)) {\n\n                // advance to closest cell\n                if (nextDistanceX < nextDistanceY) {\n                    previousDistance = nextDistanceX;\n\n                    currentCol += stepCol;\n                    nextDistanceX += deltaDistanceX;\n                } else {\n                    previousDistance = nextDistanceY;\n\n                    currentRow += stepRow;\n                    nextDistanceY += deltaDistanceY;\n                }\n            }\n\n            var cell;\n            // traverse over cells\n            // TODO: maybe change condition to `while (currentCol !== endX) || (currentRow !== endY)`\n            while ((minCol <= currentCol && currentCol <= maxCol) &&\n                   (minRow <= currentRow && currentRow <= maxRow)) {\n\n                // process cell\n                if ((cell = this.map[(currentCol << 16) ^ currentRow])) {\n                    // check each object inside this cell\n                    for (var k = 0; k < cell.length; k++) {\n                        // if supplied callback returns true, abort traversal\n                        if (callback(cell[k], previousDistance))\n                            return;\n                    }\n                }\n\n                // advance to closest cell\n                if (nextDistanceX < nextDistanceY) {\n                    previousDistance = nextDistanceX;\n\n                    currentCol += stepCol;\n                    nextDistanceX += deltaDistanceX;\n                } else {\n                    previousDistance = nextDistanceY;\n\n                    currentRow += stepRow;\n                    nextDistanceY += deltaDistanceY;\n                }\n            }\n        }\n\n    };\n\n    /**@\n     * #Crafty.HashMap\n     * @category 2D\n     * @kind Class\n     * \n     * Broad-phase collision detection engine. See background information at\n     *\n     * - [N Tutorial B - Broad-Phase Collision](http://www.metanetsoftware.com/technique/tutorialB.html)\n     * - [Broad-Phase Collision Detection with CUDA](http://http.developer.nvidia.com/GPUGems3/gpugems3_ch32.html)\n     * @see Crafty.map\n     */\n\n    /**@\n     * #Crafty.HashMap.key\n     * @comp Crafty.HashMap\n     * @kind Method\n     * \n     * @sign public Object Crafty.HashMap.key(Object obj)\n     * @param obj - an Object that has .mbr() or _x, _y, _w and _h.\n     *\n     * Get the rectangular region (in terms of the grid, with grid size `cellsize`), where the object may fall in. This region is determined by the object's bounding box.\n     * The `cellsize` is 64 by default.\n     *\n     * @see Crafty.HashMap.constructor\n     */\n    HashMap.key = function (obj, keys) {\n        obj = obj._cbr || obj._mbr || obj;\n        keys = keys || {};\n\n        keys.x1 = Math.floor(obj._x / cellsize);\n        keys.y1 = Math.floor(obj._y / cellsize);\n        keys.x2 = Math.floor((obj._w + obj._x) / cellsize);\n        keys.y2 = Math.floor((obj._h + obj._y) / cellsize);\n        return keys;\n    };\n\n    HashMap.hash = function (keys) {\n        return keys.x1 + SPACE + keys.y1 + SPACE + keys.x2 + SPACE + keys.y2;\n    };\n\n    function Entry(keys, obj, map) {\n        this.keys = keys;\n        this.map = map;\n        this.obj = obj;\n    }\n\n    Entry.prototype = {\n        update: function (rect) {\n            //check if buckets change\n            if (HashMap.hash(HashMap.key(rect, keyHolder)) !== HashMap.hash(this.keys)) {\n                this.map.refresh(this);\n            }\n        }\n    };\n\n    module.exports = HashMap;\n"},"hash":"470dbd9a4a6b3712a7e0ff4fbf2cf14c"}