{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js');\n\n\n/**@\n * #CanvasLayer\n * @category Graphics\n * @kind System\n *\n * An object for creating the canvas layer system.\n *\n * Mostly contains private methods to draw entities on a canvas element.\n */\nCrafty._registerLayerTemplate(\"Canvas\", {\n    type: \"Canvas\",\n    \n    options: {\n        xResponse: 1,\n        yResponse: 1,\n        scaleResponse: 1,\n        z: 0\n    },\n    \n    _dirtyRects: [],\n    _changedObjs: [],\n    layerCount: 0,\n    _dirtyViewport: false,\n\n    // Sort function for rendering in the correct order\n    _sort: function(a, b) {\n        return a._globalZ - b._globalZ;\n    },\n\n    /**@\n     * #.dirty\n     * @comp CanvasLayer\n     * @kind Method\n     * @private\n     * \n     * @sign public .dirty(ent)\n     * @param ent - The entity to add\n     *\n     * Add an entity to the list of Canvas objects that need redrawing\n     */\n    dirty: function dirty(ent) {\n        this._changedObjs.push(ent);\n    },\n    \n    /**@\n     * #.attach\n     * @comp CanvasLayer\n     * @kind Method\n     * @private\n     * \n     * @sign public .attach(ent)\n     * @param ent - The entity to add\n     *\n     * Sets the entity's draw context to this layer\n     */\n    attach: function attach(ent) {\n        ent._drawContext = this.context;\n        //increment the number of canvas objs\n        this.layerCount++;\n    },\n    \n    /**@\n     * #.detach\n     * @comp CanvasLayer\n     * @kind Method\n     * @private\n     * \n     * @sign public .detach(ent)\n     * @param ent - The entity to detach\n     *\n     * Removes an entity to the list of Canvas objects to draw\n     */\n    detach: function detach(ent) {\n        this.dirty(ent);\n        ent._drawContext = null;\n        //decrement the number of canvas objs\n        this.layerCount--;\n    },\n    \n\n    /**@\n     * #.context\n     * @comp CanvasLayer\n     * @kind Property\n     *\n     * This will return the 2D context associated with the canvas layer's canvas element.\n     */\n    context: null,\n\n    /**@\n     * #._canvas\n     * @comp CanvasLayer\n     * @kind Property\n     * @private\n     *\n     * The canvas element associated with the canvas layer.\n     */\n     _canvas: null,\n\n    // When the system is first created, create the necessary canvas element and initial state\n    // Bind to the necessary events\n    init: function () {\n        //check if canvas is supported\n        if (!Crafty.support.canvas) {\n            Crafty.trigger(\"NoCanvas\");\n            Crafty.stop();\n            return;\n        }\n\n        // set referenced objects to initial values -- necessary to avoid shared state between systems\n        this._dirtyRects = [];\n        this._changedObjs = [];\n\n        //create an empty canvas element\n        var c;\n        c = document.createElement(\"canvas\");\n        c.width = Crafty.viewport.width;\n        c.height = Crafty.viewport.height;\n        c.style.position = 'absolute';\n        c.style.left = \"0px\";\n        c.style.top = \"0px\";\n        c.style.zIndex = this.options.z;\n\n        Crafty.stage.elem.appendChild(c);\n        this.context = c.getContext('2d');\n        this._canvas = c;\n\n        //Set any existing transformations\n        var zoom = Crafty.viewport._scale;\n        if (zoom !== 1)\n            this.context.scale(zoom, zoom);\n\n        // Set pixelart to current status, and listen for changes\n        this._setPixelart(Crafty._pixelartEnabled);\n        this.uniqueBind(\"PixelartSet\", this._setPixelart);\n\n        //Bind rendering of canvas context (see drawing.js)\n        this.uniqueBind(\"RenderScene\", this._render);\n        \n        this.uniqueBind(\"ViewportResize\", this._resize);\n\n        this.bind(\"InvalidateViewport\", function () {\n            this._dirtyViewport = true;\n        });\n        \n        Crafty._addDrawLayerInstance(this);\n    },\n\n    // When the system is destroyed, remove related resources\n    remove: function() {\n\n        this._canvas.parentNode.removeChild(this._canvas);\n        Crafty._removeDrawLayerInstance(this);\n    },\n\n    _render: function() {\n        var dirtyViewport = this._dirtyViewport,\n            l = this._changedObjs.length,\n            ctx = this.context;\n        if (!l && !dirtyViewport) {\n            return;\n        }\n        \n        // Set the camera transforms from the combination of the current viewport parameters and this layers \n        var cameraOptions = this.options;\n        if (dirtyViewport && cameraOptions) {\n            var view = this._viewportRect();\n            var scale = view._scale; \n            var dx = -view._x * scale;\n            var dy = -view._y * scale;\n            ctx.setTransform(scale, 0, 0, scale, Math.round(dx), Math.round(dy) );\n        }\n\n        //if the amount of changed objects is over 60% of the total objects\n        //do the naive method redrawing\n        // TODO: I'm not sure this condition really makes that much sense!\n        if (l / this.layerCount > 0.6 || dirtyViewport) {\n            this._drawAll();\n        } else {\n            this._drawDirty();\n        }\n        //Clean up lists etc\n        this._clean();\n    },\n\n    /**@\n     * #._drawDirty\n     * @comp CanvasLayer\n     * @kind Method\n     * @private\n     * \n     * @sign public ._drawDirty()\n     *\n     * - Triggered by the \"RenderScene\" event\n     * - If the number of rects is over 60% of the total number of objects\n     *  do the naive method redrawing `CanvasLayer.drawAll` instead\n     * - Otherwise, clear the dirty regions, and redraw entities overlapping the dirty regions.\n     *\n     * @see Canvas#.draw\n     */\n    _drawDirty: function (view) {\n        view = view || this._viewportRect();\n        var i, j, q, rect,len, obj,\n            changed = this._changedObjs,\n            l = changed.length,\n            dirty = this._dirtyRects,\n            rectManager = Crafty.rectManager,\n            overlap = rectManager.overlap,\n            ctx = this.context,\n            dupes = [],\n            objs = [];\n        \n        // Canvas works better with integral coordinates where possible\n        view = rectManager.integerBounds(view);\n        \n        // Calculate _dirtyRects from all changed objects, then merge some overlapping regions together\n        for (i = 0; i < l; i++) {\n            this._createDirty(changed[i]);\n        }\n        rectManager.mergeSet(dirty);\n\n\n        l = dirty.length;\n\n        // For each dirty rectangle, find entities near it, and draw the overlapping ones\n        for (i = 0; i < l; ++i) { //loop over every dirty rect\n            rect = dirty[i];\n            dupes.length = 0;\n            objs.length = 0;\n            if (!rect) continue;\n\n            // Find the smallest rectangle with integer coordinates that encloses rect\n            rect = rectManager.integerBounds(rect);\n\n            // If a dirty rect doesn't overlap with the viewport, skip to the next one\n            if (!overlap(rect, view)) continue;\n\n            //search for ents under dirty rect\n            q = Crafty.map.search(rect, false);\n\n            //clear the rect from the main canvas\n            ctx.clearRect(rect._x, rect._y, rect._w, rect._h);\n\n            //Then clip drawing region to dirty rectangle\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(rect._x, rect._y, rect._w, rect._h);\n            ctx.clip();\n\n            // Loop over found objects removing dupes and adding visible canvas objects to array\n            for (j = 0, len = q.length; j < len; ++j) {\n                obj = q[j];\n\n                if (dupes[obj[0]] || !obj._visible || (obj._drawLayer !== this) )\n                    continue;\n                dupes[obj[0]] = true;\n                objs.push(obj);\n            }\n\n            // Sort objects by z level\n            objs.sort(this._sort);\n\n            // Then draw each object in that order\n            for (j = 0, len = objs.length; j < len; ++j) {\n                obj = objs[j];\n                var area = obj._mbr || obj;\n                if (overlap(area, rect))\n                    obj.draw();\n                obj._changed = false;\n            }\n\n            // Close rectangle clipping\n            ctx.closePath();\n            ctx.restore();\n\n        }\n\n        // Draw dirty rectangles for debugging, if that flag is set\n        if (this.debugDirty === true) {\n            ctx.strokeStyle = 'red';\n            for (i = 0, l = dirty.length; i < l; ++i) {\n                rect = dirty[i];\n                ctx.strokeRect(rect._x, rect._y, rect._w, rect._h);\n            }\n        }\n\n    },\n\n    /**@\n     * #._drawAll\n     * @comp CanvasLayer\n     * @kind Method\n     * @private\n     * \n     * @sign public CanvasLayer.drawAll([Object rect])\n     * @param rect - a rectangular region {_x: x_val, _y: y_val, _w: w_val, _h: h_val}\n     *\n     * - If rect is omitted, redraw within the viewport\n     * - If rect is provided, redraw within the rect\n     */\n    _drawAll: function (rect) {\n        rect = rect || this._viewportRect();\n        rect = Crafty.rectManager.integerBounds(rect);\n        var q = Crafty.map.search(rect),\n            i = 0,\n            l = q.length,\n            ctx = this.context,\n            current;\n\n        ctx.clearRect(rect._x, rect._y, rect._w, rect._h);\n\n        //sort the objects by the global Z\n        q.sort(this._sort);\n        for (; i < l; i++) {\n            current = q[i];\n            if (current._visible && current._drawContext === this.context) {\n                current.draw(this.context);\n                current._changed = false;\n            }\n        }\n    },\n\n    debug: function() {\n        Crafty.log(this._changedObjs);\n    },\n\n    /** cleans up current dirty state, stores stale state for future passes */\n    _clean: function () {\n        var rect, obj, i, l,\n            changed = this._changedObjs;\n         for (i = 0, l = changed.length; i < l; i++) {\n             obj = changed[i];\n             rect = obj._mbr || obj;\n             if (typeof obj.staleRect === 'undefined')\n                 obj.staleRect = {};\n             obj.staleRect._x = rect._x;\n             obj.staleRect._y = rect._y;\n             obj.staleRect._w = rect._w;\n             obj.staleRect._h = rect._h;\n\n             obj._changed = false;\n         }\n         changed.length = 0;\n         this._dirtyRects.length = 0;\n         this._dirtyViewport = false;\n\n    },\n\n     /** Takes the current and previous position of an object, and pushes the dirty regions onto the stack\n      *  If the entity has only moved/changed a little bit, the regions are squashed together */\n    _createDirty: function (obj) {\n\n        var rect = obj._mbr || obj,\n            dirty = this._dirtyRects,\n            rectManager = Crafty.rectManager;\n\n        if (obj.staleRect) {\n            //If overlap, merge stale and current position together, then return\n            //Otherwise just push stale rectangle\n            if (rectManager.overlap(obj.staleRect, rect)) {\n                rectManager.merge(obj.staleRect, rect, obj.staleRect);\n                dirty.push(obj.staleRect);\n                return;\n            } else {\n              dirty.push(obj.staleRect);\n            }\n        }\n\n        // We use the intermediate \"currentRect\" so it can be modified without messing with obj\n        obj.currentRect._x = rect._x;\n        obj.currentRect._y = rect._y;\n        obj.currentRect._w = rect._w;\n        obj.currentRect._h = rect._h;\n        dirty.push(obj.currentRect);\n\n    },\n\n\n    // Resize the canvas element to the current viewport\n    _resize: function() {\n        var c = this._canvas;\n        c.width = Crafty.viewport.width;\n        c.height = Crafty.viewport.height;\n\n    },\n\n    _setPixelart: function(enabled) {\n        var context = this.context;\n        context.imageSmoothingEnabled = !enabled;\n        context.mozImageSmoothingEnabled = !enabled;\n        context.webkitImageSmoothingEnabled = !enabled;\n        context.oImageSmoothingEnabled = !enabled;\n        context.msImageSmoothingEnabled = !enabled;\n    }\n\n});\n"},"hash":"9c332dcf0cb7c13a3670a265f5acdc50"}