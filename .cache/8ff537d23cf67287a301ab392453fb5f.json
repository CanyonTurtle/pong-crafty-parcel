{"dependencies":[{"name":"../core/core.js","loc":{"line":1,"column":21}}],"generated":{"js":"var Crafty = require('../core/core.js');\n\n\n\n// This is used to define getters and setters for Motion properties\n// For instance\n//      __motionProp(entity, \"a\", \"x\", true) \n// will define a getter for `ax` which accesses an underlying private property `_ax`\n// If the `setter` property is false, setting a value will be a null-op\nvar __motionProp = function(self, prefix, prop, setter) {\n    var publicProp = prefix + prop;\n    var privateProp = \"_\" + publicProp;\n\n    var motionEvent = { key: \"\", oldValue: 0};\n    // getters & setters for public property\n    if (setter) {\n        Crafty.defineField(self, publicProp, function() { return this[privateProp]; }, function(newValue) {\n            var oldValue = this[privateProp];\n            if (newValue !== oldValue) {\n                this[privateProp] = newValue;\n\n                motionEvent.key = publicProp;\n                motionEvent.oldValue = oldValue;\n                this.trigger(\"MotionChange\", motionEvent);\n            }\n        });\n    } else {\n        Crafty.defineField(self, publicProp, function() { return this[privateProp]; }, function(newValue) {});\n    }\n\n    // hide private property\n    Object.defineProperty(self, privateProp, {\n        value : 0,\n        writable : true,\n        enumerable : false,\n        configurable : false\n    });\n};\n\n// This defines an alias for a pair of underlying properties which represent the components of a vector\n// It takes an object with vector methods, and redefines its x/y properties as getters and setters to properties of self\n// This allows you to use the vector's special methods to manipulate the entity's properties, \n// while still allowing you to manipulate those properties directly if performance matters\nvar __motionVector = function(self, prefix, setter, vector) {\n    var publicX = prefix + \"x\",\n        publicY = prefix + \"y\",\n        privateX = \"_\" + publicX,\n        privateY = \"_\" + publicY;\n\n    if (setter) {\n        Crafty.defineField(vector, \"x\", function() { return self[privateX]; }, function(v) { self[publicX] = v; });\n        Crafty.defineField(vector, \"y\", function() { return self[privateY]; }, function(v) { self[publicY] = v; });\n    } else {\n        Crafty.defineField(vector, \"x\", function() { return self[privateX]; }, function(v) {});\n        Crafty.defineField(vector, \"y\", function() { return self[privateY]; }, function(v) {});\n    }\n    if (Object.seal) { Object.seal(vector); }\n\n    return vector;\n};\n\n/**@\n * #AngularMotion\n * @category 2D\n * @kind Component\n * \n * @trigger Rotated - When entity has rotated due to angular velocity/acceleration a Rotated event is triggered. - Number - Old rotation\n * @trigger NewRotationDirection - When entity has changed rotational direction due to rotational velocity a NewRotationDirection event is triggered. The event is triggered once, if direction is different from last frame. - -1 | 0 | 1 - New direction\n * @trigger MotionChange - When a motion property has changed a MotionChange event is triggered. - { key: String, oldValue: Number } - Motion property name and old value\n *\n * Component that allows rotating an entity by applying angular velocity and acceleration.\n * All angular motion values are expressed in degrees per second (e.g. an entity with `vrotation` of 10 will rotate 10 degrees each second).\n */\nCrafty.c(\"AngularMotion\", {\n    /**@\n     * #.vrotation\n     * @comp AngularMotion\n     * @kind Property\n     * \n     * A property for accessing/modifying the angular(rotational) velocity. \n     * The velocity remains constant over time, unless the acceleration increases the velocity.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, AngularMotion\");\n     *\n     * var vrotation = ent.vrotation; // retrieve the angular velocity\n     * ent.vrotation += 1; // increase the angular velocity\n     * ent.vrotation = 0; // reset the angular velocity\n     * ~~~\n     */\n    _vrotation: 0,\n\n    /**@\n     * #.arotation\n     * @comp AngularMotion\n     * @kind Property\n     * \n     * A property for accessing/modifying the angular(rotational) acceleration. \n     * The acceleration increases the velocity over time, resulting in ever increasing speed.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, AngularMotion\");\n     *\n     * var arotation = ent.arotation; // retrieve the angular acceleration\n     * ent.arotation += 1; // increase the angular acceleration\n     * ent.arotation = 0; // reset the angular acceleration\n     * ~~~\n     */\n    _arotation: 0,\n\n    /**@\n     * #.drotation\n     * @comp AngularMotion\n     * @kind Property\n     * \n     * A number that reflects the change in rotation (difference between the old & new rotation) that was applied in the last frame.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, AngularMotion\");\n     *\n     * var drotation = ent.drotation; // the change of rotation in the last frame\n     * ~~~\n     */\n    _drotation: 0,\n\n    init: function () {\n        this.requires(\"2D\");\n\n        __motionProp(this, \"v\", \"rotation\", true);\n        __motionProp(this, \"a\", \"rotation\", true);\n        __motionProp(this, \"d\", \"rotation\", false);\n\n        this.__oldRotationDirection = 0;\n\n        this.bind(\"EnterFrame\", this._angularMotionTick);\n    },\n    remove: function(destroyed) {\n        this.unbind(\"EnterFrame\", this._angularMotionTick);\n    },\n\n    /**@\n     * #.resetAngularMotion\n     * @comp AngularMotion\n     * @kind Method\n     * \n     * @sign public this .resetAngularMotion()\n     * \n     * Reset all motion (resets velocity, acceleration, motionDelta).\n     */\n    resetAngularMotion: function() {\n        this._drotation = 0;\n        this.vrotation = 0;\n        this.arotation = 0;\n\n        return this;\n    },\n\n    /*\n     * s += v * Δt + (0.5 * a) * Δt * Δt\n     * v += a * Δt\n     */\n    _angularMotionTick: function(frameData) {\n        var dt = frameData.dt / 1000; // Time in s\n        var oldR = this._rotation,\n            vr = this._vrotation,\n            ar = this._arotation;\n\n        // s += v * Δt + (0.5 * a) * Δt * Δt\n        var newR = oldR + vr * dt + 0.5 * ar * dt * dt;\n        // v += a * Δt\n        this.vrotation = vr + ar * dt;\n\n        // Check if direction of velocity has changed\n        var _vr = this._vrotation, dvr = _vr ? (_vr<0 ? -1:1):0; // Quick implementation of Math.sign\n        if (this.__oldRotationDirection !== dvr) {\n            this.__oldRotationDirection = dvr;\n            this.trigger('NewRotationDirection', dvr);\n        }\n\n        // Check if velocity has changed\n        // Δs = s[t] - s[t-1]\n        this._drotation = newR - oldR;\n        if (this._drotation !== 0) {\n            this.rotation = newR;\n            this.trigger('Rotated', oldR);\n        }\n    }\n});\n\n/**@\n * #Motion\n * @category 2D\n * @kind Component\n * \n * @trigger Moved - When entity has moved due to velocity/acceleration on either x or y axis a Moved event is triggered. If the entity has moved on both axes for diagonal movement the event is triggered twice. - { axis: 'x' | 'y', oldValue: Number } - Old position\n * @trigger NewDirection - When entity has changed direction due to velocity on either x or y axis a NewDirection event is triggered. The event is triggered once, if direction is different from last frame. - { x: -1 | 0 | 1, y: -1 | 0 | 1 } - New direction\n * @trigger MotionChange - When a motion property has changed a MotionChange event is triggered. - { key: String, oldValue: Number } - Motion property name and old value\n *\n * Component that allows moving an entity by applying linear velocity and acceleration.\n * All linear motion values are expressed in pixels per second (e.g. an entity with `vx` of 1 will move 1px on the x axis each second).\n *\n * @note Several methods return Vector2D objects that dynamically reflect the entity's underlying properties.  If you want a static copy instead, use the vector's `clone()` method.\n */\nCrafty.c(\"Motion\", {\n    /**@\n     * #.vx\n     * @comp Motion\n     * @kind Property\n     * \n     * A property for accessing/modifying the linear velocity in the x axis.\n     * The velocity remains constant over time, unless the acceleration changes the velocity.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, Motion\");\n     *\n     * var vx = ent.vx; // retrieve the linear velocity in the x axis\n     * ent.vx += 1; // increase the linear velocity in the x axis\n     * ent.vx = 0; // reset the linear velocity in the x axis\n     * ~~~\n     */\n    _vx: 0,\n\n    /**@\n     * #.vy\n     * @comp Motion\n     * @kind Property\n     * \n     * A property for accessing/modifying the linear velocity in the y axis.\n     * The velocity remains constant over time, unless the acceleration changes the velocity.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, Motion\");\n     *\n     * var vy = ent.vy; // retrieve the linear velocity in the y axis\n     * ent.vy += 1; // increase the linear velocity in the y axis\n     * ent.vy = 0; // reset the linear velocity in the y axis\n     * ~~~\n     */\n    _vy: 0,\n\n    /**@\n     * #.ax\n     * @comp Motion\n     * @kind Property\n     * \n     * A property for accessing/modifying the linear acceleration in the x axis.\n     * The acceleration changes the velocity over time.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, Motion\");\n     *\n     * var ax = ent.ax; // retrieve the linear acceleration in the x axis\n     * ent.ax += 1; // increase the linear acceleration in the x axis\n     * ent.ax = 0; // reset the linear acceleration in the x axis\n     * ~~~\n     */\n    _ax: 0,\n\n    /**@\n     * #.ay\n     * @comp Motion\n     * @kind Property\n     * \n     * A property for accessing/modifying the linear acceleration in the y axis.\n     * The acceleration changes the velocity over time.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, Motion\");\n     *\n     * var ay = ent.ay; // retrieve the linear acceleration in the y axis\n     * ent.ay += 1; // increase the linear acceleration in the y axis\n     * ent.ay = 0; // reset the linear acceleration in the y axis\n     * ~~~\n     */\n    _ay: 0,\n\n    /**@\n     * #.dx\n     * @comp Motion\n     * @kind Property\n     * \n     * A number that reflects the change in x (difference between the old & new x) that was applied in the last frame.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, Motion\");\n     *\n     * var dx = ent.dx; // the change of x in the last frame\n     * ~~~\n     */\n    _dx: 0,\n\n    /**@\n     * #.dy\n     * @comp Motion\n     * @kind Property\n     * \n     * A number that reflects the change in y (difference between the old & new y) that was applied in the last frame.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, Motion\");\n     *\n     * var dy = ent.dy; // the change of y in the last frame\n     * ~~~\n     */\n    _dy: 0,\n\n    init: function () {\n        this.requires(\"2D\");\n\n        __motionProp(this, \"v\", \"x\", true);\n        __motionProp(this, \"v\", \"y\", true);\n        this._velocity = __motionVector(this, \"v\", true, new Crafty.math.Vector2D());\n        __motionProp(this, \"a\", \"x\", true);\n        __motionProp(this, \"a\", \"y\", true);\n        this._acceleration = __motionVector(this, \"a\", true, new Crafty.math.Vector2D());\n        __motionProp(this, \"d\", \"x\", false);\n        __motionProp(this, \"d\", \"y\", false);\n        this._motionDelta = __motionVector(this, \"d\", false, new Crafty.math.Vector2D());\n\n        this.__movedEvent = {axis: '', oldValue: 0};\n        this.__oldDirection = {x: 0, y: 0};\n\n        this.bind(\"EnterFrame\", this._linearMotionTick);\n    },\n    remove: function(destroyed) {\n        this.unbind(\"EnterFrame\", this._linearMotionTick);\n    },\n\n    /**@\n     * #.resetMotion\n     * @comp Motion\n     * @kind Method\n     * \n     * @sign public this .resetMotion()\n     * @return this\n     * \n     * Reset all linear motion (resets velocity, acceleration, motionDelta).\n     */\n    resetMotion: function() {\n        this.vx = 0; this.vy = 0;\n        this.ax = 0; this.ay = 0;\n        this._dx = 0; this._dy = 0;\n\n        return this;\n    },\n\n    /**@\n     * #.motionDelta\n     * @comp Motion\n     * @kind Method\n     * \n     * @sign public Vector2D .motionDelta()\n     * @return A Vector2D with the properties {x, y} that reflect the change in x & y.\n     * \n     * Returns the difference between the old & new position that was applied in the last frame.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, Motion\");\n     *\n     * var deltaY = ent.motionDelta().y; // the change of y in the last frame\n     * ~~~\n     * @see Crafty.math.Vector2D\n     */\n    motionDelta: function() {\n        return this._motionDelta;\n    },\n\n    /**@\n     * #.velocity\n     * @comp Motion\n     * @kind Method\n     * \n     * Method for accessing/modifying the linear(x,y) velocity. \n     * The velocity remains constant over time, unless the acceleration increases the velocity.\n     *\n     * @sign public Vector2D .velocity()\n     * @return The velocity Vector2D with the properties {x, y} that reflect the velocities in the <x, y> direction of the entity.\n     *\n     * Returns the current velocity. You can access/modify the properties in order to retrieve/change the velocity.\n\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, Motion\");\n     *\n     * var vel = ent.velocity(); //returns the velocity vector\n     * vel.x;       // retrieve the velocity in the x direction\n     * vel.x = 0;   // set the velocity in the x direction\n     * vel.x += 4   // add to the velocity in the x direction\n     * ~~~\n     * @see Crafty.math.Vector2D\n     */\n    velocity: function() {\n        return this._velocity;\n    },\n\n\n    /**@\n     * #.acceleration\n     * @comp Motion\n     * @kind Method\n     * \n     * Method for accessing/modifying the linear(x,y) acceleration. \n     * The acceleration increases the velocity over time, resulting in ever increasing speed.\n     * \n     * @sign public Vector2D .acceleration()\n     * @return The acceleration Vector2D with the properties {x, y} that reflects the acceleration in the <x, y> direction of the entity.\n     *\n     * Returns the current acceleration. You can access/modify the properties in order to retrieve/change the acceleration.\n     *\n     * @example\n     * ~~~\n     * var ent = Crafty.e(\"2D, Motion\");\n     *\n     * var acc = ent.acceleration(); //returns the acceleration object\n     * acc.x;       // retrieve the acceleration in the x direction\n     * acc.x = 0;   // set the acceleration in the x direction\n     * acc.x += 4   // add to the acceleration in the x direction\n     * ~~~\n     * @see Crafty.math.Vector2D\n     */\n    acceleration: function() {\n        return this._acceleration;\n    },\n\n    /**@\n     * #.ccdbr\n     * @comp Motion\n     * @kind Method\n     * \n     * @sign public Object .ccdbr([Object ccdbr])\n     * @param ccdbr - an object to use as output\n     * @returns an object with `_x`, `_y`, `_w`, and `_h` properties; if an object is passed in, it will be reused rather than creating a new object.\n     *\n     * Return an object containing the entity's continuous collision detection bounding rectangle.\n     * The CCDBR encompasses the motion delta of the entity's bounding rectangle since last frame.\n     * The CCDBR is minimal if the entity moved on only one axis since last frame, however it encompasses a non-minimal region if it moved on both axis.\n     * For further details, refer to [FAQ#Tunneling](https://github.com/craftyjs/Crafty/wiki/Crafty-FAQ-%28draft%29#why-are-my-bullets-passing-through-other-entities-without-registering-hits).\n     *\n     * @note The keys have an underscore prefix. This is due to the x, y, w, h properties\n     * being setters and getters that wrap the underlying properties with an underscore (_x, _y, _w, _h).\n     *\n     * @see .motionDelta, Collision#.cbr\n     */\n    ccdbr: function (ccdbr) {\n        var pos = this._cbr || this._mbr || this,\n            dx = this._dx,\n            dy = this._dy,\n            ccdX = 0, ccdY = 0,\n            ccdW = dx > 0 ? (ccdX = dx) : -dx,\n            ccdH = dy > 0 ? (ccdY = dy) : -dy;\n\n        ccdbr = ccdbr || {};\n        ccdbr._x = pos._x - ccdX;\n        ccdbr._y = pos._y - ccdY;\n        ccdbr._w = pos._w + ccdW;\n        ccdbr._h = pos._h + ccdH;\n\n        return ccdbr;\n    },\n\n    /*\n     * s += v * Δt + (0.5 * a) * Δt * Δt\n     * v += a * Δt\n     */\n    _linearMotionTick: function(frameData) {\n        var dt = frameData.dt / 1000; // time in s\n        var oldX = this._x, vx = this._vx, ax = this._ax,\n            oldY = this._y, vy = this._vy, ay = this._ay;\n\n        // s += v * Δt + (0.5 * a) * Δt * Δt\n        var newX = oldX + vx * dt + 0.5 * ax * dt * dt;\n        var newY = oldY + vy * dt + 0.5 * ay * dt * dt;\n        // v += a * Δt\n        this.vx = vx + ax * dt;\n        this.vy = vy + ay * dt;\n\n        // Check if direction of velocity has changed\n        var oldDirection = this.__oldDirection,\n            _vx = this._vx, dvx = _vx ? (_vx<0 ? -1:1):0, // A quick implementation of Math.sign\n            _vy = this._vy, dvy = _vy ? (_vy<0 ? -1:1):0;\n        if (oldDirection.x !== dvx || oldDirection.y !== dvy) {\n            oldDirection.x = dvx;\n            oldDirection.y = dvy;\n            this.trigger('NewDirection', oldDirection);\n        }\n\n        // Check if velocity has changed\n        var movedEvent = this.__movedEvent;\n        // Δs = s[t] - s[t-1]\n        this._dx = newX - oldX;\n        this._dy = newY - oldY;\n        if (this._dx !== 0) {\n            this.x = newX;\n            movedEvent.axis = 'x';\n            movedEvent.oldValue = oldX;\n            this.trigger('Moved', movedEvent);\n        }\n        if (this._dy !== 0) {\n            this.y = newY;\n            movedEvent.axis = 'y';\n            movedEvent.oldValue = oldY;\n            this.trigger('Moved', movedEvent);\n        }\n    }\n});\n"},"hash":"d98f30505766a100bc752e72b75a0d02"}